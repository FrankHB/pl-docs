# 为什么我不喜欢苹果

# 0 引言

　　这篇文章本是我计划要写的一些关于苹果公司、它的产品、它的一些员工及它鼓吹的价值观相关的问题一些 FAQ 的汇总，不过这些问题时常容易引起相当零碎的争议而不便整合，因此坑了很久。因为这里和理论计算机科学、“黑客”业界以及编程语言的文化相关，也收录在这里。

　　作为意图使观点更加完整和符合逻辑的陈述，一些过于情绪化的语言在文章中将被避免。这不代表作者对具体问题的情绪化态度的上限或下限。

# 1 楔子

　　不论是什么立场，对当代科技应用史有一定了解的人，都不难赞同，苹果至少是一家不平凡的公司。它的主要创始人，[史蒂夫·乔布斯](https://zh.wikipedia.org/zh-cn/%E5%8F%B2%E8%92%82%E5%A4%AB%C2%B7%E4%B9%94%E5%B8%83%E6%96%AF)，是这种不平凡的鲜明特色的主要代表。他在这家企业中的作用和影响不言而喻。他也是苹果的一些最重要产品的负责人。借由他本人的言行，苹果公司和产品的印象被推广到各个场合。因此，对他、苹果公司和一些相关的产品的评价，许多时候是通用的，甚至可以认为是同一话题。其中特别重要的话题之一就是：如何评价他对业界的影响。

　　我没有使用过 20 世纪的苹果的早期产品。我对乔布斯的最初印象来自比尔·盖茨的传记《赢尽天下》中的侧面描述。不过，这并没有让我有多少深刻的印象。改变这个局面的是乔布斯重新执掌苹果后退出的 [iPod](https://zh.wikipedia.org/zh-cn/IPod) 和 [iPhone](https://zh.wikipedia.org/zh-cn/IPhone) 系列产品——截止今日，我从未拥有过这些产品，也不觉得这些产品合适我使用，但是产品上的一些设计和背后的更深刻的思想的思辨，对那时候的我而言是个相当有趣的话题；这段时间，对乔布斯、这些产品和苹果的印象才逐渐丰富起来。尽管在这以来的数年之中基本就有定论，我没有公开发表过任何相关的评价。直至乔布斯去世后，[理查德·马修·斯托曼(**RMS**)](https://zh.wikipedia.org/zh-cn/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC) 发表的[对此的评论](http://stallman.org/archives/2011-jul-oct.html#06_October_2011_%28Steve_Jobs%29)才让我注意到存在一段令人记忆深刻的描述：

> I'm not glad he's dead, but I'm glad he's gone.

　　尽管一贯依赖就知道 RMS 的立场和观点与我的相当不同，发现这段说法时倒觉得[颇有争议](https://news.ycombinator.com/item?id=3085765)的似乎相当自然。不过，当时也仅觉得不过如此，也并没有多追加评论的必要。这大约是因为，当年我并没有接触在乎苹果产品或者乔布斯本人的人，而不觉得我需要有对相关话题特别关注的必要。

　　之后的几年，和一些苹果产品的用户交流之后，让我改变了一些看法。我意识到，我迟早需要把零碎的看法集结起来，而最终有了现在这篇文章——似乎是时候做一个了断了。直接的契机是最近偶然翻到[一个知乎问题](https://www.zhihu.com/question/19874278) ：

> 为什么 RMS 和 ESR 等组织的开源运动领军人物如此仇恨乔布斯？\
<!-- markdownlint-disable-next-line MD034 -->
> 继10月6日Richard Stallman发表“我不希望看到他死去，但乐于看到他离去”的言论（http://stallman.org/archives/2011-jul-oct.html#06_October_2011_(Steve_Jobs)）之后，开源运动的另一位领军人物Eric Raymond在10月8日支持RMS，认为乔布斯比盖茨更加威胁自由，因为人们害怕和尊重微软，却热爱苹果（http://esr.ibiblio.org/?p=3790）。\
>苹果对开源社区的贡献要比微软大，至少推动了Webkit项目的发展。\
>近年来RMS和ESR在绝大多数问题上都意见不太一致，为什么这次却先后狠批乔布斯？

# 2 观点

　　虽然上面的问题的题主觉得很奇怪，为何与 RMS 的具有诸多重大分歧的[埃里克·斯蒂芬·雷蒙(**ESR**)](https://zh.wikipedia.org/zh-cn/%E5%9F%83%E9%87%8C%E5%85%8B%C2%B7%E9%9B%B7%E8%92%99") 在这个话题上和 RMS 是一路人，在我看来这一点都不奇怪。因为他们所说的部分，差不多就是要评价的主要观点：

* 我不在乎乔布斯本人如何，但评价他的公开活动的话，我乐于见到他不再继续持续对我所在的世界施加消极的影响。
* 和某些自由软件的鼓吹者的印象不同，苹果在这里明确比微软更有影响力，或者更确切地说，威胁。

　　在详细解释观点的缘由之前，直接引用和评论该问题下 [**pansz** 的回答](https://www.zhihu.com/question/19874278/answer/13219966)，大约也能先行厘清一下主要背景和边角问题。

> 首先，我们要搞清楚苹果是对自由软件意识形态的伤害而不是对开源软件的伤害。因此他的矛盾直接指向 RMS 而不是开源软件社区。\
> RMS 是自由软件的领军人物，Linus 是开源软件的领军人物。关于自由软件派系跟开源软件派系之争，我这里不详细介绍了，因为相关的文章已经太多，而且这主要是意识形态方面的问题。

　　没有什么问题。

> ESR 长期以来跟 RMS 意见不一致的原因是：ESR 是偏 Linus 派系的，不是 RMS 派系的。所以它意见相左很正常，ESR 长期以来一直认为，如果没有 Linus ，RMS 的自由软件运动早就以失败收场。但是当 RMS 受到围攻的时候，ESR 不出来表个态也不合适。此时 ESR 算是抛弃前嫌一致对外。

　　派系看来是莫须有的，RMS 和 ESR 两人足够知名，在正式的组织活动之外，似乎并不需要靠拉帮结派混饭。这个意义上，我倒是认为 RMS 和 ESR 对如何评价乔布斯去世的影响的话题上，确有真的共识（虽然未必特别沟通过）。

> 苹果对开源究竟是负面还是正面影响这很纠结。WebKit 其实不能算是很大的贡献，毕竟 WebKit 的源代码本来就来自开源社区的 KHTML，因而从协议上讲 WebKit 最终必须回馈给开源社区，否则就违法了。但是另一方面说，苹果产品的存在，是对 WebKit 是一种推广，因而这种推广使得这个属于开源社区的引擎具有了更好的网站兼容性。

　　想起之前还见到过 WebKit 对 KHTML 上游回馈不自觉（试图隐藏修改而不合并回上游）的消息，如果这个说法没问题，苹果确实难以算得上贡献很大，乃至可以说并不光彩。不过，苹果对自己基本能控制的开源项目应该要大方点，主要例子是早期的 LLVM 。

> 苹果的存在，还带来另外一个问题：原先不用 Windows 的用户只能去用 Linux，而有了苹果之后，人们就有了除 Windows/Linux 以外的选择。实际上，这个后果是，有相当一部分的 Linux 用户叛逃去了 MacOSX。从这个意义上说，其实对开源社区不利。

　　这个大概是事实，不过我相对表示无关心。

　　第一，事实上，我在意识形态意义上不赞同 RMS 的首要理由就是我不吃 [FSF 的自由软件原则](https://www.gnu.org/philosophy/free-sw.html#fs-definition)这套——它鼓吹的自由实在太少了，甚至不包括“用户按需自决选择使用何种软件”的自由。不包括吧，其实也就算了（毕竟很多时候还有其它法律义务上的限制没法保证这种自由），但这还显然与 FSF 不赞同非自由/专有软件的一贯立场不太兼容——否则也不会有 [GNU FSDG](https://www.gnu.org/distros/free-system-distribution-guidelines.en.html) 这样把几乎所有主流的带有非自由软件源的 Linux 发行版开除“自由系统”籍的表演了。另一个层次上，虽然独占开发资源的影响经常是现实，“自由”一开始就并不是一种必须包含“拜山头”的活动，实践自由的人即便观点不同，本就没有从属阵营之说；只不过，观点不对付的人自己结成了不同的组织针锋相对，而我没兴趣代表我自己以外的人趟浑水。

　　第二，另一个和 RMS 在意识形态或者说理念上根本不同是，我一贯历来认为确保自由的机会不是施舍物，而是要任何了解价值者自行争取的东西，更不应该是义务。自由是权利，它能够被放弃。如果有谁不在乎自由，那么这是这个人自己的事。即便鼓吹自由确实是关乎世界秩序的道德准则，要求他人符合道德水平是另一回事。进一步地，上升到道德的义务更不应该干预对权利的放弃，否则就是变相限制了权利，这是字面上对“自由”的违背。

　　第三，Linux 是个内核项目，Mac OS X 是个包含用户模式组件的更完整的操作系统，但两者都可以开发应用，这些应用可以是源代码可移植的。这个意义上，技术上不一定对开源社区不利，因为“叛逃”使用 Mac OS X 的开发者仍然可以开发开源应用。技术上，这里也并没有迫使开发者不能发布开源应用的理由；是否开源，应由开发者自行根据许可证要求等原因决定。如果说鼓吹自由软件时因为没有 GPL 等许可证的 copyleft 条款要求衍生作品具有相同的许可证会让自由软件出现的机会变少而算得上相关的话，开源软件则整个莫名其妙：比起自由软件的“自由软件正义，专有软件邪恶”的画风，开源软件运动的整个态度本来基本就是“爱开源开源不开源拉倒”，在这里纠结只会添加违背[开源定义](https://opensource.org/osd)的问题，毫无意义。

> RMS 主要强调的是意识形态，让我们回到意识形态这个问题上来，在自由软件的意识形态中，他认为：\
> 1。用户应该比程序的开发者更明白自己想要什么。软件产品应当把所有的机制的选择权交给用户。\
> 2。用户和开发者是平等的，如果用户不希望等待开发者开发他们想要的功能，用户可以选择自行开发，或者选择出钱让别人给他开发，而不必仅仅等待官方开发。

　　这是另一个我不吃 FSF 这套的更根本核心差异。

　　我旗帜鲜明地认为：**不存在理论和实际证据表明，用户和开发者具有绝对的差异。**

　　尽管可能承担不同的责任和义务，开发者并不比非开发者多长几个脑子。绝对区分开发者和作为非开发者的用户是没有道理的：

* 开发者和非开发者的角色在软件项目的生命周期中不保证是一成不变的。
	* 开发者可能有意限制自己作为开发者的能力，以非开发者的用户角色来测试软件。
	* 开发者并不一定需要给软件添加或者更改功能，甚至负责维护软件。非开发者用户经过对软件制作原理一定程度的熟悉，也可以逐渐胜任一些开发工作（例如，从写配置文件开始）。有时，这样的开发工作对正常使用软件是不可或缺的。
* 即便是不同的角色，开发者和作为非开发者的用户可能至始至终就是同一个自然人，那么“用户应该比程序的开发者更明白自己想要什么”就是个显然的逻辑谬误——他本来就同等地清楚自己想要什么。

　　而且，上述的说法其实还有其它一些漏洞：

* 用户选择的应是完成需求的方式，而非作为设计或者实现的机制。用户应当能选择软件产品在使用时提供什么功能，包括把选项去除，而交给开发者负责完成。
* 基于软件开发活动的一些基本特征，开发者没有义务无条件地同意用户的需求。如果开发者不是用户，接受不接受用户的需求应和用户的要求独立，否则用户和开发者的平等就不存在。另一方面，开发者不可能保证用户的任意提出的不明确的或者客观上根本不可行的需求。

> 那么在这一点上 RMS 永远无法调和于苹果，因为乔布斯的观点是：用户都是白痴，永远不要让用户去决定他们要什么，而是要自己设计与定义使用的方式，并且引导用户接受我定义的方式。\

　　所以，无论 RMS 跟 Jobs 的观点有多少冲突，这都不奇怪，毕竟 Jobs 的模式是完全反自由软件社区的。

　　这一段就正好可以看出上述观点和乔布斯的观点彻底的对立。虽然形式上看起来，乔布斯和 RMS 的观点（“非开发者用户不应该比开发者想要什么东西”“非开发者用户应该比开发者更明白自己想要的东西”）相对于我的“开发者和非开发者用户没有绝对的差异”的观点的差异是对偶的，但在默认对方是开发者之后，面对乔布斯的人只能首先屈居于非开发者的普通用户的角色。这时候，乔布斯的一贯践行的做法就是直球侮辱：被在了解自己想要什么的问题上，**你这个用户的意见在我（和我认可的团队）面前就不配被尊重**；相比之下，RMS 的表达看起来至少有起码的礼貌。

　　即便现实中，乔布斯并没有当着一个用户的面说“你是白痴”，但只要这个用户没有彻底放弃至少和开发者具有同等地位或者话语权的时候，正常情况下就不可能会赞同乔布斯表现出来的旁若无人的、独断的决策。特别地，如果接受乔布斯这种开发者凌驾于非开发者用户之上的观点，这种不尊重就愈发明显。

　　这种“我是你爹”式的态度颇有封建家长制的遗风，但是对不接受家长权威的而不吃这套的人面前，恐怕除了引起厌恶外，毫无作用。不论面对乔布斯的用户是居于我还是 RMS 的观点，乃至一些语气上更弱但区分了开发者和非开发者用户身份认同的观点，都自然不可能接受乔布斯的态度，乃至可以把这种表达和支持乔布斯的这种观点直接视为一种挑衅和敌对行为。代入 ESR ，在考虑对开源或者自由软件运动的观点乃至信仰之前，他极有可能就也是这样想的，所以支持在这里 RMS 也是非常自然的。这个意义下，一些答主回答的尽管是周知的事实，很可能偏离了这里的核心，如：

　　[**安江泽** 的回答](https://www.zhihu.com/question/19874278/answer/13220155)：

> Richard Stallman痛恨苹果和苹果封闭无关，RMS仇恨一切商业许可协议和非GPL开源许可协议。

　　[**keso** 的回答](https://www.zhihu.com/question/19874278/answer/13220829)：

> RMS和EMR都是将自由软件当作信仰的人，他们反对一切形式的对软件的控制，这种反对有时候到了宗教极端主义的程度，所以，他们的言论并不令人感到意外，他们对自由软件的信仰，让他们有时候看起来固执而不懂世故，这也是他们之所以令人尊敬的原因。

# 3 信仰

　　与上面讨论的不同，一些乔布斯的信徒可能没有上面提及的任意一种关于用户和开发者地位的思辨，而直接把乔布斯的观点视为无条件遵循的信仰，那么自然和不接受这种观点的人在原则上就是不可调和的了。虽然一旦上升到信仰，逻辑上就和公理一样没什么解释的余地了，但毕竟不可能出现人人都是乔布斯信徒的情况，对“异教徒”的交往通常还是不可避免的，所以如何解释信仰的合理性仍然会体现出信仰会有多少水分。

　　在说服接受观点的意义上，大部分作为乔布斯信徒的果粉是占据决定性劣势的：不管是我、RMS 还是 ESR ，都是（至少相比乔布斯而言）深刻理解程序实现原理的关键位置和开发流程的专业程序开发者，比通常仅作为产品经理实质参与产品设计的乔布斯更熟悉制造一般软件的技术乃至整个软件生命周期（包括如何收集和处理需求）的实施细节；而大部分果粉对具体产品的理解都是靠乔布斯的理念引导的，有没有独立地超过乔布斯本人对产品的思考都很成问题，更不用说评价产品设计和实现与需求对应程度的能力了。外行凭什么在专业问题上说服专业人士，这实在不应该存在什么悬念。

　　但是，偶尔还是会发现看上去似乎专业的人士也倾向于信仰乔布斯的这类观点。例如上述知乎问题上一个署名**冯东**，注释“编程话题下的优秀答主”的回答：

> RMS 和 ESR 的评论无非是因为 Jobs 和他们的某些思想不合。这是一种很懦弱的行为。思想不合，就需要你用自己的行动来证明自己的思想是正确的，而不是期待对手死掉。退一步说，对手死了，你可以暗自庆幸，并且利用其不能反驳的机会宣传自己的思想，但不可以就对手离开本身做文章。更可笑的是，还担心「他死了也有人追随」这样的事情，让他们作为思想领袖的身份成为笑话！

　　如果说这些人和乔布斯都只是“思想不合”，那怕是对这几位的侮辱。即便不是众所周知，了解一下新闻报道，就很容易发现这些人都是作为行动派闻名的。也只有忠实于思想积极的行动才有证明评价的必要。

　　特别是考虑专业背景，懦弱就显得尤为莫名其妙了。RMS 和 ESR 作为专业开发者首先直接行动就表明“我就是可以不用你苹果家的东西而满足我的软件需求”，这是最直接基本的被动反击技能——虽然这种开发的门槛很多情况下其实不高，但乔布斯本人的技能都难以独自支撑他完成类似的行动。

　　其次，基于 RMS 和 ESR 的工作能够支撑起完全脱离苹果产品的实用计算机系统甚至成为系统中的关键组件，反而苹果长期以来没多少底气排除异己。特别值得一提的是，Mac OS X 最关键开发环境的核心组件—— C/C++/Obj-C 编译器长期依赖 RMS 发起的 FSF 旗下的 GCC ——基本可以说没有 RMS 当你开的坑，苹果在这上面恐怕到现在都没什么选择。也正是主要因为受了 GCC 许可证和对 Obj-C 支持不上心的气，苹果才加大力度扶植 LLVM 新搞个 Clang 替换上面的 GCC 前端；这在当时也远没能成熟到跟 GCC 分庭抗礼的程度。

　　对着这种外强中干的“我是你爹”调调卑躬屈膝，恐怕才是真正的笑话。

> Apple 对 Open Source 只有贡献，没有伤害。贡献了大量代码，启动了一系列项目。比如 compiler，长久以来业界被 GCC 压制，都不考虑 compiler 应该作为 library 才能提高技术的发展（比如 IDE 集成，JIT 集成，OpenGL shader 集成），只有 Apple 才解放了业界的思想。Apple 对 Open Source 从无恶意言论和举动，凡事都遵守 GPL 和 BSD 的游戏规则，为 Open Source 赢得了巨大的关注度。

　　已经提过的 KHTML 的问题不重复了。GCC 实际上并不是没有考虑过拆分成 library ，但是拆起来的代价嘛……不过这个在苹果这方面恐怕算是个次要借口，最主要的还是许可证问题。至于“解放业界思想”，别说是编译器写的 C++ 代码模块化……也不用刁难不够专业的了，先确定一下，SSA IR 的编译器好意思代表编译器技术了？

> 另外，借此谈我对 Open Source 的看法：\
> 1\. Open Source 关乎软件质量，而非用户权利。Open source 是因为软件过于复杂而必须采取的一种协作方式，而不是什么权利申张。这一点 ESR 本身也是同意的。如果说 open source 是权利申张，为什么 BIOS 和 x86 CPU 都不 open source？\
> 2\. Linus 说过，给用户最好的，而不是操纵用户。反观 FSF 的很多做法，毫无考虑用户的感受，相反只是刻意的给 proprieatary implementer 设置障碍。这是 manipulate people 的做法。

　　这倒是更加说明了 ESR 支持 RMS 的观点原因跟这里的看法无关了。不过这里的看法倒是有点好笑，x86 CPU 不说版图，RTL 代码的复杂性光算体积就怕不输大部分商业软件项目的源代码了（我也算看过了一部分，多少可以判断一下），照这个说法，岂不是应该开源才对？然而都 2021 了，就没一个工业级实现开源过。倒是 2010 年开始搞的以开源 core 当作核心卖点之一的 RISC-V ，现在都已经数不大清几个商业项目了。

　　专业人士的这类信仰如何而来，也难以全部列清楚。不过，除了直接利益相关，最可能是因为无知。毕竟专业细分领域非常之多，乔布斯本人在产品设计的本行上间断翻车了几十年，误判例子不胜枚举，何况连跨领域知识拎不清楚的假内行？无知导致盲信，加剧了这种状况。

# 4 作用

　　虽然上面提了 ESR 挺 RMS 最可能的还是简单的态度问题，但是更深层次的立场也足以让 ESR 和 RMS 同意乔布斯领导的苹果是一个影响全局的风险源头。严格来讲，这里的主体不只是苹果，还有更多不胜枚举的乔布斯信条和苹果模式的追随者。不过，默认还是集中讨论乔布斯和苹果的罪。

　　这里有很多的问题，但最根本的，恐怕还是乔布斯领导下的苹果做了不应该做的事，**破坏公共利益**，却长期没有受到对等的制裁，到现在还刹不住车，甚至连有效遏制苹果薅公众羊毛的手段都还不存在。乔布斯在没有对业界长期利益做出足够预判却又能调动大量资源支持他的独断风格的决策，在一系列偶然和意外的奇妙作用下，成功地透支了业界的潜能，而攫取了大量的现金利益，却没承担什么代价。这些代价可能使若干领域的技术进展长期停滞且难以有效缓解，或许比不动产泡沫透支整个实体经济消费者的购买潜能更加严重。

　　上纲上线一些，乔布斯（有意无意地）让潜在的市场极大地缩水了。考虑到现有的市场容量已经足够惊人，这里的规模不容小觑。据我个人~~不可靠~~估计，按近几年购买力折算，原本潜在的市场约数千万亿美元，但这么一折腾就只剩下不到百万亿美元了。作为对比，黄仁勋为代表的上次 AI 寒冬以来的新兴 AI 产业在 AGI 真正到来之前，可能也就 40 万亿美元——这个数倒不是我编的，不过这里我的观点主要是强调数量级，所以暂时懒得查证出处。

　　更糟糕的是，乔布斯在商业上的继任者蒂姆·库克看上去仅仅像是个合格的企业家，玩花活的手段远不如前者（不过也不能太怪后者，只要不彻底背叛这里乔布斯遗留的理念，换谁恐怕都不会好哪去）。苹果公司这些年创新乏力、营收越来越靠吃老本（以及糊弄人，比如借口“环保”和抽苹果税“降本增效”）也快成了公共刻板印象——即便是果粉中也有不少同意这点，怒其不争。然而数据（不论是营收还是定价亦或是供应链）表明苹果在吃老本这回事上其实仍然保持了资本主义式的经典高效。这使市场容量肉眼可见地缩小。这种缩小并不能通过竞争对手（如安卓阵营）的对抗手段减缓多少（事实上不少安卓厂商越来越反对开放 root 权限这点本身就有向苹果看齐的意味，某种意义上足以令人怀疑就是因为眼红苹果的短期数据打不过就加入，才被带偏了）。以苹果的体量，带动各个上下游产业竭泽而渔，透支市场容量，甚至足以让人联想到经济危机和消费主义社会的末路。虽然不能说这些后果就是苹果导致的，也不能指望没有苹果问题就会自然地被解决，但苹果们的经营策略和价值理念已经足以恶化宏观经济的形势和愿景。一个主要产业实体的组成部分在“做大蛋糕”（另外一点——优化资源分配——在全局上苹果当然还不配管）这件事上明显有失担当，这就远远不只是市场和经济上的问题了。

　　实现这种机制的核心是乔布斯式独断和苹果的应用商店。这里的实现方式还颇有些波折。

　　和许多专业技术人士的认识不同，乔布斯历来笃信封闭和独断控制上游内容来实现所谓的“安全性”，甚至到了偏执的程度。第一代 iPhone 的时候乔布斯就不同意应用商店的设想，理由是第三方的应用可能带有病毒之类的风险而不安全。不过之后他还是同意试试上线应用商店，讽刺的是，取得了显著的商业成功，至今仍然是苹果公司的重要收入来源。

　　虽然有了商店，iOS 等移动设备使用的系统受到乔布斯影响下的极端封闭传统仍然一直保留了下来。除非机器经过破解（“越狱”），在 iPhone 等设备上安装的应用具有苹果认可的证书签名，技术上做到了用户不管直接或者间接安装什么应用都要经过苹果同意。这实际上把苹果置于和任何非苹果开发者和用户的总体对立面上：只有苹果和苹果首肯的开发者才配当真正的应用开发者（至于系统，外部开发者就别想了）。

　　应用最主要的发行渠道是应用商店，这里苹果就是天王老子，不听规矩别想上架，内购抽税（大概也就极个别规模跟苹果能够比较的垄断企业还能讨价还价）。想绕过应用商店部署，要么指望各种乱七八糟限制的测试版，要么老实买更靠谱的证书。市场上流通的苹果证书稳定性时效不一而足，可用性好一点的企业证书价格不菲——因为苹果限制了买证书企业账号，一般也只能找二道贩子，还记住物以稀为贵。即使是自己开发应用自己用，都需要注册开发者账号老实交钱，不便宜，还有数量限制。这就先把开发者当长毛的羊了。

　　能上架商店的应用，乱七八糟规矩中记得有一条离谱的：禁止动态执行本机代码。据说，这也是为了所谓的安全性，免得稀里糊涂过审核的应用里混了一坨不该被执行的代码最终稀里糊涂地执行了。于是，各家应用要热更新基本都得指望解释脚本。然后浏览器 JavaScript 引擎也被波及无法 JIT 便宜，为此苹果果断只许州官放火不准百姓点灯——动态 JIT 编译执行 JavaScript 特供 Safari 。后来算是包装成 API 给别家浏览器用了（但是用的其实就是 Safari 那套）。那么问题来了，不是 Safari 难道就低人一等了吗？

　　这种凡是当应用能跑的东西都得听苹果（而不是用户，不管用户是不是开发者）的话的政策，使得 iOS 等系统上的应用开发环境极为诡异：不仅仅乔布斯的理念上要彰显“我是你爹”，技术上也要处处渗透。如此技术细节的限制自然相当不可能是乔布斯亲力亲为，但在领会上意的精神上，苹果的技术人员恐怕被乔布斯那套调教相当完善。

　　当然会有开发者对种种 iOS 乃至应用商店上特供（而其它类似的非苹果的环境中）的限制提出不满。但比起苹果的体量，基本上所有的独立开发者都算不上啥，知名大企业跟苹果撕了然后被下架的也不是没见过。

## 4.1 应对思路分析

* 惹不起躲可以吗？
	* 行，但是上架应用商店的收益就别想要了。
* 那么干脆整个无视苹果的平台呢？
	* 这个也行。不过，如果还是打算在替代的近似领域里盈利，那还是得悠着点，因为 Windows Phone 这种 1% 啊什么的不用想了，能跟 iOS 整体对抗的就 Android 。
	* 虽然 Android 用户加起来明显更多，但是销售可没那么成比例，而且各种学苹果自己开应用商店的渠道一大坨，想赚钱，大腿一个个慢慢抱过去吧。
* 那么再退一步，干脆就不卖软件了，整得那么麻烦——都用爱发电做慈善得了？
	* 这个真行，不过 iOS 之类基本没实用意义上的可行性，而 Android 搞起来其实也挺麻烦的，要么就直接要求 `root` 权限然后按 PC 那套搞了……
	* 到这里，才算彻底逃脱了应用商店模式的阴影。

　　当然，还有屁股在苹果这边的可能强行提问：不用应用商店那么你怎么赚钱？呃，虽然我没有非得把屁股往这里挪才能生存的道理，这方面的答案倒也不是没有……不过，确定这是能免费听的嘛？

## 4.2 应用商店到底是咋回事？

* 其实，应用商店的整体作用，除了最简单分发管理应用、让用户浏览信息和提供安装入口外，其实几乎全是给开发者找不痛快的。
	* 实现这些功能，根本不需要应用商店这种形式，传统包系统管理器外加一个 GUI 前端足以做到。如果不是考虑如何盈利、支付和分成之类的破事，光是开发应用软件这个纯粹的目的，相比传统 PC 的开发工作流多出来几乎全是无用功。
	* 而且，对非开发者的普通用户而言，安装部署的体验经常也比 PC 上的应用更差。
* 苹果和跟风苹果的各路应用商店们，实际上做了什么呢？
	* 也就是建立了一种新的韭菜收割方式——把没见过像样的软件部署分发的小白用户吸引过来作为自家设备和服务的用户；
	* 然后把既有的知道其它平台的用户踢开，就不用太在乎用户抱怨什么了；
	* ——反正剩下的用户里都是连发牢骚都没经验的。
* 作为代价：
	* 这些用户习惯了这些“工作流”之后，就不会再奢望厂商改进什么了——因为他们没见过，也基本不可能有想象力猜出真正服务于用户的软件的设计应该是什么样的；
	* 而本来这些用户，是可以在见识到更多的不同平台的使用体验以后，推高各种不同设备上的应用应该具有的设计的最低门槛，而推动整个业界持续进步的。
	* 这个意义上，应用商店这种寅吃卯粮诓骗用户的垃圾策略，跟妄图一厢情愿控制生育率生育政策一样值得被鄙视——或许因为长期损害难以恢复，而更加危险。

## 4.3 应用商店这个模式如何被推广，之后会怎么样？

　　苹果能吸引各路应用商店跟风，是因为它足够“成功。”这主要是以卷入的市场容量和现金流来计量的。对资本来说，现金回馈是硬道理，这本没有错。但这实在不是能长期健康发展的市场增长模式：

* 过于依赖分发渠道，导致开发者受到技术上荒谬的限制，丧失大半定价权。
* 限制了用户本该能体验到的软件和服务。
* 另外，这还会加剧不同用户的对立。

　　最后一点在另一个细分领域——视频游戏——中更容易见到。因为历史原因，传统的游戏分发方式普遍不容易盈利，所以现在的游戏普遍非常依赖分发渠道，也出现了类似的问题。手机游戏这种传统上轻量的游戏方式，被作为重要的利润来源，市场爆炸式增长。这些游戏的用户，不少是之前连 PC 游戏（不说主机和掌机了）都几乎不碰的小白玩家，普遍缺乏对作品质量的把关能力。不熟悉游戏应该是什么样子和能有什么样子用户，被渠道一搅和把游戏偷换概念成了手机游戏，很容易自然而然地以为手机游戏就是他们想要的游戏了，而被拖到坑里——很大程度上被剥夺了体验其它形式游戏的可能性。其它载体和形式的更专业的、类别更加丰富的各种“传统”游戏厂商，则在面临用户流失无力增长的困境的同时，还得继续承担游戏行业的资本流入手机游戏市场的后果。久而久之，不满手机游戏的传统游戏玩家会逐渐陷入越来越难以找到新发售的游戏可玩的情况，整个市场缓慢地李代桃僵。除了投机的热钱外，行业内没有谁实质获益，反倒是未来的潜在用户被提前当韭菜割了个爽——而韭菜们其实也没体验到多好的游戏。

　　把游戏换成更一般的应用，再放慢点节奏，可能就是苹果式应用商店和它的用户们的命运。不同的是，相对游戏领域分发渠道的起初的集体无意识，一般的应用显然受到了别有用心的（认为用户是小白且应当是小白，当用户的爹）召唤。用户本来就有潜力自觉地接受他们真正需要的东西，莫名其妙出来一个不知道是先知还是爹的教他们应该需要选择什么东西之后，就难逃死局了。

　　虽然乔布斯本人对用户的不尊重早就溢出（比如发布会上就差直接鄙视大屏机和使用手写笔的用户），大部分人仍然没有意识到走出困局的必要性——能从 iOS 走到 Android ，就已经算是普通用户中有见地的了。另一方面，或许还就是因为乔布斯个性过于鲜明，才让一些用户注意到其实乔布斯差不多一直就没从自己身上的真实需求出发去考虑怎么让设备更好地替用户实现价值。正好 Android 这边，妄图复制苹果“成功”的功利性表露得相当明显，但讽刺的是也就是因为 Android 设备和设施没怎么抄得太像 iPhone（比如 Google 商店没那么垄断），所以反倒显得像是尊重了用户（除了 Java 的选型）。虽然 Androif 系统设计也未必多尊重用户，但始终缺乏一个能和乔布斯相提并论的存在，也让 Android 用户更加习惯了“多试下不同 UI”的绥靖。对任何不认为自己是小白的用户，乔布斯的形象自然很猥琐，如果不是开历史倒车的话。

　　再往上看，可以发现所谓的“智能手机”被 iPhone 崛起时的厂商集体偷换了概念。“智能机”显然不是这个时代的发明，先前的 Windows Mobile 和 Symbian 就是例子。虽然这些古董有许多陈旧和不尽如人意的设计，但是没有应用商店，在潜在的市场储备上要比现在好得多。由于配套带有应用商店的设备的冲击，这些古董悉数淘汰，没有什么风浪。在用户和厂商逐渐流失之后，最接近的大概也就是新的所谓“智能机”了，可惜后者对用户和开发者的各种离谱限制，导致了重建一个功能丰富的生态几乎不可能实现（想自立门户，最后怕是也会被迫转型为应用商店），基本上不会提供更好的体验。

　　继续往上看，这些用户，其实影响的并不只是手持便携设备。许多用户从来没有怎么深入了解过计算机。如果先体验足够长时间的如 PC 这样健全一点的软件环境，熟悉怎么对付不听话的应用和真正便利的多任务管理，再去使用所谓的智能手机，那么粗制滥造的应用怕是没那么容易轻易占据市场份额，反过来出现不给权限就罢工的方式要挟用户之类的乱象。

　　考虑到这里，说乔布斯以一己私利摧毁了这个星球上这几十年的软件业也毫不为过。

　　也不需要提及自由软件或者开源软件的理念问题，光是看看同样在软件卖钱上打主意的——比尔·盖茨还能算是有些启发作用而被当作先行者，相比之下乔布斯就是个把用户忽悠成小白（其实本来不都是），然后让不成熟的小白用户大量涌入，占据多数用户后，取消原来真正的用户的话语权的带恶人。这恐怕就是 ESR 会认为乔布斯比盖茨更有威胁的底层逻辑。

## 4.4 如果没有类似乔布斯的野心家干扰历史的行程，会怎么样？

* 在这个 IF 世界线中，最有可能的首先就是 iOS 和 Android 不会在市场上以成熟系统的面目出现，也不会有现在那么多用户。
* 这些用户短期内可能根本不会接触到所谓的智能机，而智能机仍然维持原来的节奏更新汰换，直到相对成熟才铺开推广。
	* 成熟的表现可以有很多，不少也适用 PC ，比如能方便普通用户使用的可编程的[强制访问控制](https://zh.wikipedia.org/zh-cn/%E5%BC%BA%E5%88%B6%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6)管理界面。
* 即便用户更晚地接触了新型的设备，到现在也不至于在这方面一边跟各种倒腾各种管家，另一边拿着一坨权限列表和不规矩的应用挨个儿斗智斗勇。
* 另外更多的人可能压根就不需要是所谓智能手机的用户就能有更体面的生活（手机就管手机，各种智能家居就能伺候得够舒服了），而不是浪费资源损害需要用户的利益。

　　然而现实没那么多如果。本世界线中，**乔布斯重新定义了智能手机顺便把这些八竿子打不着的人强行变成了用户，原来真正的适格用户从这个世界上几乎被消除了**。

## 4.5 使用智能手机的权利

　　之前跟人讨论过相关话题，有人提到，让一些人不去用智能手机，岂不是剥夺了其他人用智能手机的权利？并不是。现在那些对 `root` 一知半解的半吊子用户跟风嚷嚷要安全的机器“正常就不该有 root 权限”剥夺了本来不需要啥代价就能安全获取 `root` 的用户以管理员的身份管理自己的财产，才是真的。

　　另外现在这种情况还有更多比较抽象的不好直接理解的不对劲，夹杂点类比将就理解一下：

* 智能机本质是便携式计算机，通信终端其实只是附属功能，本来并不需要多智能。为了发挥智能机的真正的作用，需要一定的扫盲训练（具体来说，像 shell 编程）。
* 可以认为现在大多数不足以驾驭完整功能的智能机用户是文盲，而原本的适格用户是经过识字教育的少数人。
* 没有人出生就识字（会使用软件）。
	* 识字需要学习（使用软件需要专业训练），否则就只能学学怎么说清楚（提清楚需求）应付平日生活，偶尔请先生（专业人士）帮忙代笔长篇大论（制作复杂的软件）。
	* 注意，这里的软件不只是所谓的 app ，也包含一般意义上系统管理员使用的各种命令和实用工具。
* 像古代一样（市场本来就不成熟），文盲天然多数（大部分用户使用软件基本抓瞎），而真正顺利接受识字和更高级教育的是极少的“贵族”（天赋卓绝或相关专业学有余力、有能力投入者）。
* 正常情况下，随着时代的发展（市场的成熟），扫盲教育（使用软件的入门训练）会自然普及，或者也可以被热心乡绅（公益助学力量）推动。
* 但是突然跑出了一群叫做苹果的妖孽，他们的做法并不是帮助普及教育，而是说你们这字太难学不好用，应该用我们的文字（专有系统和软件）；顺便垄断收钱。
* 因为苹果的文字写起来初看起来的确简便（专有系统和软件完成简单任务方便），所以更快普及流行了。
* 接受苹果教育的脱盲人士（只会适应苹果系统和软件的用户）发现原本的字（先前的软件）还是不认识，但是因为苹果的热心洗脑教育，不碍着他们逐渐变成大多数。
* 这时候，他们认为原来识字的学徒和先生（使用传统软件的熟练用户和专业人士）整看不懂的鬼画符，过气（传统软件不实用，难用，落后），约等于不识字（不会用软件解决问题），不如彻底废弃用苹果文字取代，后者才是先进的方向。
* 这自然会引起有识之士的反抗：原本学得用的好好的，怎么就落后了？敢试试把你说得出来的东西全写清楚不（能表达任意的需求）？
* 被苹果教育的那群人，根本就不够有能力克服原本的门槛，不明白字为什么要这么写（为什么软件设计成这样的操作），更不能利用原有的丰富的文献（大量的强力的通用工具软件）。
	* 当然还是有少量常用的文字（邮箱、浏览器之类）各种写法（不同环境下的使用）其实本来就是差不多的。
* 为了证明苹果文字的先进性，同时让他们认识的苹果文字有用（符合苹果系统和软件的使用习惯）而不是发现被耍了，编制新的口水书（开发功能不怎么样的应用）的需求就出来了。
* 于是，大量的文人（开发者）被贿赂征召（许诺应用分成）去编写会被放到藏书阁收藏的苹果文字的书（开发上架苹果应用商店的应用），它们的内容质量远远不及原有的文献（传统软件），却更加普及流通，甚至到了不编写苹果文字的书（不开发苹果应用）就不配当文化人（专业开发者）的程度。
* 苹果规定，任何人不准私藏包含没有经过苹果批准的文字的书（安装未签名应用）。这样，真正有价值的传承越来越难以发挥本应有的作用。
* 在到达这个程度之前，一群叫做谷歌的妖孽也抄袭了苹果的做法，自己发明了接近苹果的文字（Android 软件）。
	* 谷歌的做法和苹果大体类似，只不过相对写书的（开发者）更友好，没那么多条条框框（审核没那么抠），没那么强调“最终解释权”，藏书阁（应用商店）也没那么权威，允许自由处理藏书阁外的书（可以不经过商店安装卸载运行应用），不过传统的（Linux 本机应用）还是麻烦。
* 有很多群山寨谷歌（其它 Android 厂商）及其藏书阁（私有应用商店）躲在谷歌管不到的地方吸收群众（发展用户），自己玩自己的。有些允许完全解禁参阅传统文字的书（安装 Linux 引用），但是要先登记办理解禁手续（解锁 bootloader ）。
* 对没有学习过传统文字（使用传统软件）的人来讲，发明新型文字（应用格式）和藏书阁（应用商店）的苹果谷歌之流就是神仙了，他们想象不到没接触过的东西本来能够如何强大。
* 问题是，不管苹果谷歌和它们的山寨者怎么倒腾，他们并没有表现出上古传承里的完整内容（功能强大的传统软件）。结果：
	* 总的学习负担更重了。
	* 虽然迟早有人会发现，还不如只鸟传统的东西，但是没有见识过上古传承的小白来讲，不太可能同时怀疑苹果和谷歌都是有问题的，最多觉得其中一个不顶用。
	* 而原来保守传统文字的人（传统软件用户）就更加落魄了。明明什么错都没有，就是不想关心作用更差的媒介，结果被反过来当作文盲。这不是搞笑么？
	* 危害还不止这一个。因为盲目招揽群众（开发市场），原来能够自觉跟上传统文献中记载的先进文明的小白用户走上了歧途，想要去理解这些先进文明都不是件容易的事——除非真正发现了苹果们的恶而划清界限。——大部分人显然是没天赋做到这个的。

## 4.6 外部影响

　　苹果扮演的“智能机”先知的角色，跟把谭×强算作是 C 语言之父一路货色了。智能机从来都不是苹果发明的，就苹果的篡改和谷歌之流的推波助澜，都是对原来用户的侮辱。就算不计较经济利益的问题，会给他们好眼色看才怪了。

　　其实绝对数量来说，信仰传统文化的人还不少：PC 世界几乎全部不是苹果的信徒。所以很讽刺地，微软变成了（多数票暴政意义下的）弱者们的卫道士了。

## 4.7 正当性

　　苹果有什么资格在这里敢为天下先，牵着人鼻子走呢？就凭市值足够高、市场份额足够大、影响足够大？

　　这些全不是苹果在道义上应该得到的东西。苹果做的实际是什么？除开少量时机是否合适有疑问的创新（例如推广电容屏），整体来看，就是编造篡改现有的知识，以次充好，放任和鼓励劣币淘汰良币，对市场揠苗助长以及开不良风气之先伙同谷歌等竭泽而渔，而全然不顾“生态”可持续的恢复。正因为资本市场大部分也是这里的小白用户，所以一直没有反应过来，就算反应过来也没法阻止了。

　　具体操作上，苹果甚至并没抓住用户的需求。主要套路是，瞎蒙小白以后会有一些什么需求，在没有能够能力满足这些需求的情况下，偷换了一个似是而非的东西，强行作为需求；至于这个需求和真实需求有多少共通的地方，在具体产品出来之前，怕是没谁能有多少底的。这显然也很符合乔布斯本人的风格。而之后乔布斯篡改的一些需求也经不住历史潮流，比如他嘲笑的大屏手机成为了市场主流——即便这些主流的用户大多数都是当年臆造需求强行开拓出来的市场的“新”用户。这也说明，再小白的用户也不可能一直都是傻子（虽然就发现大屏机需求来讲，有其他厂商的作用）。

　　总体来说，苹果根本没创造多少价值，它只是编造了一种新的投机途径，把原本市场能够自然发展的潜力提前挖掘一空。这样的价值的确够撑得起市值，但是长期公共损失哪里是一个苹果够填的？

## 4.8 Google

　　说起来 Google 蒙需求的水平其实很差。就移动操作系统，赢过苹果的部分，不少就是更符合传统价值观的部分，比如：

* 开放。
* 真后台。（毕竟一个本来真多任务的内核非得因为怕用户太傻应付不过来或者其它原因去伪装单任务系统的设计，实在过于沙雕。）

　　Google 的水平如果很好的话，其它厂商没那么多机会“分裂” Android 。虽然这个跟各个市场具体国情也有关系。而苹果的水平可以说主要就是乔布斯带出来的。后面的库克就没那么给力了。事实上，很少有人能蒙对那么多东西，或者厚脸皮强行把自己钦定的东西推广到大量小白身上还被接受了。说乔布斯是邪恶天才一点问题都没有。

## 4.9 其它舆论作用

　　苹果的商业成功引起的市场霸权还暴露了一些人普遍的软弱性。这部分还包含本来手持充分资本能对苹果说“不”的人。

　　以[马克·扎克伯格对苹果产品的评价](https://www.ithome.com/0/750/540.htm)为例，可以看出，即便是大型的竞争对手乃至先行者，面对苹果，也没什么余地正面叫板。

　　某种意义上这也没办法：靠 C 端走量的评价产品吃饭的老板在产品力的问题上，经常还是很怂的，即便产品力实际上更多是思维定势。因为苹果产品的主要缺陷（除了贵或者性价比差）确实在（即便没经过苹果教育过的）大众面前不那么明显——只有少部分始终跟得上乃至引领目标应用场景的核心用户才能清楚、全面、独立地理解满足需求能力的不足，以及这些产品的普及会牺牲用户哪些本应该享有的东西。所以如果要避免对大众过于专业的说法，着实不那么容易说明白苹果产品的劣势，或者自家产品的相对优势在哪，只能转进先全盘承认苹果的商业成功是来自产品以及营销（而不论这些成绩的取得有何历史背景以及是否涉及滥用市场地位的不正当性——那实在太跑题了）。

　　（作为对比，这些年吃 B 端饭战略的微软，对这种问题就有底气完全冷眼不管了。虽然 HoloLens 是失败品，但不靠这些改善业绩，甚至砍了也不影响整体营收和调性，自然完全没必要下场掺和。）

　　不过这里更大的槽点是：既然扯历史那就别隐含多数票保证讨好“多数”人口嫌体正直呗？

　　注意这里没有群众史观和英雄史观的对立。无论是苹果还是 Meta ，都是吃的 C 端消费者这样的“大众”的饭。苹果的创新程度在此也远达不到算是英雄的程度，也是泯然众人之一（就是 iPhone 去掉伪装的钦点“智能”的面纱，也不过如此——从历史的角度看，普及不成熟的电容屏支棱不起多大的变革）。

　　关键是，一个特定时代的大众，相对历史的行程中全体群众的存在感，有多大的代表性呢？

　　已有的历史不能说明这个问题。历史上多数人还不识字呢。历史谁书写的？

　　这里的主要教益是：不能把关于对现在和未来几乎所有人都能有深远影响的问题的话语权拱手让给特定时代的从众者。除了让少数人赚得盆满钵满和满足个别人的自满（被卖了还帮数钱），这对谁都没好处。

　　马克·扎克伯格可能是不得不出来发表意见刷新存在感；在舆论上先发制人或许比被逼得出来发表观点还是好得多。但只是这种程度，就免不了很大的酸葡萄嫌疑了，丝毫无法以退为进，殊为不智。须知，即便是 Quest ，也远没有便宜到足以向多数用户普及类似的设备（至是不是值这个价，见仁见智）；不论如何划分目标用户群体，都缺乏决定性的竞争优势，并没什么吸引大众改变舆论导向的可能。

## 4.10 其它的影响

　　如先前说过，一些细分领域也有类似问题：

* 手游市场对传统视频游戏也多少是一样的套路，欺负原本根本不是游戏目标用户的小白成为手游用户瓜分他们的时间和钞票罢了。
* 短视频对传统视频，传统视频对更传统的网站，都有类似噶韭菜的性质。
	* 但是，相对来说，它们好歹还是有些独有的创新的，比起手游创新的基本就是氪金套路来讲，健康得多；更不提苹果商店模式和智能机概念的谎言了。

# 5 技术

　　苹果具有一些专有技术。

　　有的技术原本是封闭的，然后被开放，如 Swift 。

　　技术上并没有明显的作恶，但是客观上因为各种局限性，并没有改善市场或者反而使市场环境恶化，有失担当。

# 5.1 LLVM/Clang

# 5.2 Objective-C

# 5.3 Swift

# 5.4 Safari

　　需要强调，本文在引出主要观点的讨论中使用的理由不依赖软件实现的技术问题。

　　否则，技术上来说，不使用 Safari（更确切地，其中的 JavaScriptCore ，所以实际上包含了 iOS 上的“换皮”浏览器）在现实可用的用户权利意义上确实低人一等，因为[这是唯一在客户端应用提供 ECMAScript 6 的 PTC(proper tail call) 的实现](https://kangax.github.io/compat-table/es6/)。

　　理由（因为无法指望消除的理解门槛，大多数读者建议跳过）：

* 这项特性是 ES6 的最重要的改进，**没有之一**，即便是专业开发者也很可能难以**意识到**（不提理解）这点。原因可能是……专业能力普遍不足。
	* 这里的专业开发者包括制定 [ECMA-262](https://www.ecma-international.org/publications-and-standards/standards/ecma-262/) 的不少 [TC39](https://tc39.es/) 专家组成员。
	* 否则，就不会有那么多[莫须有的争议](https://github.com/kangax/compat-table/issues/819)。
		* 特别地，部分 TC39 成员反对 PTC 而提出 [STC(syntaictic tail call)](https://github.com/tc39/proposal-ptc-syntax) 的替代方案，[体现出他们不清楚 PTC 的特殊性](https://github.com/tc39/proposal-ptc-syntax/issues/23)。
		* 不提理论重要性，其中一些实际阻碍 PTC 实现的工程理由就是错的。
			* 甚至 [Google V8 曾经实现过，一年后又去除了](https://bugs.chromium.org/p/v8/issues/detail?id=4698)。
				* 这工作量并不小，瞎折腾了属于是。
				* 于是这里倒是有充分理由可以鄙视 Google 的一些工程师的品味以及无组织无计划性。
				* 虽然[迫于 WebAssembly 的要求过了几年又给加回来了](https://v8.dev/blog/wasm-tail-call)。
			* 相比之下，Mozilla 和 Microsoft 在这里基本是无能。
				* Chakra 看来是唯一陷入了 ABI 兼容的传统艺能[问题](https://github.com/chakra-core/ChakraCore/issues/796)导致根本上技术困难的。
			* 结果，苹果还就真的是矮子里拔高个的比较能看的独苗了。
		* 不展开[实现策略](https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#tco-%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5%E6%A6%82%E8%BF%B0)，就挂一个技术问题：[backtrace 和 PTC 不兼容（曾经）是基础不那么靠谱的编程语言实现者中一个流行的迷信](https://groups.google.com/g/comp.lang.functional/c/06h9o9jks48/m/9BPR0nI9PQUJ)，除非外部兼容问题，没什么理由凭空无法[实现](https://www.muq.org/~cynbe/ml/smlnj-hacking-backtraces.html)不出来。
			* 退一步讲，连放宽要求加一个模式带上 shadow stack 都想不到的，没资格拿 stack trace 的困难说事。
			* 退两步讲，只是为了调试体验，[加个选项临时禁用](https://github.com/tc39/proposal-ptc-syntax/issues/23#issuecomment-901724902)也不是什么难理解的事。
				* 特别是考虑 ES 引擎的实现者基本都应是（熟练的）C++ 用户，而 C++ 标准库的调试模式（如 [MSVC](https://learn.microsoft.com/cpp/standard-library/debug-iterator-support) 和 [libstdc++](https://gcc.gnu.org/onlinedocs/libstdc++/manual/debug_mode.html)）普遍提供不满足语言规范强制的计算复杂度规则（如[关于迭代器的要求](https://eel.is/c++draft/iterator.requirements#general-13)）的接口，要想不到这点是有些匪夷所思的。
* 考虑理论上的问题，PTC 的重要性特别体现在：是否从语言规范上保证 PTC 是一种足以重要到**相当上游的分类依据**。
	* 理论形式的第一个系统性论述参考 [[Cl98]](https://www.researchgate.net/profile/William_Clinger/publication/2728133_Proper_Tail_Recursion_and_Space_Efficiency/links/02e7e53624927461c8000000/Proper-Tail-Recursion-and-Space-Efficiency.pdf) 。
		* 这里使用的是 PTR(proper tail recursion) ，不过实际内容远比递归(recursion) 更普遍（包括内部实现的 administrative state 的处理），所以 PTC 是一般的用法。
			* 这种差异在许多通俗（不那么理论的）读物也有提到（如 [Programming in Lua](https://www.lua.org/pil/6.3.html) ）。
		* 即便放眼整个计算机科学的相关领域，基本没有更显著的其它例子表明，单凭算法的复杂度这样的渐进性质就能够单独决定一个系统的整体性质的**正确性**。
	* 用词是重要的。特别地，PTC/PTR 不是 TCO(tail call optimization) ，因为它是一种保证，而不是优化。忽视这一点容易造成理解偏差。
		* 但对大多数所谓的专业用户，[包括一些 Lisp 的实现者](https://groups.google.com/d/msg/comp.lang.lisp/AezzhxTliME/2Zsq7HUn_ssJ)，避免稀里糊涂似乎仍然太难了。
		* 严格来说，[ES6 使用 tail position](https://262.ecma-international.org/6.0/#sec-tail-position-calls) 的 position 因为语义的定义方式过于强调语法的(syntactic) 性质（配合[动态语义](https://262.ecma-international.org/6.0/#sec-preparefortailcall)的实现细节）而非直接要求支持复杂度界限（或者等效地要求免除对调用深度的限制），形式上可以有弱化的理解，实际要求也是比较宽松的。只不过不修改语言规范本身时，不会遇到这种难以概括的问题。
* 实际的问题影响更加深远：PTC 决定**大量常见语言特性的原生支持是冗余的**，极大地**降低语言设计可触及的复杂度下限**。
	* PTC 允许递归调用和其它少量更基本特性**完全取代**命令式语言的所谓控制结构在接口功能上的基本地位。
		* 所谓基本特性是指*控制作用(control effect)* 的抽象。
			* 当前该领域发展仍然相当迟缓，常年炒冷饭（什么 algebraic effects ，说白了不就是 delimited continuation 换皮么）。
			* 终端应用的缺失是一个重要原因。
		* 这个基础上，所谓的控制关键字可以完全实现为库。
	* 更重要地，这进一步**消除语言设计者及实现者和普通开发者之间的技术壁垒**。
		* 这也支持了本文的主要观点：**用户和开发者不具有绝对的差异**。
* [关于 ES6 的一些实现经验](https://github.com/babel/babel/issues/256) 等表明，缺乏 PTC 几乎无法通过直接内嵌实现变通解决——几乎只能重新实现整个核心语言。
	* 或者说，因为 PTC 依赖特定实现的魔法过于深刻，以至于没有 PTC 的语言在实现上对普通用户而言就是个无可救药的残废。
	* 缩水的 STC 没有那么困难的问题，也说明 STC 在普遍性的地位上没 PTC 的特殊性值得单独加入语言特性清单。
* 因此，不论是理论还是实践，是否提供 PTC 保证的差异在语言演化的系统发生树上被区分的节点理应先于许多其它看似普遍的性质。
	* 例如，是否存在类型系统，相比起来都不算是什么大不了的差别，实在不行用户自己都能解决。……什么？连写些库和工具给现有语言加一个类型系统都不会？要么是用的语言可扩展性太弱了，要么是太菜了。
		* 实际上就是工业界都烂大街了的套路，即便例子数量不多存在感爆炸。ES 上有 [spec 坑几年了且看起来不打算填坑的](https://github.com/microsoft/TypeScript/issues/15711) TypeScript ，就是 Python 那么混子的都有 [PEP-484](https://peps.python.org/pep-0484/) 。
	* 当然，虽然很少，也有严格比 PTC 更有存在感的特性和分类。特别地，函数*调用(call)* 是 PTC 的 C 存在的前提。
		* 函数调用在上游普遍以 λ 演算为基础建模，对应其函数应用的语义规则（β 规约）。这和变量一道构成了高级语言的事实分野（不涉及变量替换的组合子逻辑一般不被视为高级语言的模型）。
		* PTC 在这个意义上仅对高级语言有效。但是，考虑不用调用很难表达大多数实用算法，因此 PTC 事实上几乎处处存在实际意义。
		* PTR 的 R 实际上仅指*递归调用(recusive call)* ，不是更一般地的递归形式（如 [μ-递归函数](https://zh.wikipedia.org/zh-cn/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0)）。因此 PTC 在一般意义上是更合适的说法。
* 本文中除笔者以外的人物，除了 RMS 因为 [Emacs Lisp](https://en.wikipedia.org/wiki/Emacs_Lisp) 多少沾点边以外，专业背景和积累都不用指望理解这个问题。
	* 当然说 RMS 够格其实也相当可疑，毕竟大约[因为历史背景的影响](https://stackoverflow.com/a/38494010)，Emacs Lisp [也没有 PTC](https://en.wikipedia.org/wiki/Emacs_Lisp#Language_features) 。
		* 其实[连动态作用域都能保持几十年](https://stackoverflow.com/a/38509006)的设计，品味也不能指望了。虽说从实现经验来说，动态作用域其实并不和 PTC 完全冲突，不过确实是得考虑更多东西。
		* [RMS 对动态作用域的选型理由至少……非常古董](https://en.wikipedia.org/wiki/Emacs_Lisp#From_dynamic_to_lexical_scoping)，因为只有纯解释器才有这方面的问题。
	* 如果需要另外点名，在技术领域和这里的非技术（~~钞能力~~）领域同时有~~那么点~~相提并论的影响力的人物中，可能只能加上 Paul Graham 这么一个。
		* 毕竟 [Arc](https://en.wikipedia.org/wiki/Arc_(programming_language)) 看来[还是有 PTC 的](https://www.righto.com/2008/02/arc-internals-part-1.html)，~~虽然[文档](https://arclanguage.github.io/ref/)糟烂到没提~~……~~用 Racket 实现的 Lisp flavor 故意没 PTC 的才怪了。~~
	* 作为对比，[Guido van Rossum 的理解](https://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html)显然是[不够格相提并论的](https://neopythonic.blogspot.com/2009/04/final-words-on-tail-calls.html)。
	* 当然，要以对理论上的理解的充分性评价，这几个人看上去都不那么懂行。
* 暂时懒得专门整理文档讨论有关技术话题~~黑一些人~~，所以有点跑题的这坨也就先糊在这里吧。

　　实际看，不论是 Web 前端开发者还是相关基础设施的开发者，几乎从来没有注意到这类技术问题。

　　这里明显是苹果以外的竞争对手更加明显地作恶——不论是消极的，还是积极的。然而，很遗憾，苹果的垄断（特别是 iOS 上）没有对澄清偏见和错误认知起到明显的帮助，即便这本应是苹果的技术资产中（相对剩下的市场来）最先进的而不需要依赖垄断就该被推广的部分。

　　如果改变刻板印象，情况是否会有不同？

## 关于 PTC 的重要性和必要性

　　需要指出，TC39 在这里存在争议。并非所有的专业人员都没有意识到 PTC（在一个通用目的编程语言中）的重要性，但在一个语言的标准委员会里产生争议，足以说明至少其中有一部分专业人士*没有做足功课*。

　　以下部分回应对[这个修订](https://github.com/FrankHB/pl-docs/commit/3d6aaf92da53b0db383944d71551ef910016d7d9)的评论。

　　如 TC39 代表 [@hax](https://github.com/hax) 指出，争议在引入 STC 的早期即已存在，[存在许多不同观点以及许多到现在都适用、一直没有解决的分歧](https://v.youku.com/v_show/id_XMjc0NDQ3MDI1Ng==.html)，且许多观点分歧并非是技术上，而使政治上的。这倒更加能够证实，一些普遍的技术观点显然没有充分地被讨论。

　　因为一些理解具有普遍性，在这里针对提供。注意这里只是澄清技术争议相关的观点，并非完全的科普。关于 PTC 的系统观点可能仍需要单独的文章归纳~~所以在这先坑了~~。

### 易用性

　　上面提过，PTC 实际上是很基本的……基本到让人发指的东西。因为过于基本，以至于（只要先不管语言背景）可以发散一些话题：

* 任何一个理解精确的操作语义的用户理应只会因为缺少 PTC 而需要单独记忆诸如循环之类的附加替代原语而造成理解负担，而不会是有 PTC 才有包袱。
	* 简而言之，**任何函数调用默认就满足 PTC**，而破坏 PTC 需要特设的非默认方式的调用。
	* 最简单的设计中，介入非 PTC 的原语只有一个：函数应用序(applicative) 求值。
* 严格来说 PTC 其实不只是函数应用的调用，如何扩展约定非 PTC 是否在尾上下文是另一回事。
	* 不过，至少单独约定尾上下文比特设非 PTC 的特设语法在**工程上是相对容易维护的**；因为起草规范时，如果没有 PTC 要求迫使作者长心眼，很可能漏掉这茬而在事后引起不必要的实现差异。

　　当然，对 JS 用户而言，PTC 是“新事物”。不过，根本上还是因为无法脱离路径依赖导致的思维问题。这是因为他们不幸地用了 JS 这样的语言（虽然其实也包含别的大多数工业语言），而不是因为他们脑子不好使。

### 可调试性

　　大多数用户的脑子在这方面问题其实大多差不多好使或者不好使。可能我在这方面也就稍微好使那么一点儿。我当初是在 Guido van Rossum 回复 Python 为什么不支持 PTC 的博客回复中看到有人提到 shadow stack 才知道那么个玩意儿的，然而我当时没花几个毫秒就大概猜出来是怎么回事了，即便我也之前没实现过。大概是这么个东西一直都在我脑子里，只不过没刻意去叫罢了。

　　对我而言，引入一个 shadow stack 去保存活动记录就和“引入实际参数求值就不 PTC 了”一样自然，并没有什么难度，也没有非得用一个名字去命名的必要。反倒是想象会让栈帧失踪而阻碍调试体验，这才更费点脑子（虽然也不难），因为必须模拟现场才能推理出合理性，弯弯绕绕其实更多。

　　造成这些差异，无非是关于函数调用的理解是否到位。没有 PTC 的语言造成或者加强了这种思维定势：但凡函数调用就得 push/pop stack frame ，这其实是毫无道理的实现细节，因为函数调用根本是语法上的东西，是不是会对应运行时状态改变的动作这点都不确定，更别说对应到具体什么操作了。

　　1980 年代初期对“函数调用一定对性能有害”的迷信也是类似的大脑短路混淆函数调用这种抽象机制和它在典型本机语言中的实现的结果——这个假象后来被 Scheme 编译器打破。现在的用户来看这可能显然地很蠢：连内联都想象不出来？

　　遗憾的是，无法理解 PTC 和可调试性的无矛盾性，和无法理解这点，恐怕没有多大难度上的差别；“ PTC 无法调试（而用不 PTC 的函数调用代替）”和“函数调用性能会低所以少用（而尽量用 C 那种宏代替）”差不多，至少对专业用户来讲，实在不是啥光荣合理的借口。

　　当然，因为行为可能不同，调试体验多少会有差异，这个很正常——反过来要求不同配置下可调试的高级语言程序的行为完全一致，这才不正常。这我恰恰就还正提过：C++ 的 debug 模式的操作的时间复杂度都能不一样。（而且你个写浏览器的能不知道这个？）所以真全 shadow 了导致实际不 O(1) 自然不 PTC 了，都不是问题（何况还可以限制保留常数个帧变通）。

　　其实真要强行尽量一样也不是不行……上硬件调试器吧。（然后实时性就无了，这是后话。）至于 JS 用户这里就自求多福吧。

### 兼容性

　　问题：怎么判断一段代码是不是依赖了 PTC ？

* 没支持 PTC 的语言，自然假定不依赖 PTC 。
* 否则，不展开调用把实现扒个明白，就不大能确定了。
* 然而这就成了和判断是否用了异常一样没建设性。
	* 在静态分析的意义上，能容忍判断不清楚是否用了异常，却不能容忍判断不清楚是否依赖 PTC ，在可信性上双标是没有道理的。
	* 在运行时上，对最终用户来说，或许也是半斤八两——支持 PTC 能正常跑，否则爆栈了也是异常嘛。

　　比较微妙的是开发者预期的运行时行为。要避免兼容性包袱，的确需要主动的额外工作量：

* 有意识地依赖 PTC 时，需要针对具体实现进行名义检查把允许 PTC 实现的拉白名单（因为关于 PTC 的测试永远覆盖不全，原则上都是不可靠的）；其它情形使用旧的实现即可。
* 直到所有的实现都支持了 PTC ，可以去掉兼容实现，通过黑名单排除不支持 PTC 的实现。

　　可以看到这其实就是常规新特性迭代的场景——大不了 shim 一下（虽然这个 shim 写起来可能和 STC 差不了太多）。区别是，大部分厂商支持 PTC 不积极。但**这就不是这里开发者的问题了**。要是厂商拿这点鸡和蛋的问题作为不支持 PTC 的理由，就是耍流氓了。

### 安全机制

　　这类问题我不记得有根本矛盾（像上面提到的析构或者 contract check 一定会改变尾上下文），所以与其说是和机制冲突，还不如说是和现有设计的兼容性冲突——于是根本还是和 Chakra 因为 ABI 坑导致无法实现一样。

　　关于 PTC 和安全机制的这方面我没有深入挖掘，因为古早就有代表性的例子：[关于 stack inspection 和 PTC 莫须有的冲突](https://www2.ccs.neu.edu/racket/pubs/cf-toplas04.pdf)。根本还是一样的道理：传统上所谓的 stack inspection 只是为了实现安全机制的一种实现方式，并没有在更高层次上排除更普遍的、一般的方法以确切地证明和 PTC 普遍地冲突；然后还就有不冲突的方式。

　　因为和 PTC 的实现（特定的 TCE ）冲突而断言不能支持 PTC ，这种轻率的决策和认定“函数调用性能差”（所以尽量别用）没太大高下之分。

　　稍微耐人寻味的是为什么这里改的是 stack inspection 而不是 PTC ——其实也很简单，后者过于基础而退无可退。

### FP 语言

　　这点或许才是最有必要回复的一点。因为这里的意见**充斥着长期没有效解决的误解和混乱**。

　　就像当年 PTC 被踢出 ES4 时的[典型意见](https://johnresig.com/files/Adobe_position_on_ES4_features.pdf)一样，PTC 被认为是 FP 的一部分，但远远不够。

　　然而事实是，**PTC 跟 FP 没什么关系**。更确切地，需要注意：

* 显然不管 FP 不 FP 的语言都能要求 PTC 。
	* 特别地，这个 call 其实跟函数调用上也就是语法上粘一层皮，因此甚至没函数应用的低级语言都能支持，只要能钦点出蕴含尾上下文的类似函数调用的东西，然后实现成类似 `jmp` 这样的指令。
	* 很显然这里的 call 其实就只是一种控制的转移，和需要 `pop` 调用“返回”的实现至少是并列的（更一般的做法是 CISC 风格的 `call` 实际上是 `jmp` 和 `pop` 等拼起来的，`jmp` 在这里更接近本质）。
	* 所以，这还和 FP 有多大关系？
* 包含几乎所有命令式语言的**大部分语言**因为一开始就没有支持 PTC 的设计，引起一些误解：
	* 这直接导致高级语言提供特设的迭代（循环）机制才能实现本来用 PTC 直接就能支持的迭代。
	* 这也导致设计者在内的大多数用户都没预料到 PTC 的普遍性，而把看起来“不命令式”的 FP 语言才出现比较多的 PTC 误认为 FP 语言的特征。
* PTC 影响 FP 风格是否可用，这是**实现细节**。
	* 明确要求 PTC 的计算模型反而可以不那么 FP 。
		* 因为可以通过局部替换一个本来完全 FP 的子程序隐式地扩展副作用而不改变写法，所以是不是 FP 其实是中立的。
		* 一个不那么 FP 的语言也可以支持 PTC（比如 Lua ）。
	* 没有要求 PTC 的函数调用的语言也可以是 FP 语言，只不过不容易实现迭代的效果罢了。

　　顺便，关于垃圾的问题……这是实现细节。C++ 照样大把临时对象，为什么不是垃圾？逻辑上其实就是，关键是*创建对象其实未必需要分配*。JS 在语言设计上只会更松垮（默认不要求立即回收局部资源，也不用关心有副作用的析构这类真正可能冲突的破事，是不是做逃逸分析靠自觉），而不存在实现的障碍。

## 总结的技术回应

　　（版权声明：引用部分评论以合理使用。）

> 第一，委员会里不同人对 PTC/STC 的态度是很不一样的。以我看来这个争议到最后更多的是JS引擎厂商之间的政治斗争。非引擎厂商的代表可能有所偏好，但基本上无论是PTC/STC是都可以接受的。比如我，我是倾向于STC的（具体原因后面说），但一定要上PTC我也不反对。具体到每个代表，其考量是多方面的，包含了一些非技术因素。即使单说技术因素，考虑的方向也会很不同，比如我评价JS的语言特性时非常看重其在普通JS程序员在工程实践上的后果（其实我这种出发点在委员会是少数派）。其他人则也各有不同的出发点，相比较来说，反而是引擎厂商的诉求是相对一致的。不过在这个具体事件上，如我所说，因为已经演变成了引擎厂商之间的政治斗争，其他因素就不重要了。

　　就 ES 如何演进 PTC/STC 相比澄清 PTC 的普遍意义确实现实上没那么重要。主要原因已经提过——兼容性。JS 再重要，“已经这样了”，“现在”（任何想要修改标准时都可以这样说）修改基础设计的边际收益不大，所以就算是最普遍的改动，相比别的改进也不需要有很高优先级。影响这里决策的大部分问题都是非技术问题，毫无夸张。

　　我要提的是，虽然不是每个人都必须面面俱到，但整个 TC39 似乎并没有一个权威一点的声音能涵盖 [Cl98] 里的入门观点，这就有些离谱。考虑到不知道这些基础的用户占大多数（[连维护 `compat-table` 的都不甚了解](https://github.com/compat-table/compat-table/issues/1357)），放弃科普基础的补课，对评估用户影响的工作显然是不利的：都不知道你为何要有，关我嘛事？无视会导致原有代码出错么？于是对普通用户的实践后果也不那么显著了。讽刺的是，这也确实导致 ES6 的 PTC 缺少感知以至于几个主流厂商更加好意思干脆放着不实现；但无论如何 TC39 在这里做的无用功是大家一起背锅，并不会因为与会者吵得舒服了，意见交换充分了，就表示这没浪费资源了，没损害 ECMA-262 的可用性了。

　　没有进一步的共识，只是澄清了分歧，这也算是有个结果。但仅仅是把各个点过了一遍，而没有概括出关键分歧的共性，也没有为解决问题的未来可能性提供指引，这进展实在不怎么样。

　　（讽刺的是，微软放弃 Chakra 反倒是消除了一个因为 ABI 坑导致的无法实现 PTC 的最现实的问题——虽然对整体进展几乎毫无卵用。）

> 第二，所谓「其中一些实际阻碍 PTC 实现的工程理由就是错的」。首先，工程上可以实现不代表就是可接受的方案。尤其有一些因素可能被其他的争论掩盖了。比如跨越特定边界（如 js/wasm，还有 membrane —— 这玩意儿比较难用一句话解释清楚，反正就是某种隔离层）的问题，我记得mozilla的人反对PTC似乎主要是这个理由。其次（实际有可能是更重要的），在具体会议讨论上扔出来的理由，未必是真正的理由，或者至少不是主要理由。V8和SpiderMonkey的人难道不知道shadow stack吗，肯定是知道的（因为在吵架之前，webkit的人早就写过文章吹嘘他们自己的实现了）。所以这无非是辩论双方把所有有利于己的都讲出来，不利于己的都回避。实际上苹果的人也回避了一些对他们不利的问题。

　　这里说的是“其中一些实际阻碍 PTC 实现的工程理由就是错的”，跟是否接受决策自然是两回事。

　　“错”虽然可以有主观性，但大致上是说，逻辑上经不起推敲，理由十分薄弱。这主要是针对关于 PTC 可调试性一定差的观点。这些言论因为对专业人员而言过于没常识，按理都不需要占据什么讨论的篇幅——实际上看起来也只是因为 STC 针对性地“克服”了这些问题才有必要强调。但这个角度来针对，未免就有些下作了一些，反而又削弱了 STC 的技术合理性。

　　反倒是互操作问题（包括跨运行时边界和 ABI ）是真实的、实际会有阻碍的、相对比较合理的工程问题。但这些问题根本上都是特定实现的兼容问题。长期演进来看，这些问题不是不能克服的——极端情况，无非是直接更换实现了（像 Chakra 切换到 v8 那种——虽然这俩在这里都不行）。

> 第三，就事论事，我讲讲为什么我支持 STC 而不是 PTC。首先，PTC 导致程序员很难看出一个代码到底是不是 tail call（相比较而言，STC 因为有语法标志而非常显式）。这进一步导致在重构代码时容易破坏 PTC（STC 则不会，因为如果破坏了会是 syntax error）。糟糕的是破坏 PTC 的效果是不容易发现的。是不是 stack overflow 由很多因素决定，比如递归的次数，引擎的 stack 大小，不同引擎，不同的runtime（如mobile browser通常就比 desktop browser的stack要小）都不同，甚至其他因素都相同，如果在工具链上换了个工具，比如说js压缩工具，结果就可能是不一样的。从工程上看，就是容易引入难以发现和追踪的线上故障甚至事故。其次，需要注意 JS 的最主要应用场景 web 前端中用户浏览器的多样性。即使所有引擎都支持了 PTC，也需要非常长的时期（现在一般要两、三年，如果是中国的话那可能要5年以上）才会等到绝大多数用户都升级完，一些特殊场景则永远不会完成全部升级。因此在一个长时期里一份相同代码可能按照 PTC 也可能不按照 PTC 运作。这导致很多东西会发生偏差，比如收集来的 stack 日志根据是否支持 PTC 会产生差异。特别注意这是无意中发生的（绝大部份开发运维根本没有意识到从某一刻开始事情突然不同了）。这和 STC 的情况不同，STC 作为新语法它强制你必须对其作出处理，虽然比 PTC 麻烦，但是更显式的处理（比如根据 feature detection 分派到两个不同版本）避免了前述问题。而且不用新特性的人根本不会被打扰。实际上，由于相同代码事实上必然会存在有的 client 有 PTC，有的 client 没有 PTC ，使得「PTC 是保证而不是优化」这句话在实践上根本不成立，从而成为了一个陷阱。归根到底，STC显式地编码意图是更好的选择，至少对JS是这样（因为JS程序员传统上并不熟悉许多fp语言里有的设施和概念，贸然引入 PTC 可能不是惊喜而是惊吓）。

　　这里倒是有几个稍微有意义展开的点（这里 TC39 的讨论应该也相当不充分）。

* 首先，关于开发者在代码中看到显式特性的必要性问题。
	* 一个总的观点是，显式出现的代码应当是逻辑上有意义、不易引起视觉疲劳且能够**便于利用普遍的语言机制使代码更健壮**。否则，就容易是语法噪音。
		* 前两个容易理解，第三点常常被忽视。结论的共性是：显式标注的内容不是越多越好。
		* 例子：有的 C 用户认为，C++ 隐含的操作太多，不够显式，所以不好。这显示出对成熟高级语言语用的理解不足，因为：
			* *约定大于配置*。只要是默认应该有的，再关键的操作也适合隐藏——最典型的是释放局部资源的析构函数调用。
			* 把隐式的代码强行用显式的方式表达，并不会提升可读性，反而会因为挤占了非平凡的代码逻辑的篇幅，分散熟练读者的注意力，而损害可读性。
		* 例子：有的用户认为，类型标注应当是显式的，C++ 的 `auto` 和 C# 的局部 `var` 缺少类型而损害可读性。这显式出对类型标注使用的理解不足，因为：
			* 局部实体根据需要实现的逻辑引入，之后才确定类型。先随意确定一个类型，基本不可能保证最合适而不需要调整。
			* 因此，局部类型不是重要的，而*应当*弱化其具体形式，以避免引入语法噪音。（实际上，重复的非必要类型标注还增加修改工作量。）
	* 还有语义噪音的问题。例子：有的用户“强”类型信息越多越好。这体现出对类型系统的理解不足，因为：
		* 类型的作用是在项上提供语义信息编码特定的真命题，使读者理解意图，使实现能够获得更好的目标代码质量，以及提供自动化的形式检查。
		* 在接口边界适当使用类型是正确的，过度使用类型阻碍意图的表达，无助于实现利用类型信息，是语义噪音。
	* PTC 是一个调用的局部性质：保证调用自身的空间复杂度总是 O(1) 。STC 是显式的标注。
		* 逻辑上这可能是必要的，但不一定需要是显式的，因为这是个组合性质：当被调函数的实现都满足预期时，调用方也自然正确。
		* 这类似类型标注：能通过类型推断时，显式类型标注就可能不必要，反而可能形成语法噪音。
		* STC 在此是退化了的类型系统（虽然标注复杂度的类型系统不流行）——完全通过语法形式编码语义性质。
		* 在接口边界，类型可能是必要的，但除了 function sigil 方案，STC 仅仅标注调用而不是函数签名，反而缺乏类似的用法。如果用户需要通过被调函数推断，还可能需要人肉控制流分析。
		* 仅考虑这些因素，STC 也只适合作为可选的特性，而非按照提案取代 PTC（实际上互递归也无法取代），且大部分情形不应当依赖。
		* 然而，如果可选，那么是否用语法关键字标注属于君子协定。而注释在此也够用，用关键字效果不显著。
		* 反之，如果 STC 取代 PTC ，还会引起读者无权避免语法噪音，无法写出对被调用函数 PTC 正确性中立的包装函数。
		* 注意 STC+PTC 会比 PTC 有更多复杂性。
	* 而“很难看出”如何以及在何时会出现问题？
		* 对递归调用，看到返回同名函数调用表达式，就能知道是尾递归，对任何能理解什么叫尾递归的用户这本来就很清楚，*即便用户仅仅使用过 JS* 。
			* 凡是有尾调用概念的用户都应该容易理解返回的表达式的子表达式求值几乎都不是尾上下文。
			* 特别是考虑到 `return` 无法被随便省略的上下文，这就是个显眼包：和 `return` 邻接的函数调用才是，其中的参数或者别的子表达式都不是。
			* 老实说，我还就没见到过认错显式尾上下文的重构导致的软件缺陷。（隐式的相对容易漏的，比如 `call/cc` ，在 JS 中可没有。）
		* 退一步讲，就算重构破坏了 PTC ，在那些场合会出什么问题？
			* 仅在没有正确支持 PTC 的实现中且实际递归调用深度足够大时容易出现爆栈的问题。
			* 正确支持 PTC 的实现会出现非预期的内存泄漏——这是个不依赖具体配置也可能不影响使用，一旦影响就相对容易发现和修复的问题。
		* 实现问题并不要求引入 STC 才能解决，更没有理由要求 STC 替代 PTC 。
			* 针对代码修改的 STC 检查防御的是现有的不支持 PTC 的实现介入时才可能出错的问题。
			* 这无法说明，新增支持 STC 比逐步淘汰不支持 PTC 的实现更有可操作性；注意使用 STC 需要修改代码。
		* 即便引入了 STC ，已经有问题的代码也不会自动变得没问题，要进行修改；而为了兼容还是需要 shim 。
	* 另一方面，**完全重现执行状态不是一般高级语言用户应该被容忍具有的特权**，以可调试性为借口要求无条件减少环境差异更是*方法论错误*。
		* 面向接口，而不是面向实现细节。语言运行时的特定配置就是一套接口。
		* 尽可能重现环境的实现细节本就是在特定受限环境下系统（包括语言实现）开发者的特权。
		* 而在生产环境，更加没有任何人能保证能控制运行环境细节的条件总是可被满足。
		* 普通应用开发者完全没有条件重现全部的环境状态，因为环境中注定有些东西是他们不可控的，必须认为是“未指定”而全部兼容。
			* 重现用例其实*要求*开发者自觉把*任何可枚举的*环境归纳为有限的配置项，在上层足够近似但不能保证完全相同的环境才有必要尝试重现。
			* 完全依系统状态重现直接消灭了可有限枚举的可能性。
		* 更正确的做法是，*一开始就应当避免依赖不确定的环境状态的外延*。
			* 应当理解所有支持的配置的多样性之间的共性，而非鼓励反其道而行之去做不成熟的优化，以至于把维护健壮性的成本花在事后重现，而不是采样可重现的基础设施上（最简单的，比如日志）。
				* 不成熟的优化体现在：依赖具体配置的实现细节（比如栈的具体大小）而不是配置项本身（比如具体支持哪个运行时）。
			* 如果仅用自己可控制的环境重现失败，才有必要考虑向其他人要求本来不可配置的资源，以重建具有更多细节的实现环境。
				* 这种方式本就是一种寻找问题来源的常规调试方法。
* 其次，关于多样性和迭代困难。这里基本上都是工程决策而非技术可行性的问题。
	* 这里 PTC 和其它特性没有根本差别，适配逐渐演进的实现环境时，都需要不同的代码路径兼容旧实现。
		* 这些代码路径不都需要应用开发者承担，完全能在库/框架/中间件中解决。
		* 不愿意采用其它方案的开发者也可以选择承担复杂性换取“自主可控”的灵活性。
	* 而 STC（不论是否取代 PTC ）会引入更多复杂性，使这里的问题对*几乎所有人*——不论是语言实现者、库的作者还是应用的开发者——都更复杂化。
		* 这还不算 STC 无法取代的互递归 PTC 情形。这种情况还是横竖要让人去写 trampoline 之类的方法变通。
	* 检查 PTC 可以按配置部署静态分析实现，不需要 STC ，同时避免使所有人都面临更复杂的状况。
		* 要求替代 STC 的 PTC 实际上是一种特殊情况：不信任任何开发者可以自觉正确使用 PTC ，而强制要求检查。
		* 在语言规范而不是实现工具中配置这种强制策略缺乏建设性：*就算 JS 用户真的全蠢到连这种问题都 hold 不住，也不至于直接说出来吧*。
		* 而自觉兼容 PTC 和非 PTC 的写法会使代码近似 STC 。这不需要通过修改语言规范强制。
	* 如果在乎 stack 日志可能有差异，那只能说明这里本来就不应该使用 PTC 。
	* 通过“不使用 STC ”默认确保 stacktrace 符合预期虽然在技术上可行，但正常依赖的逻辑中*随意依赖 stacktrace 本就不应提倡*。
	* 能 PTC 时全部要求默认依赖 STC ，跟该 release 的时候还去用 debug 版大致上是类似的工程策略。
		* 实际也没有因此让 debug 普遍默认代替 release 配置的道理。
		* 一般是 release 本就有不依赖 stacktrace 这样的 log 直接就能分析出很多问题，遇到极端情形需要重现才降级 debug 版本。
	* 在已经存在对 PTC 需求的情况下，问题就不是**不用新特性的人根本不会被打扰**，而是**因为没有提供 PTC 所以长期以来很多用户在被迫做人肉编译器变通**（特别是考虑到 Babel 之类对这事的自动化变通其实很不靠谱）。
		* 所谓“PTC 是保证而不是优化”本来就是健全的语言的份内事，加上 PTC 很大程度上只是在*修复设计上的明显缺陷*罢了。这完全是从语言的使用者 push 的需求，并不存在因为实现者理解有偏差不去支持，用户就放弃依赖的理由。
		* 可以确定这部分清楚为什么需要 PTC（乃至于自己写 trampoline ）的用户在平均水平之上，因为剩下的用户包含大量完全不知 PTC 为何物，甚至需要担心源代码里没 STC 都一眼认不清楚是不是有 tail context 的。
		* 让专业用户不被非专业用户拖后腿是通用目的语言的一项主要任务。当然 JS 自有 JS 特色的情况在……
		* 然而 ES 到后来引入的特性早就不是随便什么用户都能得轻易用对的了，对这种已经向大而全的大杂烩发展的实用语言来说，这就已经不对非专业用户友好到哪去了。
		* 甚至即便不论 ES 多复杂，不支持 PTC 本身单独拎出来说在任何一个支持函数调用的语言里就很离谱。
			* 大致上就是有 `call` 不给 `jmp` 的汇编那么离谱。当然 `jmp` 还有其它普遍形式，对应高级语言中的 [J operator](https://en.wikipedia.org/wiki/J_operator) 和 `call/cc` 等超纲货色所以就先不提了。~~`goto` 那种非结构化阉了的弟弟先无视。~~
			* 有的人可能会说 C/C++/Rust 也不支持嘛……这个**已经黑过了**。不过，这几个语言有一点没 JS 那么容易黑：因为对象模型，需要直接考虑活动记录对象分配和所有权确实有些（语言设计而不只是实现上的）麻烦的限制，然而你 JS 实质上已经依赖 GC 了，居然还不 PTC ？

> 最后，有些东西可能是可以争辩的，但标准委员会的运作本来就要求妥协。演变成政治斗争，在我看来更大的责任在Apple。Apple既无法说服其他任何一家厂商，也无法说服利益无关方。从流程上说，在2015年之后的流程里，PTC根本达不到stage3。Apple说因为这是ES6的内容所以不需要按照新流程，虽然是个理由，但是更类似于法庭辩论中钻法律漏洞的情况。苹果真正拒绝STC的理由，在我看来根本不是不是某种对编程语言理念的坚持，而纯粹是不想其已经实现（并夸耀）的一些实现方案（如shadow stack）被标准否定从而要被丢弃。

* 最后，标准委员会不该是妥协和低效的代名词。
	* 争辩本来就不是目的，目的是形成共识。
		* 妥协是共识的表象，但不是最终结果。
		* 对不同阵营，没有推进有不同的理由，但整个 TC39 在这事上对外的表现就是不忍直视。
		* Apple 没什么资格夸耀，标准也不用直接否定这些实现方案。TC39 在没取得更关键的共识前先去纠结这些事情，多少有些不务正业了。
	* Apple 的表现很烂，但这和它已有的技术立场没什么关系。
		* 不妨反过来想想，为什么 Apple 那么烂表现的孤家寡人，居然在 TC39 内没法被干掉？如果后面的问题仅仅是流程原因，那**为什么一开始 PTC 能进 ES6**？
		* 关键原因是 **PTC 的正当性在所有编程语言中具有普遍性，TC39 内部的观点起不到决定作用**。
		* 更一般地，无论用户基数有多大，技术力多低下，该成长的总是会成长的。所以就算 JS 用户全都没意见（其实不可能），普及（垄断）以后因为残缺的特性就会被其他用户抱怨，**这种矛盾不可能仅仅通过 TC39 的妥协就消失**。
	* Apple 在流程上也算不上钻空子。法律漏洞需要被堵上，但现在看，*很难认为这里的空子已被公认*而需要被修复。
	* 你可以说 Apple 投机、很菜并且动机不纯。但就这事来说，还真投机对了。

> 对于开发者来说，能力比形式重要。实际结果是，自2017年至今，JS开发者始终没有普遍的PTC可用（除非你只为safari编程），也没有STC可用。这个锅只能是苹果的。（虽然很多时候v8的独断专行更甚一筹。）

　　这里的锅显然 v8 大得多：

* Apple 是菜，然而 Microsoft 和 Mozilla 甚至更菜（当时的实现真有技术困难实现不了），但你 Google 怎么肥事？
	* 先自己在 v8 里支持了 PTC ，然后过了一年又自己干掉了？
		* 这样反复折腾（虽然 Mozilla 更加老传统艺能了，但这里不算），体现出工程决策更优秀了，责任就比 Apple 小了，而不是瞎折腾拨动整个行业的神经，该骂？
	* 仅仅是其它厂商恰好更菜都实现不了只剩下 Apple 了，就算 Apple 的锅？人话否？
		* 其实换任何一个正常实现了 PTC 的厂商在这里都会有意见。只是这恰好只有 Apple 而已。
* 如果 STC 更合理，为什么拖那么久才提出，让 PTC 能进 ES6 ，让 Apple 能钻“空子”？
	* 至少一开始技术上功课没完，做理解得不成熟是跑不了的了。
	* **PTC 在一般的编程语言中一早是成熟的设计**，偏偏在 JS 中水土不服的破事为什么那么多，留给在座厂商自己反省吧。Apple 恰好是最不需要反省的。

> 但是对于JS来说是不成立的，因为JS的主要应用场景决定了其要永远保持兼容性，也就是即使其有了 PTC 或者代数效果之类的牛逼特性，也不可能把原有的哪些「冗余」特性删除，也就是原则上说，你不可能通过增加特性来降低JS语言的复杂性。

　　这里的逻辑**普遍**不成立的。不说“永远的兼容性”是否作为真实需求存在，实现这种兼容性并不是大不了的问题——撑死多几个 `strict` 类似物和几个并列的运行时而已。啥，你说 ROM 太小放不下新的运行时？不好意思，风太大没听见—— JS 占用资源表现恶劣早就名声在外，会在这种极端情形保持兼容性的需求会被自然无视。结果，这就不会是个问题。

　　而越是无原则的极端的兼容性，越是会被人人喊打——就像当年的 IE 一样。反过来，有些东西的“兼容性”则不会，比如 PTC ，因为这些东西是贯穿在整个 PL 乃至理论 CS 历史中的**主线**，或者说就是*原则的一部分*，在可见的未来是不可能被取代的——你不支持 PTC 结果就是有用户发现被迫写 trampoline ——猜猜这些用户会嫌弃 JS 无能还是会抱怨 PTC 麻烦？不好意思，后者的必要性某种意义上就是“客观规律”，是人力无法回避的，用户再头铁再有意见对此也无能为力。因此整个 JS 都不可能有相提并论的待遇；相比 PTC ，JS 就是软柿子，长期来看，只会是被牺牲和妥协掉的一方，无非是现在的用户没有把 PTC 的必要性当做是常识而已；未来呢？当然，JS 或许根本就没通用到活得到需要用户这样二选一的一天，这就是后话了。

