# 关于语法

# 引言

　　有人说语法很重要。这点我实际上一直不否认，但一定程度上（除了[这篇文章](what-is-syntax.md)）并没有表达过一个整体上为什么有意无意地在语言设计和分析中避免“优化语法设计”这样的工作的理由，所以有必要概括一下观点。

　　因为上下文是编程语言，所以“语法”指的是 syntax ——这在自然语言中是“句法”，但编程语言不存在严格对应的“句”的概念；自然语言意义上的语法则是更一般的文法(grammar) 。

# 重要

　　很多人同意，记号(notation) [影响思想的表达](https://github.com/hypotext/notation)。这种影响可能是积极的，也可能是消极的：合适的记号使表达的成本更低而更具有可行性；糟糕的记号可能会对交流制造意想不到的门槛，并歪曲表达的原意，进而限制思想的可行性。

　　语法提供作为系统化的、有规律可循的记号系统的基本规则。除了少数强调直观而非普遍性的更适合图形等非文字和非符号化表达的场合，语法对人工设计的记号系统的作用是毋庸置疑的：它很重要。考虑到使用频率，语法就像呼吸一样。也因此我不能忍受复杂到在日常使用时需要刻意注意的构造，并且有意远离不得不使用这些构造的场合。要是一个人时不时[潮式呼吸(en-US)](https://en.wikipedia.org/wiki/Cheyne%E2%80%93Stokes_respiration) 的话，那么大概是快要挂了。

# 变化

　　另一方面，既然众口难调是现实，通用目的语言中呈现的最终的语法就应该允许让用户定制。这更容易使之被排除出语义规则之外单独设计——如 Racket 这样的基于传统 Lisp 的 read macro 基础上扩展出来的方案。

　　这样的现实需求也体现语言设计中分离语法和语义规则（而不是铁板一块的混沌文法）的普遍必要性——考虑到应对需求而变更不成熟的语法设计的代价仍然不会小到哪去（未必困难，但对会设计并更感兴趣使用语义解决实际问题的语言设计者来说，不用普遍规则概括的细节几乎总是烦的），只有极端不在意语法的“一次性”的小规模[领域特定语言](https://zh.wikipedia.org/zh-cn/%E9%A2%86%E5%9F%9F%E7%89%B9%E5%AE%9A%E8%AF%AD%E8%A8%80)设计中，才可能漠视这种模式而不造成麻烦。

# 作用

　　现代编程语言的语法设计在语言中起到的作用的机制大同小异。

　　一般来说，除了使用使用“扁平”式的单一[形式文法](https://zh.wikipedia.org/zh-cn/%E5%BD%A2%E5%BC%8F%E6%96%87%E6%B3%95)的设计方式，**现代的编程语言通常采用语法和语义(semantics) 规则分离的设计**。这是因为，形式文法不容易捕获语言设计需要的有目的性的抽象特性，以至于几乎无法合理地表达需要描述含义而不仅仅是操作语法元素的场合：

* 被形式文法描述的对象语言直接被文法的[产生式(en-US)](https://en.wikipedia.org/wiki/Production_%28computer_science%29) 描述，其形式是已经分解成语言的字母表上的固定元素（符号(symbol) ），且产生的新的符号串难以通过产生式的描述**保持**能清楚描述设计者意图暴露给用户使用的特性相关的结构（例如，[作用域](https://zh.wikipedia.org/zh-cn/%E4%BD%9C%E7%94%A8%E5%9F%9F)的内部表示）。
* 同时，虽然[足够强的形式文法](https://zh.wikipedia.org/zh-cn/%E4%B9%94%E5%A7%86%E6%96%AF%E5%9F%BA%E8%B0%B1%E7%B3%BB)能够允许上下文(context) ，但上下文仅限符号串的表达，无法提供显示设计者和用户目的的抽象含义。

　　因此，除了一些极特殊的场合下的[领域特定语言](https://zh.wikipedia.org/zh-cn/%E9%A2%86%E5%9F%9F%E7%89%B9%E5%AE%9A%E8%AF%AD%E8%A8%80)（如[正则表达式](https://zh.wikipedia.org/zh-cn/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)——它的目的就是为了描述串操作），现代语言的设计通常不使用单一的形式文法指定规则。

　　注意针对这类作为元语言的传统形式文法表达上下文的能力不够强的问题，文法层次上存在[自适应文法(en-US)](https://en.wikipedia.org/wiki/Adaptive_grammar) 这样更复杂的方案。但使用这样的文法进行设计本质上是在扩展习惯上作为领域特定语言的描述文法规则的元语言，有增加复杂性的代价。考虑不同用户定制文法规则的需求差异很可能相当大，定制的部分往往难以复用，在元语言中直接承受所有定制需求带来的复杂性并不是很明智的做法——若有资源应对增加的复杂性，为什么不优先直接考虑目的上一般更通用的对象语言的功能呢？相比之下，仅就语法设计这个特定领域，专用于描述语法的元语言的复杂性就简单得多了（至少比把对象语言揉合在一起的文法设计容易控制）。这个意义上，使用产生式的传统方法仍然可能足够合适的，并且还是通用的事实标准。这样设计的形式文法也叫“语法的文法”(syntactic grammar) 。其中，元语言自身的语法由作者约定，常见的如上下文无关文法的[巴科斯-诺尔范式](https://zh.wikipedia.org/zh-cn/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F)。而语义上的规则因为形式化方法的困难，不被通常的语言设计者掌握而熟练使用；因此，语义规则往往仍使用自然语言描述。（即便使用形式语义，一般也不使用传统的形式文法，而是结合不同的形式语义方法单独设计元语言和对应的变换规则。）

　　分离语法和语义规则也为实现的模块化结构提供了对应基础。实现语法规则的程序称为语法的[分析器](https://zh.wikipedia.org/zh-cn/%E8%AA%9E%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8)。由于描述形式文法中产生式的元语言是规则的，这相对容易被自动生成程序等非手工方式实现（可以基于[分析文法(en-US)](https://en.wikipedia.org/wiki/Formal_grammar#Analytic_grammars)）。与之相对，实现语义规则的剩余部分则一般只能手动编码实现。语法分析器可以生成[分析树](https://zh.wikipedia.org/zh-cn/%E5%88%86%E6%9E%90%E6%A0%91)，并输出[抽象语法树](https://zh.wikipedia.org/zh-cn/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9)作为被语义实现接受的[中间表示(en-US)](https://en.wikipedia.org/wiki/Intermediate_representation) 。

## 反面作用

　　不是所有的语言设计都会严格遵守分离语法和语义规则的设计范例。一个比较明显的例子是 C 语言的 `*` 具有构成声明或二元操作符的歧义。要消除这个歧义，至少需要清楚两侧的标识符是否表示的已声明的类型，而存储已知类型需要的类型环境(typing environment) 是无法直接在传统形式文法中编码的上下文，一个纯粹的语法分析器实现并不支持存储声明的类型这样的功能。另一个例子是，C++ 具有比 C 更多的歧义，乃至不惜反用户直觉地约定 [most vexing parse(en-US)](https://en.wikipedia.org/wiki/Most_vexing_parse) 规则简化相关规则，然而一般的实现仍然需要获取语义分析的信息回溯到语法分析才能消除可能的文法歧义或给出有意义的语法错误。极端地（如涉及模板），C++ 实现可能不得不先生成不同路径的中间表示，通过语义规则判定是否存在唯一一符合语言规则要求的形式的方式来消除歧义。这大大提高了实现和用户理解程序规则的复杂性，不论在设计和实现上都是反模块化的（某种意义上，[C++ 不存在单独的语法](https://github.com/cplusplus/draft/pull/790#issue-76094464)），而除了想当然的“容易理解”（建立在写程序的用户永远不会出现语法错误的假设上），这并没有什么实际好处。因此，**现代的语言多数情况下抛弃了这种不够模块化的设计，且使用[上下文无关文法](https://zh.wikipedia.org/zh-cn/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95)来约束语法规则的设计，可预见地避免语法歧义**。

　　显然并非所有用户都能直接理解此中的缘由。例如，有用户认为表达式语法的操作符[前缀记法](https://zh.wikipedia.org/zh-cn/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95)不如操作符[后缀记法](https://zh.wikipedia.org/zh-cn/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95)，因为计算表达式的值时，前者不如后者构造简单。尽管对普通用户而言似乎无可厚非，这种观点有一些理应明显但并没有被很多人足够考虑的问题：

* 这种观点首先没有分清需求要求的接口设计和实现方式。不论输入的是何种表达式的记法，都可以有不同的实现。
	* 使用具体的内部表示这样的实现细节代替接口直接导致一些操作数编码上的限制，这和之前讨论的形式文法难以编码需求中需要的抽象设施的限制在方法论意义上是类似的。
	* 只有假定朴素的[解释实现](https://zh.wikipedia.org/zh-cn/%E7%9B%B4%E8%AD%AF%E5%99%A8)方式，被断言的性质才可能是符合事实的。
	* 注意到接口并不要求输入的表达式以何种数据结构表示。只要直接用线性表而不是栈的表示，不提普遍的[部分求值(en-US)](https://en.wikipedia.org/wiki/Partial_evaluation) 这样的一般变换，如针对具体已知操作的[内联展开(en-US)](https://en.wikipedia.org/wiki/Inline_expansion) 这样稍微“高级”那么一点点的优化就可以被低成本地实现，而使这个断言失效。
* 事实上，前缀和后缀记法存在一一对应的映射；也很容易实现变换映射使其分析树直接转写成的抽象语法树满足[图同构](https://zh.wikipedia.org/zh-cn/%E5%9B%BE%E5%90%8C%E6%9E%84)。
	* 前缀或后缀的差异，本质是因为抽象语法树使用单一节点序列表示时，从左到右（操作符优先）还是从右到左（操作数优先）的表示的不同。
	* 在处理这样的语法结构时，也只有类似使用类似序列的受限数据结构才可能体现出区别。
* 这种观点隐含了无意义的、实际不应该难以避免的[抽象泄漏](https://zh.wikipedia.org/zh-cn/%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F)：要求用户理解前缀和后缀记法的实现细节（内部表示及其处理方式）。这至少对通用目的语言的用户并没有什么好处，反而（因为上面提及的实现细节的原因）使理解和实际实现有出入。
* 除了一些[计算器](https://zh.wikipedia.org/zh-cn/%E8%AE%A1%E7%AE%97%E5%99%A8)在逻辑上使用后缀表达式的内部表示，更一般的硬件实现普遍不支持上述的解释实现。
	* 主流计算机的[指令集架构](https://zh.wikipedia.org/zh-cn/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B)中，使用被编码的二进制指令，其硬件实现也不需要对操作数给出具体的对应结构。
		* 操作数通常是在指令的二进制表示中的预先设计好的位置中编码的。硬件解码这样的操作数，逻辑上就不需要的会用栈这样的数据结构，用栈也不会使实现更优化，自然没有必要在实际实现中使用。
	* 相反，实际上使用了栈作为指令集架构层次上的接口的 [x87(en-US)](https://en.wikipedia.org/wiki/X87) 浮点协处理器指令集被认为低效，必须实现寻常浮点操作并不要求的栈操作语义正是其中的一个原因。
		* [原设计者考虑的优点](https://stackoverflow.com/a/26447672/2307646)并非基于外部需求且非常依赖具体实现细节。现在的常见的用例中，这些细节并无法有效地体现出实际的好处。
		* 即便配合现代的微架构设计，这种指令集架构上的设计也难以高效地实现和扩展（例如，[不适应平坦的寄存器堆(flat register file)](https://link.springer.com/chapter/10.1007/978-3-540-71270-1_4) 也不便使用[单指令流多数据流](https://zh.wikipedia.org/zh-cn/%E5%8D%95%E6%8C%87%E4%BB%A4%E6%B5%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%B5%81)向量化）。
	* 计算器不仅使用这种内部表示，实际上还指定了和操作顺序相关的交互式操作方式：输入一个操作数或非操作数，应该有什么特定的**即时响应**。
		* 这种**用户界面**上的设计约定反过来使固定的表示成为需求，而从内部表示上升到接口规范。
		* 为了能正确使用计算器满足计算目的，用户需要对这种用户界面的约定进行适应性训练，只是因为表达式的形式简单，成本不高罢了。
		* 然而，这种约定并不能自然地扩展到其它类似的任务中，包括稍微复杂一些的其它数学表达式（如积分运算）。这是因为这种约定**并不是求解“计算表达式的值”的任务的内容**，而是关于“操作特定种类用户界面设计的计算器”这种更依赖具体实现的任务的。当不提供能完成扩展任务的对应计算器时，自然不能适用。
		* 一般地，完成更复杂的表达式计算，输入的是整个表达式，用户不能期望中间步骤的响应。因为实现比上述简单的任务更复杂，设计者不能直观地让用户理解其中的每个操作步骤会具有什么结果作为响应。
* 另外，虽然没有直接关系，用户使用自然语言的[词序(en-US)](https://en.wikipedia.org/wiki/Word_order) 和[书写方向(en-US)](https://en.wikipedia.org/wiki/Writing_system#Directionality) 的习惯对语法表达的处理并不是相同的。这种关联的实际意义可能比考虑这里的解释性能差异更大。

　　语法设计影响的不仅仅是具体程序语言的语法。由于一些语法规则在不同语言都可适用，影响的范围可能非常大，可以包括一大类语言的[范型(paradigm)](https://zh.wikipedia.org/zh-cn/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B)。例如，所谓[指令式编程](https://zh.wikipedia.org/zh-cn/%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%B7%A8%E7%A8%8B)，尽管一开始主要是具体体系结构实现限制下的顺序表达（这广义上也可以视为语言设计，只是起初缺乏严格的形式化）的惯例决定的，其流行在相当大程度上受到顺序风格的语法影响的；这普遍而深刻地影响用户对语义的理解，并进一步导致不少语言设计者之后不加思索地应用这些现有惯例。

* 这里的顺序是指源程序中出现自然的字面顺序(literal order) ；对大多数用户，这就是自上而下和从左到右。
* 顺序风格的语法首先体现在对源程序片段的静态划分。这种语法设计风格往往在一个翻译单元(translation unit) 中的顶层(top-level) 源程序可以指定其语法具有特定的顺序组合的单位，如 C++ 的*声明(declaration)* 和 Fortran 的*语句(statement)* 。在这些顶层的语法构造元素之下，通常具有和顶层规则不同的其它语法构造。
	* 和*表达式(expression)* 通常预期可具有*子表达式(subexpression)* 的普遍可组合语法的设计惯例（来自传统数学）不同，这依赖具体语言的语法规则，并不太容易直观概括，增加了设计的复杂性。
	* 区分顶层和非顶层的构造对通用目的语言而言意义通常并不大，因为实际上会引起不符合这样语法规则的错误的主要原因往往就是用户不够熟悉这样的语法限制，而不是在理解语法构造作用的前提下不慎把特定的语法构造的位置写错了。这通常不如把语法限制改写成语义限制更有效——也往往因为上下文信息更丰富而更易实现。
	* 这样的构造通常具有一些变体，区分“可执行”表示计算的和其它（通常用于表示程序元数据）的构造，如 Fortran 的*可执行语句(executable statment)* 和*非可执行语句(nonexecutable statement)* ，对应 C++ 的*语句(statement)* 和其它声明。另外注意，C 语言的声明即便看上去和 C++ 近似，并不归类为“语句”——这体现了这方面的语法设计的一些模糊性。
* 和“指令式编程”的来源类似，经过长期的演化，“语句”这一代表性概念也不再符合其原始含义和引入的目的。对此可能产生的误解导致一些“以辞害意”的限制语言设计和影响用户交流的风险。
	* 历史上，表达式一直被用于表示取得作为计算结果的值(value) 的语法构造；取得计算结果的过程称为求值(evaluation) 。与此相对，语句被用于表示执行(execute) 具有副作用(side effect) （例如修改系统外部可观察的状态的输入/输出操作）而不是值的构造。
		* 表达式的求值通常蕴含子表达式的求值，但事实上并不是所有子表达式都必须被求值，即非严格(non-strict) 求值。表达式的非严格求值表明作为子表达式的表达式并不总是用于取得计算结果的值而存在。
			* 不被求值的子表达式作为操作数(operand) 在历史上普遍存在并延续至今，如 LISP 的 `QUOTE` 以及指令式语言中也常见的逻辑操作符的所谓[短路(short-circuit) 求值](https://zh.wikipedia.org/zh-cn/%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC)。
			* 一些语言中可能提供利用非严格求值的未求值操作数(unevaluation operand) 取其值以外的元数据的机制，如 C 和 C++ 中的 `sizeof` 操作符。
			* 非严格求值类似的非严格执行也存在于分支指令如 `if` 语句中，但其中的判断通常是会被求值的表达式，而依赖表达式的语法和求值规则。
		* 传统的语句强调“可执行”。但如之前分析的，现代的语言对类似语句这样的构造（至少在顶层）往往允许“非可执行”的扩充，导致这个外延实质上失效了。
		* 表达式和语句的这些语用外延的改变导致语法上目的不再有历史上的原始习惯用途一样的清晰的界限。但是，还是有不少的用户并不了解这些普遍知识，而以是否取得计算结果划分期望的语法构造，这使预期和实际语法设计产生了偏差，造成理解以及和其他用户交流上的困难。
	* 数学习惯上的求值总是纯(pure) 的，即不蕴含产生副作用；但这早已经不是现代主流编程语言及其背后的操作语义模型的固有限制——事实上，因为共享计算状态的这样的实用性上的考虑，第一个被广泛实现高级编程语言 FORTRAN 就不限制求值必须是纯的。
		* 限制纯求值的语言即现在通称[纯函数式(purely functional) 语言](https://zh.wikipedia.org/zh-cn/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B#%E7%B4%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80)，在数十年之后才因为和纯函数式的传统数学模型风格近似及其程序便于被并行化等理由，重新引起广泛注意。
		* 但是，严格排除副作用的语言没有和环境的交互手段，乃至无法取得计算结果，是缺乏可操作性上的意义的；纯函数式的系统只能隔离约定带有副作用的基本操作，其实现才具有可用性。
		* 即便如此，在纯函数式和指令式编程风格对立的背景下，表达具有副作用的基本操作在纯函数语言中并非和原始的“语句”具有相同地位，而往往是派生(derivative) 的。例如，有的纯函数式语言会把它包装为 [do-notation(en-US)](https://en.wikipedia.org/wiki/Monad_%28functional_programming%29#Syntax_Sugar) 这样的表面上近似传统语句的形式。
	* 对不严格符合纯函数式风格的编程语言，由于表达式的求值可能具有副作用，只要语法设计允许在出现语句的位置上出现表达式并丢弃求值结果，则语句并没有必要存在。反过来，若存在语句，也不能排除表达式的必要性。
		* 因为语句通常没有如子表达式一般普遍的“子语句”的递归语法设计的惯例，并不适合类似的设计——如果有，“语句”和“表达式”在语法上就没有什么区别了。并且，这样的语句必须补充不能被丢弃的子表达式的结果，语义上也不符合惯例，并且因为需要重新基于表达式的构造定义“求值”的概念，容易造成理解混乱。
		* 现时的典型的指令式语言中即便需要允许表达递归求值，通常提供的是把表达式包装为“表达式语句”，也并没有试图用语句取代表达式。
	* “语句”这一代表性概念实际只剩下程序片段中其实例出现的自然的字面顺序的这一特点被普遍遵守，而偏离是否取得计算结果相关的原始含义。这实际上**混淆了语法和求值规则这类语义规则的设计的界限**，导致一些直接的缺陷。
		* 一般地，作为抽象的事件，程序中任意两个子表达式求值的相对顺序和程序片段出现的语法顺序逻辑上无关。限制求值顺序跟随语法顺序需要附加约定，增加语义规则的复杂性。
		* 求值规则的这种设计限制了和语法顺序不一致的表达能力。最显然地，源代码的字面顺序具有确定性，因此这种规则不支持并发求值和调换非确定求值顺序的优化实现。
	* 当前的“语句”的概念除容易引起误会，对语言规则的理解经常也是有害的——用户直觉上容易依赖字面顺序替代求值顺序，乃至对求值这个无法回避的重要的机制完全缺乏了解。这也会影响之后的语言设计者，反过来又容易造成更大的混淆。
		* 习惯以语法顺序代替求值顺序思考的用户，会难以理解区分清晰分辨两者的具有正常设计的语言。
		* 对此习惯的适应可造成有争议的改动，典例如 ISO C++17 采纳的 [P0145R3](https://wg21.link/p0145r3) ，同时引入了以下问题：
			* 使语言表达能力下降（不再允许通过函数参数求值等实现一般意义下的若干表达式之间具有未指定的求值顺序）。
			* 不能彻底混同语法顺序和求值顺序而符合这种习惯（仍存在部分未指定顺序）。
			* 使求值规则大大复杂到一般用户几乎无法准确记忆的程度。
			* 可能导致实现支持这种新特性时出现缺陷（如 G++ 8 在 C++17 模式下不使用 `-fno-strong-eval-order` 时生成的程序仍不符合新增的对 [`new` 表达式中调用分配函数的确定性顺序要求](https://eel.is/c++draft/expr.new#23)）。
* 因此，考虑到语法设计的简单性和避免误会，现代不少语言已经在语法设计上排除了“语句”这样的单独的顺序执行构造，而提供在表达式的基础上确定求值顺序的构造（如 Scheme 的 `begin` ）替代。
	* 即便是顺序的非可执行构造，也严格限定其适用范围，并避免和被求值的表达式并列提及。
		* 而这样的构造往往只是习惯上的变通，仍然并非必要。特别地，通用目的语言本质上不存在需要区分“顶层”这样的语法上下文限制语法构造才可实现的可用性。
		* 在顶层引入类似变量声明的构造，可通过解释为修改隐式的和变量绑定构造关联的上下文（如环境(environment) ）的方式加以支持。这类机制是普遍的语义规则，本身不需要依赖顶层这个特定的语法上下文。
		* 特定目的的区分顶层上下文的限制可以由用户指定利用其它语义规则实现，这仍然不要求这个上下文是关于特定语法的。
	* 以指令式语言入门的用户可能对这样的设计仍有普遍的理解困难，这个事实表明不适当的语法设计的影响可以远远超出具体语言语法的范畴。

# 复杂

　　需要刻意注意的构造通常来自语法规则的复杂性。这种复杂性是抽象的，但并不是很难体现。对设计者以外的用户，最主要负担这种复杂性的场合体现在语法分析(parse) 上——不论是对人还是对机器的实现而言。

　　解析复杂的语法需要更多的上下文切换(context switch) 。用“上下文切换”这种特定机器实现气息浓厚的说法，是因为这不仅是人脑应对复杂性的比喻，而是普遍事实。就是抽象的机器实现，在[抽象机(abstract machine)](https://plt.cs.northwestern.edu/snapshots/current/doc/redex/redex2015.html#%28part._wed-aft%29) 操作语义的底层这恰恰是带来无法避免的开销的本质的麻烦之一——如函数调用和 `eval` 操作的 E(environment) 这样的上下文——虽然这仅仅是操作语义（元语言）中的真正的 context（所谓 hole ）的一个实例。

　　当然，机器的实现跟人脑相比通常并不计较运行时的开销，但实际情况当然远远不止例子中的规模，而且多余的开销处处存在。就算机器快到运行时无所谓多余的开销，设计、实现和测试语法分析器(parser) 的普遍代价也不是零。

　　更深层次的复杂来自语法规则自身。过于复杂和特设(ad-hoc) 的规则缺乏泛用性，而使记忆语法规则的效用下降；这反过来削弱了语法的重要性，也制造了冗余：反正记不清楚，为什么去记“不常用”的语法呢？为什么不在遇到“不常用”的语法的时候去查询语法规则呢？这里的问题是，划分“常用”或者“不常用”的语法子集的策略几乎无法避免导致用户体验的下降。实用场景中，判断“常用”和“不常用”的代价无论如何都很难是零，不论是读还是写，都很容易被打断现有的思路来对这些底层的问题进行“中断处理”。这种“优先级反转”损害了用户的普遍利益。早知这样，为什么不考虑简化语法呢？

　　一些设计者漠视语法设计中可能具有的用户体验问题的设计带来的问题，原因可能是：

* 无知：欠缺对使用场景和目的敏感性，也不知道普遍的做法的外延。
* 懒惰：逃避分析需求和方案的合理性。
* 跟风：无原则地认为遵循现有的设计是保险的。
* 盲目：因为种种认知偏差，认为这样的设计在绝对意义上代价不高，用户“应该”乐于接受。

　　有的语法设计，在特定的场景下可能是相对合理的，但在一般意义上具有不必要的复杂。这部分的复杂可能被作为习惯而遗留到其它衍生设计中，而先前的合理性不能发挥作用。这使复杂设计的负面作用更加明显，并且可能会有一些意想不到的副作用。

　　作为日常工具的语法需要有效，因此解析技术的复杂在工程上只能是妥协，而非适合通过复杂度来展现意义的话题。一旦复杂，那么已经说明某种失败。而以实现技术本身以外的进展在更大的背景（例如某个具体项目，或者作为评判某个语言设计话题的依据）下用复杂的分析器炫技，其理由比上面的分析或许更简单——多是无知（不知轻重）或无耻（有意搅混水）至少其一的行径。

## 关于上下文的例子

　　举例来说，解析 `1 + 2 + 3` 这样的表达式，不管按哪个方向扫描输入的字符，遇到不同的记号(token) 时总需要至少切换一次上下文并记忆状态；相比之下，用 `(+ 1 2 3)` 这样的同义表达式，在减小记号数量同时减少上下文切换数量上的效果高下立判。

## 关于历史遗留问题的例子

　　C 语言的中缀声明符(declarator) 语法，和二元操作符(operator) 表达式的中缀语法类似，在技术上都具有减小源代码长度的优势。而要保证能正确表达和分析这样的语法实际上是相当复杂的：

* 语言规范中的形式语法具有两套略相关但技术上没法合理去重的形式：声明符和抽象声明符。
* 几乎只能根据语言规范中的形式文法匹配而没有能够保证正确性的变通优化的替代规则。
	* 对机器来讲这似乎不是太大的问题，但对人来讲这是灾难性的：这些语法规则几乎不会被用户记住，于是在声明复杂到无法用直觉判定时，用户只能借助于看似靠谱但其实不能保证万全的“经验规则”，例如通称为“右左法则”或“[螺旋定则](https://c-faq.com/decl/spiral.anderson.html)”的[关于声明符的经验分析方法](https://docs.microsoft.com/en-us/cpp/c-language/interpreting-more-complex-declarators)。
		* 这不能正确分析被声明的标识符不明确的情形，例如函数声明的声明符中同时具有作为参数名标识符时。
		* 人类读者产生可分析的错觉的主要原因是，看到一个复杂的 C 声明时，读者倾向于首先认知这是一个单独的、合法的声明，且能根据已知的上下文语义信息确定哪个标识符是当前尚未声明的。
		* 但在严格意义上，上述简化假设是不能保证的：一个声明可能包含多个声明符；一个声明符中可能具有多个标识符，且不能在仅知声明而不提供上下文信息时，通过“右左法则”准确判定哪个标识符应被声明。
		* 对此的一个变通是，如有可能，避免使用复杂的声明，而使用 `typedef` 等同义形式代替。
			* 然而，用户实际上并没法保证这一点，在权威来源中也可能存在足够复杂形式的声明（例如，ISO C 的标准库函数 `signal` 的原型）。
			* 这也是上述经验规则的流行的一个原因。
	* 一个表明这种方法局限性的一个具体例子：声明 `void (*signal(int, void (*fp)(int)))(int);` 是可分析的，但照搬相同的方法无法正确分析表达式 `(void (*(int, void (*fp)(int)))(int)) 0` 中的抽象声明符（而无法进一步分析出这里在语法上正确，而存在一个转换为函数类型的语义错误），因为事先不知道 `signal` 这个作为起点的标识符。
	* 根本上，这种方法可用的原因，也仅在于它是形式文法的一部分罢了（所以能在补充一些前提下保持正确）。
	* 此外，这种方法不足以涵盖关于声明的语法的扩展。
		* 例如，ISO C99 在声明符中支持 `static` 等规则，并没有被自然地涵盖；为了解读这些语法，仍然需要单独考虑附加的形式规则。
		* 即便这样的扩展原则上没有使这种经验规则失效，语言的实际演化也不太可能继续让这里的语言规则显得更复杂，但并非理论上不可行，也没有被保证不被破坏。
* 讽刺的是，显然今天绝大多数的 C 语言用户已经不再利用这里的技术优势。
	* 例如，几乎所有代码规范都会约定，声明符的记号之间应插入空白符（以提升可读性）。
* 一个历史副作用是，声明符中的 `ptr-declarator`（也就是包含参与到决定类型名中的 `*` 的声明符）无谓地制造了代码风格的分歧：到底是 `T* p`、`T *p` 还是 `T * p` ？
	* 从一个 `ptr-declarator` 对应一个被声明的标识符，而一个声明可包含多个 `ptr-declarator` （如 `T *p, *q, r;`）的角度看，似乎 `T* p` 是合理的。
		* 但事实上这不适用于函数的形式参数的声明。若要正确反映此处声明的语义，在函数参数列表中应该使用 `T* p` 。若已经在其它场合使用了 `T* p` 以外的声明方式，为避免损害一致性，在函数参数声明中对应使用 `T *p` 的风格仍然很常见。
		* 这在早期的 K&R 声明语法中不是问题，因为早期的函数声明根本不支持在参数列表内部声明参数类型的语法。然而，新的语法是 ANSI C 鼓励的原型声明方式，也是现在主流的用法。如 C++ 等借用 C 语言的设计的语法，即便继承了声明符语法（以及这里风格分歧）的传统，也不支持 K&R C 风格的声明，因此必须面对这个问题。
	* 相比之下，统一为 `T* p` 看起来是个更务实和容易在不同用户之间贯彻一致性的做法。分离 `T*` 这样的类型名一般具有更好的可读性，尤其对兼容这样的语法但针对类型名的操作可能更频繁的 C++ 这样的语言来讲。不过由于语言仍然支持 `T *p, *q, r;` 的声明，这还是一定程度上依赖自觉。
	* 除此之外，实际上还有 `*` 和其它行声明对齐的风格。不过这种风格是特定目的下的局部风格，一般用意比较容易辨认而不至于引起误会，所以问题相对较小。
* 这样的设计遗留到了其它语言中。
	* 最广为人知的例子可能是 C++ 。进一步地，C++ 扩充了声明符中的 `ptr-declarator` 的记号 `*` ，允许 `&` 和 `&&` （单从这里的设计体现一致性倒是无可厚非）。类似的扩展还有 C++/CLI 的 `^` 。
	* 即便 Java 没有 `ptr-declarator` 的对应物，在数组的声明语法中还是采用了类似的做法。
	* C# 相比 Java 放弃了中缀的写法，即便 C# 重新引入了指针而需要有 `*` ：声明的语义上保证了 `*` 和类型名前缀的结合，而不支持一个前缀对应多个 `ptr-declarator` 。如需在同一个声明中引入多个标识符的声明，则需要重复 `*` 。这也基本消除了上述代码风格的争议，但在对习惯与之不兼容的 C/C++ 语言语法的用户来讲，仍有误用风险。

　　不限于中缀风格的声明符语法，一般的中缀操作符的表达式语法也带来了一些限制。除了和中缀声明符语法（以及刻意引入 `++i` 和 `i++` 这样微妙的设计）同样损失了原始的节约源代码长度的技术优势外，中缀操作作为表达式语法还限制了表达能力，并因为复杂的优先级和结合性的语法规则的特征，制造用户记忆上的负担：

* 二元操作的语法不能直接自然过渡到函数调用，不同的语法导致为了看起来普遍自然，可能需要添加“操作符重载”的设计。如果一开始就没有特设的二元操作，那么根本不需要有这些复杂性同时仍能不损失相同语法代表的操作的普遍性。
* 四则运算以及 `%` 或许容易被多数初学者接受和掌握，但大部分即便在工业界“熟练”掌握 C 语言的用户并不足以让业界信任准确掌握了 `<<` 以及 `&` 等操作符和这些运算混用的情形，以至于甚至实现都需要警告加上括号。
* 类似 C 语言这样具有“丰富”的（二元甚至更多元）操作符的现有设计似乎使某些设计者产生了对用户接受扩充中缀语法的盲目乐观，乃至认为中等教育程度的用户应当能像接受四则运算一样容易接受各种不同的中缀语法。
	* 然而“定义新运算”的语法实践实际上普遍不属于学历教育中的必修内容（尽管可能出现在所谓“奥林匹克数学”的教学中），所以至少对初学者，门槛是普遍存在的。
	* 即便是对有经验的用户，不同语言之间可能存在的微妙的差异带来的成本也不是零，唯一能普遍可行的方法似乎就是忘记特设的优先级和结合性规则，不确定时就加上括号——然而这样为什么不直接用函数代替特设语法的操作符呢？

## 应对

　　语法设计的不必要的复杂性应根本地从设计上寻找原因并试图克服来解决：明确引起语法规则复杂的需求来源，合理地把一些语法上不合适处理的规则转移到更普遍的语义规则中处理。然而遗憾的是，大多数设计者并不能彻底分析复杂性的来源；不少通用目的语言的设计者欠缺识别需求通用性并拒绝其中不合理部分的能力。对这些作者来说，他们可能会使用其它措施来变通而不是解决问题。这样的变通无法深入语法规则自身，所以往往着眼于用户的语用体验。

　　一种在语用复杂性上的通用的变通措施是[语法糖(syntax sugar)](https://zh.wikipedia.org/zh-cn/%E8%AF%AD%E6%B3%95%E7%B3%96) ，即提供特设(ad-hoc) 的语法来替代其它语法的语用。这在迭代语法设计的不同版本时保持兼容性（以及掩盖旧的语法设计的失误）的场合往往很有效；也可以用来模拟不同范型的惯用法——例如纯函数式语言模拟指令式顺序风格的 do-notation 。但是，语法糖不可能根本地解决语法设计过于复杂的问题；相反，还很容易加剧复杂性：

* 按定义，语法糖提供的语法是已经在源语言中支持的语法的同义表达，因此语法糖实质上依赖被包装的其它原始语法，去掉后者就不是语法糖了。考虑语法规则的通常表达形式几乎不可能被复用，对设计者来说提供两种语法总是比提供一种语法需要更多的工作。
* 对用户而言，记忆清楚两种语法规则同样需要投入更多的精力；即便用户总是预期不打算记忆非语法糖形式的原始语法，语义的理解也必须依赖原始语法，实际上很难保证这就起到了简化。
	* 语法糖只能起到简化用户已经熟知语义时的特定的一些语用场景。然而，对通用目的语言，对特定的场景“优化”的这种设计很容易流于过度设计，并没有解决问题。
* 更麻烦的问题是，用户并不总是能熟悉近似语法对应的精确含义时，随意替代同义语法的习惯很容易进一步混淆用户对语法和语义分别解决的问题的范畴的混淆。有时候，还会出现实际上不是语法糖而被误认为语法糖的情况。
	* 一个典型例子：不少指令式语言新加入 lambda 表达式实现“匿名函数”，被用户误认为是具名过程（函数）的语法糖。这不一定成立，而且通常不应该成立。
		* 使用同义语法的替代并不保证精确地等义，这种情形下的匿名函数就不可能通过语法糖得到。例如，C++ 的求值得到闭包对象(closure object) 的 *lambda-expression* 就不能作为其它特性（如函数对象）语法糖，因为并没有其它语法支持等价地表达闭包对象的未指定属性（如捕获变量被存储在闭包中的布局的显式未指定(unspecified) 的初始化顺序）。（此外，因为重载等原因，C++ 的 *lambda-expression* 在功能上也不能替换传统的函数，这体现语义设计也具有冗余。）
		* 语义上匿名函数本来就比这些语言中具名函数更基本。通用目的语言中的具名函数本应设计为指称匿名函数的变量（若要拒绝修改函数，可以限制为拒绝修改匿名函数的绑定）；但由于种种历史原因，具名函数和变量指称的实体（“对象”）往往被区别对待。这些原因基本没有普遍的合理性：诸如“函数不是对象，因为它不提供确定的可访问的存储”这样的理由，相比使用名称指称实体而实现变量支持的普遍机制来讲，是更低层次的实现细节；把这样的设计提升为特设的规则的动机并不充分。

　　另一种和语法糖相对的做法称为[语法盐(syntactic salt)](https://zh.wikipedia.org/zh-cn/%E8%AF%AD%E6%B3%95%E7%9B%90) ，是指在语法规则中要求用户冗余表达的设计方式。和语法糖不同，语法盐以语用上的复杂性为代价减少非预期的代码错误，即语用复杂性总是会相对不要求冗余的对应语法更大；此外，语法盐要求的冗余可以是语法规则内部体现的，并不严格要求替换其它同义语法。和语法糖类似，语法盐在语法设计演进中也容易起到作用。若语法盐不排除被替代的易错的同义语法，则和语法糖一样会加剧语法设计的复杂性，同时其作用依赖用户的自觉。否则，冗余的合理性依赖和语义规则的交互作用。因此，语法盐也不是普遍可靠的在语法设计上消除复杂性的做法。不过，某些情况下合适的语法盐能区分原本不够明确的不同语义功能而简化具体情形的语义设计——例如 C++ 的显式转换代替 C 风格显式转换，排除 C 没有对应的部分的具体转换的规则反而更简单（虽然保留后者使之在某些情况处理为前者的语法糖使转换规则整体上仍然更复杂了）。

# 意义

　　语法设计的复杂，除了导致上述的复杂处理的表面问题外，还隐藏了更一般的麻烦问题：损失普遍性，并妨碍抽象的目的。

## 计算目的

　　对（因为不方便使用而）不适用 [AOT 编译(en-US)](https://en.wikipedia.org/wiki/Ahead-of-time_compilation) 的场合——包括人脑——解析语法的工作构成了求值算法(evaluation algorithm) 的算法复杂性的基础，也构成了计算性上的(computational) ——即为了通过操作语义规则得到计算结果的——需要克服的复杂性的基础。因此复杂的语法和语义一样会直接影响实现计算目的的效率。如果解析语法不是直觉上特别有目的的行为，语法不应该承担比语义更显著的角色。

　　一个语法上起到重要作用的构造的例子是[结合律](https://zh.wikipedia.org/zh-cn/%E7%BB%93%E5%90%88%E5%BE%8B)。结合律用中缀风格的语法来表达时显得简洁易记，但使用前缀或后缀的写法就比较晦涩了。这说明中缀语法的优越吗？不，普遍来看恰恰相反，一般的计算中非二元操作远远多于（主要是作为某些构造性实现的）二元操作，因此结合律实际上并不应具有计算上的普遍作用。习惯性滥用结合律是一个“以辞害意”的例子。

## 本质问题

　　强调并不自觉依赖结合律这样的语法风格，在语法以外的一个直接原因是“二元操作中心主义”。这体现在二元操作的原生特殊支持——而扩展二元操作往往用 [fold(en-US)](https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29) 实现。但是，若要反方向归纳到二元以下的操作上，又需要有特殊的规则。这和 Lisp 风格用 `(+)` 、`(+ 1)` 、`(+ 1 1)` ……这样的序列通吃任意有限参数个数的操作而归纳出一致性相比，显得并不自然。

　　当然，以二元操作中心的方法论用于抽象目的上并非全然是无效的。得益于[数学归纳法](https://zh.wikipedia.org/zh-cn/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95)和[递归](https://zh.wikipedia.org/zh-cn/%E9%80%92%E5%BD%92)的表达形式，像 [cons pair](https://en.wikipedia.org/wiki/Cons) 这样的还原主义方法就体现出了单一的二元操作(cons) 的简洁而普遍的威力。

　　但是，体现这种适用性的目的是*建模(modeling)* ——为了得到抽象的描述和理解对象本身的构造。一旦目的改为通过变换不同粒度的对象以解决一般的问题——*计算(computing)* ，其最明显的劣势就体现来了：直接使用二元操作解构运算的步骤来替代计算上的操作，会有复杂度上的困难。造成这种困难的原因是，要解决的问题通常并不在乎二元操作这种具体的实现细节，而二元操作隐含的归纳法本质依赖的局域性可能就只能作为可选的实现细节才不至于阻碍问题的解决。实际是否形成阻碍，取决于算法是否仅依赖局域特性。例如，当对一个序列(sequence) 进行搜索时，元素访问操作是局域的，而比较操作是不限制局域性的，因此使用 cons pair 这样的方式来表达序列的构造并不阻碍只依赖局域操作的最基本的顺序迭代算法；但这样的构造并不能利用超出相邻元素的局域的性质——当这个序列全局有序时，使用 cons pair 的构造无法利用全局性而不能直接支持[降低计算复杂度的有效算法](https://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95)。再如，cons pair 的实现方式蕴含了序列中非预期存在的构造顺序这一细节，而暴露了构造、访问和析构操作可能的和顺序相关的[副作用](https://zh.wikipedia.org/zh-cn/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8)，使结构上的实现细节（非预期地）泄漏到普遍行为上，阻碍[信息隐藏(en-US)](https://en.wikipedia.org/wiki/Information_hiding) 和抽象目的的准确表达。

　　另一个次要的困难是，表达本身在计算上的冗余——罗嗦。有时候，这种罗嗦还可能“传染”到使用这些表达的问题的解中，使解的形式并不够具有预期的良好性质。要使解能符合原始目的，还需要一个附加的变换把解的形式修改回看上去更“正常”的形式。实际上，这时候被直接解的问题并不是原始问题。通过变换问题的形式使问题可解是个很实用的重要思路，但是在问题本来就并非难以解决时，这种多此一举就是一种过度设计，显然是有害的。

　　上述问题共同导致许多常用的抽象脱离使用二元操作构造表示的模型而存在独立的意义。不少时候，通过二元操作或其它还原论方法构造的模型仅仅起到模型论意义上的作用——例如，大多数时候人们不使用[集合论编码](https://zh.wikipedia.org/zh-cn/%E8%87%AA%E7%84%B6%E6%95%B0%E7%9A%84%E9%9B%86%E5%90%88%E8%AE%BA%E5%AE%9A%E4%B9%89)来表示自然数，即便是不使用加法之类套用模型会有算法复杂度问题的场合。

## 其它妨碍

　　在具体使用中，过度依赖二元操作或更特定的操作语法代替更直接自然的形式的局部设计，会以更复杂和看似偶然的方式嵌入到整体设计中，影响语言用户对问题和解决问题的方法的理解。这些影响的广泛性和深刻性可能并不小于上面的本质问题造成的负面影响。这些影响至少包括：

* 这种习惯倾向在语言设计中引入特设的(ad-hoc) 欠缺可扩展性的特性。其中，最直接的典型是[操作符重载(en-US)](https://en.wikipedia.org/wiki/Operator_overloading) 。
	* 因为语法上有限的操作符（通常其优先级和结合性还被写死了）通常有受限的内置的语义，不足以表示一些近似的语法形式，保留语法而替换具体语义的“重载”被发明以解决这样的问题。
	* 作为一个直接结果，这使语言的语义规则更加复杂。
		* 和通用的其它设计结合，这直接制造了更多需要解决的问题（例如，如何解析操作符找到非内建处理操作符的逻辑，使之能和词法作用域(lexical scoping) 、名称解析(name resolution) 等一般机制相容）。
		* 当然，无视复杂性的代价，这确实是可解决的，而且大部分复杂性普通用户经过训练后可以无视——所以也的确被作为 C++ 等一些现实语言的特性和“优点”。
	* 但是反过来，为什么不直接使操作符和“函数”一样共享语法而根本不需要引入这些特设的规则呢？
		* 即便非要适应特定领域用户对语法习惯，也完全可以局部地作为语法糖来设计，而不需要引入成套的复杂规则。
		* 现实中，不得已引入特设的复杂的规则，一个可能的原因是在此之前因为语言欠缺通用的语法扩展能力（如[卫生宏(en-US)](https://en.wikipedia.org/wiki/Hygienic_macro)）而无法可靠地把这样的特性作为语法糖，不过这就是另一个话题了。
	* 注意操作符重载是一种[特设多态(en-US)](https://en.wikipedia.org/wiki/Ad_hoc_polymorphism)，因此也自然具有特设多态带来的实用性问题，例如滥用（过度依赖领域知识）导致难以理解。不过这和语言的语法设计没有直接关系（因为造成的问题多少取决于用户如何使用这项特性），应与以上问题区分。
* 传统数学教育不够区分操作符关联的[操作顺序(en-US)](https://en.wikipedia.org/wiki/Order_of_operations)而使用户容易存在一些关于“计算”本质上的认知偏差。从经验上看，这种实际偏差被某些语言设计的问题放大了，且已经造成了用户学习和使用的困难，乃至因此在产品中制造了更多的缺陷。**随意、粗放而欠缺一致性的特设的语法规则加剧了这种现象。**
	* 因为传统数学中表达计算的系统本质上是[纯函数式](https://en.wikipedia.org/wiki/Purely_functional_programming)的，在子表达式中使用操作数进行计算的不同局部顺序并不会影响表达式整体的计算结果，所以新手往往不会注意到迁移到更有表达力的可能有[副作用(en-US)](https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29) 的系统中，忽略顺序导致的后果和导致这些后果的直接原因。继续这种思路进行语言的教学，会使用户容易陷入误区，事半功倍。
		* 用户被迫使用和数学教育过程中习得的相当不同的思维理解编程系统才能使编写的程序大体符合预期，而错失探究不同语言之间在数学上的存在的一些普遍联系的机会。特别地，在[重写系统](https://en.wikipedia.org/wiki/Rewrite_system)这样的模型中，行为看似不同的系统实际上是统一的。
			* 例如，上述局部顺序不影响计算结果的一般性质，在重写系统的意义下称为[汇聚性(en-US)](https://en.wikipedia.org/wiki/Confluence_%28abstract_rewriting%29) 。
			* 再如，传统的数学表达式作为重写系统具有[强规范化性质](https://zh.wikipedia.org/zh-cn/%E8%A7%84%E8%8C%83%E5%8C%96%E6%80%A7%E8%B4%A8)，保证有限的表达式的计算总是能经过有限计算步骤后终止，而一般的程序并不一定有这样的保证——实际上，[非终止性(en-US)](https://en.wikipedia.org/wiki/Nonterminating) 可以建模为一种副作用；此外，[图灵完备(en-US)](https://en.wikipedia.org/wiki/Turing_completeness) 的系统必须允许构造不终止的程序。
			* 若用户只使用总是汇聚和具有强规范性的这些**缺乏普遍性的特例**，反而不容易觉察和理解这些性质，且很可能进而**影响对通用目的语言能实现的特性的想象和理解**。
		* 用户同时错失对[求值策略(en-US)](https://en.wikipedia.org/wiki/Evaluation_strategy) 进行认识的机会，而进一步**妨碍对计算的本质特征和典型的语言如何实现计算的一般机制的理解**。
	* 因为对顺序问题理解上的含糊，使用表达式求值可能有副作用的语言，用户往往有更大的机会犯错，并且甚至在试图解释时继续犯错而自以为是地认为理解了。一个经典的例子是 C 语言的 `printf("%d %d %d", i++, i++, i++)` 这类存在[未定义行为](https://zh.wikipedia.org/zh-cn/%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA)的表达式求值的解释。
		* 抛开表述未定义行为的语言规则对表达式的求值顺序(order of evaluation) 的概念具有的依赖，混淆从左往右的语法分析顺序（同时应该也是大多数用户会习惯的“自然”的阅读顺序）和求值顺序甚至附会到某些实现的[调用约定](https://zh.wikipedia.org/zh-cn/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A)中作为函数参数的子表达式求值结果的传递顺序这**三种不同顺序**的问题，使用户对程序语义（而不是行为）的理解可能南辕北辙。
		* 未定义行为本身的性质使用户进一步原则上不可能推测出程序能具有的“正确”的可预期行为。
	* 即便抛开顺序本身的含义，使用 [PEMDAS(en-US)](https://en.wikipedia.org/wiki/Order_of_operations#Mnemonics) 这样的助记符灌输个别的教条形成的刻板印象也容易使用户适应新的优先级和结合律等规则更加困难。最直接的，用户需要一定程度上在 PEMDAS 以外的操作符的表达式付出记忆附加的求值规则的成本。
	* **中缀中心主义的风格以一种不容易被注意到的方式大大加深了类似的潜意识性的影响**，使用户更难判断语言设计的合理性。不少这样的语言（虽然不止是这样的语言）会以支持大量的操作符（以及对应表达式的特设的求值规则）来体现“功能丰富”，这客观上加强了用户理解具体操作规则的要求，而**竞争性地弱化了对表达计算的一般机制的理解的要求**。实际上，这样的设计因为之前提及的附加的规则记忆成本等问题而放大了这类设计的局限；但种种原因下，某些语言设计者和用户仍然陷入了斯德哥尔摩综合症的怪圈（认为中缀是“大众”意义上更合理的，全然不知晓或理会因果上的先来后到）。
	* 同时，没受到这些思维定势和怪圈影响的用户通常并不怎么关心这里的问题，或者认为问题不大，结果导致市面上的语言更倾向于不在乎这些问题的设计。久而久之，工程选型的范围也受到限制，在这方面上就整体“劣币驱逐良币”了。

## 一转攻势

　　着力于在两个现有数学体系之间建立联系（通过[态射](https://zh.wikipedia.org/zh-cn/%E6%80%81%E5%B0%84)）的[范畴论](https://zh.wikipedia.org/zh-cn/%E8%8C%83%E7%95%B4%E8%AE%BA)本来并没有太多的槽点，不过其中一些不良语法习惯被某些语言奉为“函数式”正统设计以至于把一些用户迷得神魂颠倒就颇有些奇怪了。

　　讽刺的是，在这个背景下的最基础的[复合](https://ncatlab.org/nlab/show/composition)，传统语法也有[歧义](https://ncatlab.org/nlab/show/composition#Notation)，以至于要强调所谓的 diagrammic order 。注意作为结合律的适用的典例，复合操作具有上面提及的所有问题。强调 diagram 这种先天被局域作用限制的语法已经在一定程度上误导了局部结构的在一般问题的解中所占的比重，乃至歪曲了表达解时本应注意到的抽象甚至目的。

# 语用习惯和程序风格

　　跟语言设计相关的问题，往往需要迁就非语言设计者的用户习惯。这可能带来以辞害意的问题——仅仅为了适应习惯，而不是更根本的需求而决定设计。显然这是个不良习气。

　　更糟糕的是，用户之间也可能因为对习惯偏差不同而产生争议。（在 DSL 中，习惯容易找到缘由上的共识，所以后者主要是通用目的语言设计的问题。）大部分现实情况下，后者可以归咎于设计者欠缺充足的考虑，因为不大可能每个用户的意见都是不合理的，往往从设计者自己没能充分考虑到不同场景的需求开始就埋下了祸根；而被迁就的用户作为帮凶，趋向冲抵人头数来坐实不合理的设计的必要性——剩下的在表达需求话语权中竞争失败用户，通常更倾向于用脚投票而选择其它的设计（即便其它的设计也可能存在类似的不一而足的其它问题）。

　　考虑到设计者有一贯的历史传统在这类决策中被带到沟里，因此不能等闲视之。另一个问题是，有不少本来简单的普遍问题，在这种氛围中逐渐愚蠢起来了，直至变成了集体无意识的避讳——哪怕稍微思考一下都很容易理解。当然，为了避免浪费时间这样的理由纠结这样的低级问题，倒也无可厚非。诸如缩进用制表符还是空格、大括号后要不要换行的问题……一开始要我这样的沙雕问题的屁股在哪，其实我是拒绝的。因为我觉得……一般人不能跟沙雕一样见识。但是后来沙雕的猴子多了，要控制一下种群数量了，所以就得加特技了。

## 判断基准

　　这样的问题的简单性，首先是词法(lexical) 性质上表现出来的。作为常识，这些被讨论的语言都是应当便于被人阅读的高级语言，所以作为用户需要明白自己预期什么样的视觉(visual) 特性：看得顺眼而便于读写就是好的，否则就是不好的。

　　不过，要取得共识，判断是否能“顺眼”，不能是纯粹主观的标准，而必须要有客观的依据。对习惯阅读代码的用户，至少在一些基本外观相关的直观效果上，理应是简单的；遗憾的是，事实并非如此。这集中体现在某些用户的**双重标准**上。一个典型例子：有说法声称类 ALGOL 语言的左大括号（`{`）之后的换行为了避免只有单独大括号的行，以便在屏幕上允许更稠密的代码。然而作为这些语言的用户，稍经过大脑就应当发现这经不住推敲：如果真的是为了避免单独大括号浪费行数，那为什么不使用类 LISP 的风格，不保留单独具有右大括号（`}`）的行，非得只强调左大括号？（即便完全没有类似风格的经验，这一点都不难想象，几乎是个会使用这样的语言的用户都应该能“发明”得出来。）除了经不起推敲的双重标准，更多例子中，部分用户同样地忽略逻辑推理来审视习惯性需求合理性的必要性——结果选择了相对更不合理的设计。例如，使用制表符在文本数据流中表示缩进诚然只是一个变通（制表符自身的确算不上有“缩进”的含义——但这可以通过领域习惯约定补充），但使用本来同样没有“缩进”的含义的固定数量的空格来替代制表符显然在各种意义上（无论是持久存储的不必要开销、编辑器和其它项目配置兼容性相关的编辑和维护体验上）都是更加低劣的；这样，流行的一些观点就更耐人寻味了。（更一般地，在[编码、换行、BOM 等文本流相关格式选型的问题上，不少用户也有类似的理解偏差](about-operating-systems.md)，但这也不只是视觉效果那么直观的问题。）

　　正常情况下，**习惯**不是**瘾**，如果发现明显的不合理，理性的判断应该能够自然地自觉摒弃。这类不够经过大脑的武断判断能够生存甚至借助集体无意识而流行的状况，如果不是成瘾性戒断症状，基本就是**跟风**的体现。新用户的跟风本身减少了沟通成本，倒不全然是坏事；坏的是，这些只知结论而不知缘由的用户习惯，助长了对审视自身需求的取消主义的**反智**作风，也普遍地纵容了不良的设计；及至这种现象被习惯地避而不谈，持久地损害了用户合理表达需求的自由。因此，不论是否作为语言设计者的角色的立场上，这都应当打击的对象。

## 避免教条

　　应当强调，这里要求“经过大脑”的首先是分析理由的过程，而不一定需要是具体结果。因为不同领域不同来源的需求不一定存在全然的共识，允许不同本身就是通用目的语言设计需要满足的需求。所以，强迫用户不能使用不同的风格来强行统一，往往是更糟糕的设计，并且更加毫无疑问地容易引起争议。如 Python 这样强制地禁止 ALGOL 传统的允许不同空白符的自由形式(free form) 的来避免风格不统一，就是这样的实例。虽然动机并非完全不合理，在语言中强制这样的设计，并没有解决预期想要避免的问题——而仍然需要如 [PEP 8 这样的风格导引](https://www.python.org/dev/peps/pep-0008/)来擦屁股。技术上这还有更大的问题：这种强制一致性的设计影响的不仅是视觉效果，还有语义上的缺陷（如检查 `IndentationError` 对自觉遵守一致性约定的用户的不必要的开销）。整体上看着就是一种 garbage in gargage out 的闹剧——用户自身没能足够反省造成不一致困难的来源，设计者选取了“解决提出问题的人”的思路妄图解决一个原则上就解决不了的问题，结果理所当然地并不能让大多数用户满意。对此视而不见的剩余用户，则和设计者一道充当了鼓动传播反智方法可行性的不光彩角色。

　　这种强调过程而非结果的方法也可能预期地导致很具体的结论上的不一致。例如，关于 `{` 不换行是否一定更不合理？实际也不一定。节约行数虽然并非充分的合理理由，但单独 `{` 会占用屏幕空间而可能影响代码阅读体验是客观的事实——只是是否占用空间的负面影响足够大到应该优先考虑这点需要根据其它需求的相互作用而定罢了。类 ALOGL 语言的用户应容易理解，在 `{` 后换行的一个直接好处是，配合 `}` 前也换行，用户在视觉上能够快速定位匹配的 `{` 和 `}` 而快速分析代码块的边界。注意这种相对高效的扫描是适应人的视觉特性的二维并行算法，不同于机器的普遍实现。即便有高级的自动匹配括号的编辑器环境使用户能够通常不在乎这样“小”的好处，依赖编辑器也不能在块的定位上取代这里的视觉效率优势（这类似资源预分配不可能取代不进行资源分配的性能优势的逻辑），更不能代替这种策略不依赖文本编辑特性可用性以及不可靠性（如在多种括号错误地没有匹配的情形下）的优势。但在稠密的嵌套代码块中，如果块足够短，那么要求换行的优势可能小到可以忽略，这就是可能值得变通为不换行了——特别是考虑要求对对应的 `}` 前插入换行的要求可能在复杂的嵌套表达式中（如 C++ 中作为某个 `postfix-expression` 子表达式的 `lambda-expression` ）表现得很不自然，就不难理解这里的权衡应当优先于词法上的教条结论进行记忆的动机。

## 理论方法

　　理解上述的优势是否足够“小”的问题，在一定意义上无法避免主观理解引入的偏差。实际操作中，这种偏差应当定义为特定领域中特定涉众要求的需求，并在具体代码风格约定规范上继承——而至少排除出语言设计的强制要求之外，以避免毒害语言在不同领域适用的普遍性。指导这种判断可通过对语义的非必要影响来有限地度量，或者至少能一致地偏好顺序以明确其相对效用。具体地，在给定无歧义的需求集的前提下，可定义平凡性(triviality) 来确定“没意义”的下限：若两种风格的选取不能被需求集提供的任意判定方法在接受或者拒绝的结果上体现出差异，则这个风格差异是平凡的，强制其选择结果的规则应当被排除出语言的设计之外。以这个原则考虑，要求消除平凡的语义风格差异（如引入强制缩进）是根本地有害的，因为它混淆了只满足个别涉众的次要的风格差异和满足更普遍涉众需求的、真正更应跟程序自身目的相关的非平凡语义差异（如实现算法引起的程序的差异）。

　　试图把本应明显适合作为语法差异的处理问题延迟为语义差异解决，可造成在最优化工程成本的意义上的一揽子没事找事的多余问题——不少看上去似乎可能但实际上又无法被可编程地自动有效处理，而不得不要求程序的维护者最终以能从明确需求集无歧义推导确定以外的方式投入精力人工干预（如根据对程序实现的具体目的的理解去判定某个缩进是不是真的漏了），以确保效果上可疑的风格的一致性的本不必要的问题。有一个很直白的诘问：为何不直接要求程序的构造时就使用保证能自动处理的语法性质进行约束（如“把 free form 空白符作为平凡性质而作为不影响语义等价性的性质忽略”的传统策略），来代替这种效果可疑的强制？也许只是设计者单纯没考虑这点罢了，所以造成了这种笑话；但坚持笑话不动摇而持续造成损害，就不是什么笑话了。应当注意，由于已经依赖维护者个别经验的判断依据不可能由语言预设的语法规则决定（最好的、明确无歧义、能在所有维护者之间形成共识的情况下，这也是一个平凡的语义性质），这是一个理论上普遍而无法变通回避的问题。与此相对，若（适合“真正的”）语义差异是非平凡的，则总是需要人工干预，很大程度地回避了效用可疑相关的争议，参见 [Rice 定理](https://zh.wikipedia.org/zh-cn/%E8%8E%B1%E6%96%AF%E5%AE%9A%E7%90%86)。当然，也并非所有非平凡语义性质都应该是同等有资格地非平凡的，例如具体同等复杂度的两个不同算法的选取可能是对某个需求平凡的——而应当作为实现细节。这根本上也是工程上应区分作为设计直接内容的接口以及接口的实现的必要性的一个实例；反过来说，这也体现了不合理的语言规则的延迟设计，一个来源是设计者对工程原则上的需求理解的（潜意识的）偏差。

## 辅助特性

　　除了一般意义上的语法规则，还可能存在一些某些和语言设计并非直接相关的、通过语言规范之外的手段实现的特性。这些特性的用意同样是为了优化用户的视觉体验。但是，大多数情况下，这些特性只是辅助手段，不能代替语言设计的影响，反倒受制于语言特性的设计。

　　这种特性的代表是[连字（合字）(ligature)](https://zh.wikipedia.org/zh-cn/%E5%90%88%E5%AD%97)：通过使用特定的字体渲染方案，使多个字符(character) 联结形成和通常单独呈现的多个字形(glyph) 不同的形式单一字形。这是西文字体排印学技术的应用，对要求固定视觉风格的输出有一定作用；对个别字形进行的调整方案如果合理，也能加大视觉区分度而避免误用。但这在原则上具有的很大局限性：

* 字符序列的针对性调整是有限的，一般受限于具体语法设计提供的记号(token) 。
	* 且和剩余（没有被作为连字处理的）的字符构成的记号（序列）的视觉表现风格并不一定容易保持一致。
	* 类似 [APL 语言](https://zh.wikipedia.org/zh-cn/APL%E8%AA%9E%E8%A8%80)方式直接滥用字形可以避免这个问题甚至取代连字本身，但非通用的记号对读写都容易造成严重的负担。（与此相对，[J 语言](https://zh.wikipedia.org/zh-cn/J%E8%AF%AD%E8%A8%80)针对这种问题使用简化的设计方案，正好和连字的效果相反，但更多侧重关于写而非读的体验。）
* 一定程度破坏视觉上的感知的效率。
	* 因为改变了非连字情形的默认间隔，这对等宽字形的预期预测阻碍尤其明显。
* 不论是抽象还是外部表示，编辑体验都更复杂而可能不一致。
	* 例如，考虑删除一个“字符”，用户应预期到的编辑器的响应方式。
* 通常要求特定的字体支持。
	* 这减少用户对统一的视觉效果的选择余地。
	* 有时需要更加关注印刷字体的效果和屏幕显示的效果不同。特别地，许多劣质的印刷出版物滥用非等宽字形和屏幕显示的不对等的问题（如误用全角标点）已经带来了感知上的不必要的差异；在这个方式上引起用户习惯的分歧可能会更加混乱，劣化学习多种语言的用户的体验。
* 对文本渲染实现的要求更高。
	* 不论是基于 Unicode 这样的文本编码还是仅依赖渲染部分的后处理的实现，要完整地实现都有一定难度。而正确的编辑操作（光标定位、选取和其它交互式访问操作）也显然地更困难。
	* 这使编辑环境的更难实现可移植性（也基本不被终端支持）。
	* 这减少用户对编辑环境的选择余地。

　　因为这些问题，这样的特设“优化”欠缺实用于一般需求的能力。越是通用领域的语言，一般在预设的用户体验中避免依赖这样的辅助特性，而留给用户自行决定。使用多种语言的用户同样不应依赖这样的特性是如自由形式的空白符一般普适的特性。

# 解决

　　避免麻烦的语法和相关问题的大部分套路并不难：

* 除非必要，避免新造 DSL 。
	* 使用成熟的设计。
	* 使用通用目的语言构造 DSL ，而不是从头造轮子。
* 避免没有明确目的的中缀语法等过度依赖局部结构的设计。
	* 尤其避免设计生造的新的中缀语法。
	* 使用类似 `x . y . z` 到 `. x y z` 这样的变换消除一般情形中对结合律等局部特异性质的不当依赖。

　　不过，不擅于独立思考以及观念上先入为主的偏见容易导致难以实践本应简单的套路。这可能是相当难以纠正的。原因的一部分可以归因于理解上的困难，这来自经验和想象力的匮乏。

　　例如，就二元操作语法，有观点认为：函数调用表达式中，作为操作符的函数和操作数(operand) 的语法组合仍然是中缀的；即 `f x y` 实际上是 `f call x y` 或者更明显的 `(f) call (x y)` ，其中 `call` 是原本隐含的中缀操作符。这从实用上看似自然，实际却隐含了使用关于“调用”的求值策略的并不见得那么自然的前提：操作符和操作数作为表达式的求值保持相对独立，例如 [WHNF(en-US)](https://en.wikipedia.org/wiki/Lambda_calculus_definition#Weak_head_normal_form) 。作为后果，这种刻板印象排除了一些非决定性的其它优化求值策略，如允许在求值前对操作符内部结构进行（可能和操作数表达式有关联的）分析的[完全 β 规约(en-US)](https://en.wikipedia.org/wiki/Evaluation_strategy#Full_β-reduction)，而成为“以辞害意”限制可行表达的一个例子。

