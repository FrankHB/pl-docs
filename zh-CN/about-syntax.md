# 关于语法

## 引言

　　有人说语法很重要。这点我实际上一直不否认，但一定程度上（除了[这篇文章](what-is-syntax.md)）并没有表达过一个整体上为什么有意无意地在语言设计和分析中避免“优化语法设计”这样的工作的理由，所以有必要概括一下观点。

　　因为上下文是编程语言，所以“语法”指的是 syntax ——这在自然语言中是“句法”，但编程语言不存在严格对应的“句”的概念；自然语言意义上的语法则是更一般的文法(grammar) 。

## 重要

　　很多人同意，记号(notation) [影响思想的表达](https://github.com/hypotext/notation)。这种影响可能是积极的，也可能是消极的：合适的记号使表达的成本更低而更具有可行性；糟糕的记号可能会对交流制造意想不到的门槛，并歪曲表达的原意，进而限制思想的可行性。

　　语法提供作为系统化的、有规律可循的记号系统的基本规则。除了少数强调直观而非普遍性的更适合图形等非文字和非符号化表达的场合，语法对人工设计的记号系统的作用是毋庸置疑的：它很重要。考虑到使用频率，语法就像呼吸一样。也因此我不能忍受复杂到在日常使用时需要刻意注意的构造，并且有意远离不得不使用这些构造的场合。要是一个人时不时[潮式呼吸(en-US)](https://en.wikipedia.org/wiki/Cheyne–Stokes_respiration) 的话，那么大概是快要挂了。

## 变化

　　另一方面，既然众口难调是现实，通用目的语言中呈现的最终的语法就应该允许让用户定制。这更容易使之被排除出语义规则之外单独设计——如 Racket 这样的基于传统 Lisp 的 read macro 基础上扩展出来的方案。

　　这样的现实需求也体现语言设计中分离语法和语义规则（而不是铁板一块的混沌文法）的普遍必要性——考虑到应对需求而变更不成熟的语法设计的代价仍然不会小到哪去（未必困难，但对会设计并更感兴趣使用语义解决实际问题的语言设计者来说，不用普遍规则概括的细节几乎总是烦的），只有极端不在意语法的“一次性”的小规模[领域特定语言](https://zh.wikipedia.org/zh-cn/领域特定语言)设计中，才可能漠视这种模式而不造成麻烦。

## 作用

　　现代编程语言的语法设计在语言中起到的作用的机制大同小异。

　　一般来说，除了使用使用“扁平”式的单一[形式文法](https://zh.wikipedia.org/zh-cn/%E5%BD%A2%E5%BC%8F%E6%96%87%E6%B3%95)的设计方式，**现代的编程语言通常采用语法和语义(semantics) 规则分离的设计**。这是因为，形式文法不容易捕获语言设计需要的有目的性的抽象特性，以至于几乎无法合理地表达需要描述含义而不仅仅是操作语法元素的场合：

* 被形式文法描述的对象语言直接被文法的[产生式(en-US)](https://en.wikipedia.org/wiki/Production_%28computer_science%29) 描述，其形式是已经分解成语言的字母表上的固定元素（符号(symbol) ），且产生的新的符号串难以通过产生式的描述**保持**能清楚描述设计者意图暴露给用户使用的特性相关的结构（例如，[作用域](https://zh.wikipedia.org/zh-cn/%E4%BD%9C%E7%94%A8%E5%9F%9F)的内部表示）。
* 同时，虽然[足够强的形式文法](https://zh.wikipedia.org/wiki/%E4%B9%94%E5%A7%86%E6%96%AF%E5%9F%BA%E8%B0%B1%E7%B3%BB)能够允许上下文(context) ，但上下文仅限符号串的表达，无法提供显示设计者和用户目的的抽象含义。

　　因此，除了一些极特殊的场合下的[领域特定语言](https://zh.wikipedia.org/zh-cn/%E9%A2%86%E5%9F%9F%E7%89%B9%E5%AE%9A%E8%AF%AD%E8%A8%80)（如[正则表达式](https://zh.wikipedia.org/zh-cn/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)——它的目的就是为了描述串操作），现代语言的设计通常不使用单一的形式文法指定规则。

　　注意针对这类作为元语言的传统形式文法表达上下文的能力不够强的问题，文法层次上存在[自适应文法(en-US)](https://en.wikipedia.org/wiki/Adaptive_grammar) 这样更复杂的方案。但使用这样的文法进行设计本质上是在扩展习惯上作为领域特定语言的描述文法规则的元语言，有增加复杂性的代价。考虑不同用户定制文法规则的需求差异很可能相当大，定制的部分往往难以复用，在元语言中直接承受所有定制需求带来的复杂性并不是很明智的做法——若有资源应对增加的复杂性，为什么不优先直接考虑目的上一般更通用的对象语言的功能呢？相比之下，仅就语法设计这个特定领域，专用于描述语法的元语言的复杂性就简单得多了（至少比把对象语言揉合在一起的文法设计容易控制）。这个意义上，使用产生式的传统方法仍然可能足够合适的，并且还是通用的事实标准。这样设计的形式文法也叫“语法的文法”(syntactic grammar) 。其中，元语言自身的语法由作者约定，常见的如上下文无关文法的[巴科斯-诺尔范式](https://zh.wikipedia.org/zh-cn/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F)。而语义上的规则因为形式化方法的困难，不被通常的语言设计者掌握而熟练使用；因此，语义规则往往仍使用自然语言描述。（即便使用形式语义，一般也不使用传统的形式文法，而是结合不同的形式语义方法单独设计元语言和对应的变换规则。）

　　分离语法和语义规则也为实现的模块化结构提供了对应基础。实现语法规则的程序称为语法的[分析器](https://zh.wikipedia.org/zh-cn/%E8%AA%9E%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8)。由于描述形式文法中产生式的元语言是规则的，这相对容易被自动生成程序等非手工方式实现（可以基于[分析文法(en-US)](https://en.wikipedia.org/wiki/Formal_grammar#Analytic_grammars)）。与之相对，实现语义规则的剩余部分则一般只能手动编码实现。语法分析器可以生成[分析树](https://zh.wikipedia.org/zh-cn/%E5%88%86%E6%9E%90%E6%A0%91)，并输出[抽象语法树](https://zh.wikipedia.org/zh-cn/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9)作为被语义实现接受的[中间表示(en-US)](https://en.wikipedia.org/wiki/Intermediate_representation) 。

### 反面作用

　　不是所有的语言设计都会严格遵守分离语法和语义规则的设计范例。一个比较明显的例子是 C 语言的 `*` 具有构成声明或二元操作符的歧义。要消除这个歧义，至少需要清楚两侧的标识符是否表示的已声明的类型，而存储已知类型需要的类型环境(typing environment) 是无法直接在传统形式文法中编码的上下文，一个纯粹的语法分析器实现并不支持存储声明的类型这样的功能。另一个例子是，C++ 具有比 C 更多的歧义，乃至不惜反用户直觉地约定 [most vexing parse(en-US)](https://en.wikipedia.org/wiki/Most_vexing_parse) 规则简化相关规则，然而一般的实现仍然需要获取语义分析的信息回溯到语法分析才能消除可能的文法歧义或给出有意义的语法错误。极端地（如涉及模板），C++ 实现可能不得不先生成不同路径的中间表示，通过语义规则判定是否存在唯一一符合语言规则要求的形式的方式来消除歧义。这大大提高了实现和用户理解程序规则的复杂性，不论在设计和实现上都是反模块化的（某种意义上，[C++ 不存在单独的语法](https://github.com/cplusplus/draft/pull/790#issue-76094464)），而除了想当然的“容易理解”（建立在写程序的用户永远不会出现语法错误的假设上），这并没有什么实际好处。因此，**现代的语言多数情况下抛弃了这种不够模块化的设计，且使用[上下文无关文法](https://zh.wikipedia.org/zh-cn/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95)来约束语法规则的设计，可预见地避免语法歧义**。

　　显然并非所有用户都能直接理解此中的缘由。例如，有用户认为表达式语法的操作符[前缀记法](https://zh.wikipedia.org/zh-cn/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95)不如操作符[后缀记法](https://zh.wikipedia.org/zh-cn/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95)，因为计算表达式的值时，前者不如后者构造简单。尽管对普通用户而言似乎无可厚非，这种观点有一些理应明显但并没有被很多人足够考虑的问题：

* 这种观点首先没有分清需求要求的接口设计和实现方式。不论输入的是何种表达式的记法，都可以有不同的实现。
	* 使用具体的内部表示这样的实现细节代替接口直接导致一些操作数编码上的限制，这和之前讨论的形式文法难以编码需求中需要的抽象设施的限制在方法论意义上是类似的。
	* 只有假定朴素的[解释实现](https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8)方式，被断言的性质才可能是符合事实的。
	* 注意到接口并不要求输入的表达式以何种数据结构表示。只要直接用线性表而不是栈的表示，不提普遍的[部分求值(en-US)](https://en.wikipedia.org/wiki/Partial_evaluation) 这样的一般变换，如针对具体已知操作的[内联展开(en-US)](https://en.wikipedia.org/wiki/Inline_expansion) 这样稍微“高级”那么一点点的优化就可以被低成本地实现，而使这个断言失效。
* 事实上，前缀和后缀记法存在一一对应的映射；也很容易实现变换映射使其分析树直接转写成的抽象语法树满足[图同构](https://zh.wikipedia.org/zh-cn/%E5%9B%BE%E5%90%8C%E6%9E%84)。
	* 前缀或后缀的差异，本质是因为抽象语法树使用单一节点序列表示时，从左到右（操作符优先）还是从右到左（操作数优先）的表示的不同。
	* 在处理这样的语法结构时，也只有类似使用类似序列的受限数据结构才可能体现出区别。
* 这种观点隐含了无意义的、实际不应该难以避免的[抽象泄漏](https://zh.wikipedia.org/zh-cn/%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F)：要求用户理解前缀和后缀记法的实现细节（内部表示及其处理方式）。这至少对通用目的语言的用户并没有什么好处，反而（因为上面提及的实现细节的原因）使理解和实际实现有出入。
* 除了一些[计算器](https://zh.wikipedia.org/zh-cn/%E8%AE%A1%E7%AE%97%E5%99%A8)在逻辑上使用后缀表达式的内部表示，更一般的硬件实现普遍不支持上述的解释实现。
	* 主流计算机的[指令集架构](https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B)中，使用被编码的二进制指令，其硬件实现也不需要对操作数给出具体的对应结构。
		* 操作数通常是在指令的二进制表示中的预先设计好的位置中编码的。硬件解码这样的操作数，逻辑上就不需要的会用栈这样的数据结构，用栈也不会使实现更优化，自然没有必要在实际实现中使用。
	* 相反，实际上使用了栈作为指令集架构层次上的接口的 [x87(en-US)](https://en.wikipedia.org/wiki/X87) 浮点协处理器指令集被认为低效，必须实现寻常浮点操作并不要求的栈操作语义正是其中的一个原因。
		* [原设计者考虑的优点](https://stackoverflow.com/a/26447672/2307646)并非基于外部需求且非常依赖具体实现细节。现在的常见的用例中，这些细节并无法有效地体现出实际的好处。
		* 即便配合现代的微架构设计，这种指令集架构上的设计也难以高效地实现和扩展（例如，[不适应平坦的寄存器堆(flat register file)](https://link.springer.com/chapter/10.1007/978-3-540-71270-1_4) 也不便使用[单指令流多数据流](https://zh.wikipedia.org/zh-cn/%E5%8D%95%E6%8C%87%E4%BB%A4%E6%B5%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%B5%81)向量化）。
	* 计算器不仅使用这种内部表示，实际上还指定了和操作顺序相关的交互式操作方式：输入一个操作数或非操作数，应该有什么特定的**即时响应**。
		* 这种**用户界面**上的设计约定反过来使固定的表示成为需求，而从内部表示上升到接口规范。
		* 为了能正确使用计算器满足计算目的，用户需要对这种用户界面的约定进行适应性训练，只是因为表达式的形式简单，成本不高罢了。
		* 然而，这种约定并不能自然地扩展到其它类似的任务中，包括稍微复杂一些的其它数学表达式（如积分运算）。这是因为这种约定**并不是求解“计算表达式的值”的任务的内容**，而是关于“操作特定种类用户界面设计的计算器”这种更依赖具体实现的任务的。当不提供能完成扩展任务的对应计算器时，自然不能适用。
		* 一般地，完成更复杂的表达式计算，输入的是整个表达式，用户不能期望中间步骤的响应。因为实现比上述简单的任务更复杂，设计者不能直观地让用户理解其中的每个操作步骤会具有什么结果作为响应。
* 另外，虽然没有直接关系，用户使用自然语言的[词序(en-US)](https://en.wikipedia.org/wiki/Word_order) 和[书写方向(en-US)](https://en.wikipedia.org/wiki/Writing_system#Directionality) 的习惯对语法表达的处理并不是相同的。这种关联的实际意义可能比考虑这里的解释性能差异更大。

　　语法设计影响的不仅仅是具体程序语言的语法。由于一些语法规则在不同语言都可适用，影响的范围可能非常大，可以包括一大类语言的[范型(paradigm)](https://zh.wikipedia.org/zh-cn/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B)。例如，所谓[指令式编程](https://zh.wikipedia.org/zh-cn/%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%B7%A8%E7%A8%8B)，尽管一开始主要是具体体系结构实现限制下的顺序表达（这广义上也可以视为语言设计，只是起初缺乏严格的形式化）的惯例决定的，其流行在相当大程度上受到顺序风格的语法影响的；这普遍而深刻地影响用户对语义的理解，并进一步导致不少语言设计者之后不加思索地应用这些现有惯例。

* 这里的顺序是指源程序中出现自然的字面顺序(literal order) ；对大多数用户，这就是自上而下和从左到右。
* 顺序风格的语法首先体现在对源程序片段的静态划分。这种语法设计风格往往在一个翻译单元(translation unit) 中的顶层(top-level) 源程序可以指定其语法具有特定的顺序组合的单位，如 C++ 的*声明(declaration)* 和 Fortran 的*语句(statement)* 。在这些顶层的语法构造元素之下，通常具有和顶层规则不同的其它语法构造。
	* 和*表达式(expression)* 通常预期可具有*子表达式(subexpression)* 的普遍可组合语法的设计惯例（来自传统数学）不同，这依赖具体语言的语法规则，并不太容易直观概括，增加了设计的复杂性。
	* 区分顶层和非顶层的构造对通用目的语言而言意义通常并不大，因为实际上会引起不符合这样语法规则的错误的主要原因往往就是用户不够熟悉这样的语法限制，而不是在理解语法构造作用的前提下不慎把特定的语法构造的位置写错了。这通常不如把语法限制改写成语义限制更有效——也往往因为上下文信息更丰富而更易实现。
	* 这样的构造通常具有一些变体，区分“可执行”表示计算的和其它（通常用于表示程序元数据）的构造，如 Fortran 的*可执行语句(executable statment)* 和*非可执行语句(nonexecutable statement)* ，对应 C++ 的*语句(statement)* 和其它声明。另外注意，C 语言的声明即便看上去和 C++ 近似，并不归类为“语句”——这体现了这方面的语法设计的一些模糊性。
* 和“指令式编程”的来源类似，经过长期的演化，“语句”这一代表性概念也不再符合其原始含义和引入的目的。对此可能产生的误解导致一些“以辞害意”的限制语言设计和影响用户交流的风险。
	* 历史上，表达式一直被用于表示取得作为计算结果的值(value) 的语法构造；取得计算结果的过程称为求值(evaluation) 。与此相对，语句被用于表示执行(execute) 具有副作用(side effect) （例如修改系统外部可观察的状态的输入/输出操作）而不是值的构造。
		* 表达式的求值通常蕴含子表达式的求值，但事实上并不是所有子表达式都必须被求值，即非严格(non-strict) 求值。表达式的非严格求值表明作为子表达式的表达式并不总是用于取得计算结果的值而存在。
			* 不被求值的子表达式作为操作数(operand) 在历史上普遍存在并延续至今，如 LISP 的 `QUOTE` 以及指令式语言中也常见的逻辑操作符的所谓[短路(short-circuit) 求值](https://zh.wikipedia.org/zh-cn/%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC)。
			* 一些语言中可能提供利用非严格求值的未求值操作数(unevaluation operand) 取其值以外的元数据的机制，如 C 和 C++ 中的 `sizeof` 操作符。
			* 非严格求值类似的非严格执行也存在于分支指令如 `if` 语句中，但其中的判断通常是会被求值的表达式，而依赖表达式的语法和求值规则。
		* 传统的语句强调“可执行”。但如之前分析的，现代的语言对类似语句这样的构造（至少在顶层）往往允许“非可执行”的扩充，导致这个外延实质上失效了。
		* 表达式和语句的这些语用外延的改变导致语法上目的不再有历史上的原始习惯用途一样的清晰的界限。但是，还是有不少的用户并不了解这些普遍知识，而以是否取得计算结果划分期望的语法构造，这使预期和实际语法设计产生了偏差，造成理解以及和其他用户交流上的困难。
	* 数学习惯上的求值总是纯(pure) 的，即不蕴含产生副作用；但这早已经不是现代主流编程语言及其背后的操作语义模型的固有限制——事实上，因为共享计算状态的这样的实用性上的考虑，第一个被广泛实现高级编程语言 FORTRAN 就不限制求值必须是纯的。
		* 限制纯求值的语言即现在通称[纯函数式(purely functional) 语言](https://zh.wikipedia.org/zh-cn/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B#%E7%B4%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80)，在数十年之后才因为和纯函数式的传统数学模型风格近似及其程序便于被并行化等理由，重新引起广泛注意。
		* 但是，严格排除副作用的语言没有和环境的交互手段，乃至无法取得计算结果，是缺乏可操作性上的意义的；纯函数式的系统只能隔离约定带有副作用的基本操作，其实现才具有可用性。
		* 即便如此，在纯函数式和指令式编程风格对立的背景下，表达具有副作用的基本操作在纯函数语言中并非和原始的“语句”具有相同地位，而往往是派生(derivative) 的。例如，有的纯函数式语言会把它包装为 [do-notation(en-US)](https://en.wikipedia.org/wiki/Monad_%28functional_programming%29#Syntax_Sugar) 这样的表面上近似传统语句的形式。
	* 对不严格符合纯函数式风格的编程语言，由于表达式的求值可能具有副作用，只要语法设计允许在出现语句的位置上出现表达式并丢弃求值结果，则语句并没有必要存在。反过来，若存在语句，也不能排除表达式的必要性。
		* 因为语句通常没有如子表达式一般普遍的“子语句”的递归语法设计的惯例，并不适合类似的设计——如果有，“语句”和“表达式”在语法上就没有什么区别了。并且，这样的语句必须补充不能被丢弃的子表达式的结果，语义上也不符合惯例，并且因为需要重新基于表达式的构造定义“求值”的概念，容易造成理解混乱。
		* 现时的典型的指令式语言中即便需要允许表达递归求值，通常提供的是把表达式包装为“表达式语句”，也并没有试图用语句取代表达式。
	* “语句”这一代表性概念实际只剩下程序片段中其实例出现的自然的字面顺序的这一特点被普遍遵守，而偏离是否取得计算结果相关的原始含义。 这实际上**混淆了语法和求值规则这类语义规则的设计的界限**，导致一些直接的缺陷。
		* 一般地，作为抽象的事件，程序中任意两个子表达式求值的相对顺序和程序片段出现的语法顺序逻辑上无关。限制求值顺序跟随语法顺序需要附加约定，增加语义规则的复杂性。
		* 求值规则的这种设计限制了和语法顺序不一致的表达能力。最显然地，源代码的字面顺序具有确定性，因此这种规则不支持并发求值和调换非确定求值顺序的优化实现。
	* 当前的“语句”的概念除容易引起误会，对语言规则的理解经常也是有害的——用户直觉上容易依赖字面顺序替代求值顺序，乃至对求值这个无法回避的重要的机制完全缺乏了解。这也会影响之后的语言设计者，反过来又容易造成更大的混淆。
		* 习惯以语法顺序代替求值顺序思考的用户，会难以理解区分清晰分辨两者的具有正常设计的语言。
		* 对此习惯的适应可造成有争议的改动，典例如 ISO C++17 采纳的 [P0145R3](https://wg21.link/p0145r3) ，同时引入了以下问题：
			* 使语言表达能力下降（不再允许通过函数参数求值等实现一般意义下的若干表达式之间具有未指定的求值顺序）。
			* 不能彻底混同语法顺序和求值顺序而符合这种习惯（仍存在部分未指定顺序）。
			* 使求值规则大大复杂到一般用户几乎无法准确记忆的程度。
			* 可能导致实现支持这种新特性时出现缺陷（如 G++ 8 在 C++17 模式下不使用 `-fno-strong-eval-order` 时生成的程序仍不符合新增的对 [`new` 表达式中调用分配函数的确定性顺序要求](http://eel.is/c++draft/expr.new#23)）。
* 因此，考虑到语法设计的简单性和避免误会，现代不少语言已经在语法设计上排除了“语句”这样的单独的顺序执行构造，而提供在表达式的基础上确定求值顺序的构造（如 Scheme 的 `begin` ）替代。
	* 即便是顺序的非可执行构造，也严格限定其适用范围，并避免和被求值的表达式并列提及。
		* 而这样的构造往往只是习惯上的变通，仍然并非必要。特别地，通用目的语言本质上不存在需要区分“顶层”这样的语法上下文限制语法构造才可实现的可用性。
		* 在顶层引入类似变量声明的构造，可通过解释为修改隐式的和变量绑定构造关联的上下文（如环境(environment) ）的方式加以支持。这类机制是普遍的语义规则，本身不需要依赖顶层这个特定的语法上下文。
		* 特定目的的区分顶层上下文的限制可以由用户指定利用其它语义规则实现，这仍然不要求这个上下文是关于特定语法的。
	* 以指令式语言入门的用户可能对这样的设计仍有普遍的理解困难，这个事实表明不适当的语法设计的影响可以远远超出具体语言语法的范畴。

## 复杂

　　需要刻意注意的构造通常来自语法规则的复杂性。这种复杂性是抽象的，但并不是很难体现。对设计者以外的用户，最主要负担这种复杂性的场合体现在语法分析(parse) 上——不论是对人还是对机器的实现而言。

　　解析复杂的语法需要更多的上下文切换(context switch) 。用“上下文切换”这种特定机器实现气息浓厚的说法，是因为这不仅是人脑应对复杂性的比喻，而是普遍事实。就是抽象的机器实现，在[抽象机(abstract machine)](http://www.ccs.neu.edu/home/matthias/redex-workshop/wed-aft.html) 操作语义的底层这恰恰是带来无法避免的开销的本质的麻烦之一——如函数调用和 `eval` 操作的 E(environment) 这样的上下文——虽然这仅仅是操作语义（元语言）中的真正的 context（所谓 hole ）的一个实例。

　　当然，机器的实现跟人脑相比通常并不计较运行时的开销，但实际情况当然远远不止例子中的规模，而且多余的开销处处存在。就算机器快到运行时无所谓多余的开销，设计、实现和测试语法分析器(parser) 的普遍代价也不是零。

　　更深层次的复杂来自语法规则自身。过于复杂和特设(ad-hoc) 的规则缺乏泛用性，而使记忆语法规则的效用下降；这反过来削弱了语法的重要性，也制造了冗余：反正记不清楚，为什么去记“不常用”的语法呢？为什么不在遇到“不常用”的语法的时候去查询语法规则呢？这里的问题是，划分“常用”或者“不常用”的语法子集的策略几乎无法避免导致用户体验的下降。实用场景中，判断“常用”和“不常用”的代价无论如何都很难是零，不论是读还是写，都很容易被打断现有的思路来对这些底层的问题进行“中断处理”。这种“优先级反转”损害了用户的普遍利益。早知这样，为什么不考虑简化语法呢？

　　一些设计者漠视语法设计中可能具有的用户体验问题的设计带来的问题，原因可能是：

* 无知：欠缺对使用场景和目的敏感性，也不知道普遍的做法的外延。
* 懒惰：逃避分析需求和方案的合理性。
* 跟风：无原则地认为遵循现有的设计是保险的。
* 盲目：因为种种认知偏差，认为这样的设计在绝对意义上代价不高，用户“应该”乐于接受。

　　有的语法设计，在特定的场景下可能是相对合理的，但在一般意义上具有不必要的复杂。这部分的复杂可能被作为习惯而遗留到其它衍生设计中，而先前的合理性不能发挥作用。这使复杂设计的负面作用更加明显，并且可能会有一些意想不到的副作用。

　　作为日常工具的语法需要有效，因此解析技术的复杂在工程上只能是妥协，而非适合通过复杂度来展现意义的话题。一旦复杂，那么已经说明某种失败。而以实现技术本身以外的进展在更大的背景（例如某个具体项目，或者作为评判某个语言设计话题的依据）下用复杂的分析器炫技，其理由比上面的分析或许更简单——多是无知（不知轻重）或无耻（有意搅混水）至少其一的行径。

### 关于上下文的例子

　　举例来说，解析 `1 + 2 + 3` 这样的表达式，不管按哪个方向扫描输入的字符，遇到不同的记号(token) 时总需要至少切换一次上下文并记忆状态；相比之下，用 `(+ 1 2 3)` 这样的同义表达式，在减小记号数量同时减少上下文切换数量上的效果高下立判。

### 关于历史遗留问题的例子

　　C 语言的中缀声明符(declarator) 语法，和二元操作符(operator) 表达式的中缀语法类似，在技术上都具有减小源代码长度的优势。而要保证能正确表达和分析这样的语法实际上是相当复杂的：

* 语言规范中的形式语法具有两套略相关但技术上没法合理去重的形式：声明符和抽象声明符。
* 几乎只能根据语言规范中的形式文法匹配而没有能够保证正确性的变通优化的替代规则。
	* 对机器来讲这似乎不是太大的问题，但对人来讲这是灾难性的：这些语法规则几乎不会被用户记住，于是在声明复杂到无法用直觉判定时，用户只能借助于看似靠谱但其实不能保证万全的“经验规则”，例如[通称为“右左法则”的经验分析方法](https://docs.microsoft.com/en-us/cpp/c-language/interpreting-more-complex-declarators?view=vs-2019)。
		* 这不能正确分析被声明的标识符不明确的情形，例如函数声明的声明符中同时具有作为参数名标识符时。
		* 人类读者产生可分析的错觉的主要原因是，看到一个复杂的 C 声明时，读者倾向于首先认知这是单独的一个声明，且能根据已知的上下文语义信息确定哪个标识符是当前尚未声明的。
		* 但在严格意义上，上述简化假设是不能保证的：一个声明可能包含多个声明符；一个声明符中可能具有多个标识符，且不能在仅知声明而不提供上下文信息时，通过“右左法则”准确判定哪个标识符应被声明。
		* 对此的一个变通是，如有可能，避免使用复杂的声明，而使用 `typedef` 等同义形式代替。然而，用户实际上并没法保证这一点，在权威来源中也可能存在足够复杂形式的声明（例如， ISO C 的 库函数 `signal` 的原型）。这也是上述经验规则的流行的一个原因。
* 讽刺的是，显然今天绝大多数的 C 语言用户已经不再利用这里的技术优势。
	* 例如，几乎所有代码规范都会约定，声明符的记号之间应插入空白符（以提升可读性）。
* 一个历史副作用是，声明符中的 `ptr-declarator`（也就是包含参与到决定类型名中的 `*` 的声明符）无谓地制造了代码风格的分歧：到底是 `T* p`、`T *p` 还是 `T * p` ？
	* 从一个 `ptr-declarator` 对应一个被声明的标识符，而一个声明可包含多个 `ptr-declarator` （如 `T *p, *q, r;`）的角度看，似乎 `T* p` 是合理的。
		* 但事实上这不适用于函数的形式参数的声明。若要正确反映此处声明的语义，在函数参数列表中应该使用 `T* p` 。若已经在其它场合使用了 `T* p` 以外的声明方式，为避免损害一致性，在函数参数声明中对应使用 `T *p` 的风格仍然很常见。
		* 这在早期的 K&R 声明语法中不是问题，因为早期的函数声明根本不支持在参数列表内部声明参数类型的语法。然而，新的语法是 ANSI C 鼓励的原型声明方式，也是现在主流的用法。如 C++ 等借用 C 语言的设计的语法，即便继承了声明符语法（以及这里风格分歧）的传统，也不支持 K&R C 风格的声明，因此必须面对这个问题。
	* 相比之下，统一为 `T* p` 看起来是个更务实和容易在不同用户之间贯彻一致性的做法。分离 `T*` 这样的类型名一般具有更好的可读性，尤其对兼容这样的语法但针对类型名的操作可能更频繁的 C++ 这样的语言来讲。不过由于语言仍然支持 `T *p, *q, r;` 的声明，这还是一定程度上依赖自觉。
	* 除此之外，实际上还有 `*` 和其它行声明对齐的风格。不过这种风格是特定目的下的局部风格，一般用意比较容易辨认而不至于引起误会，所以问题相对较小。
* 这样的设计遗留到了其它语言中。
	* 最广为人知的例子可能是 C++ 。进一步地，C++ 扩充了声明符中的 `ptr-declarator` 的记号 `*` ，允许 `&` 和 `&&` （单从这里的设计体现一致性倒是无可厚非）。类似的扩展还有 C++/CLI 的 `^` 。
	* 即便 Java 没有 `ptr-declarator` 的对应物，在数组的声明语法中还是采用了类似的做法。
	* C# 相比 Java 放弃了中缀的写法，即便 C# 重新引入了指针而需要有 `*` ：声明的语义上保证了 `*` 和类型名前缀的结合，而不支持一个前缀对应多个 `ptr-declarator` 。如需在同一个声明中引入多个标识符的声明，则需要重复 `*` 。这也基本消除了上述代码风格的争议，但在对习惯与之不兼容的 C/C++ 语言语法的用户来讲，仍有误用风险。

　　不限于中缀风格的声明符语法，一般的中缀操作符的表达式语法也带来了一些限制。除了和中缀声明符语法（以及刻意引入 `++i` 和 `i++` 这样微妙的设计）同样损失了原始的节约源代码长度的技术优势外，中缀操作作为表达式语法还限制了表达能力，并因为复杂的优先级和结合性的语法规则的特征，制造用户记忆上的负担：

* 二元操作的语法不能直接自然过渡到函数调用，不同的语法导致为了看起来普遍自然，可能需要添加“操作符重载”的设计。如果一开始就没有特设的二元操作，那么根本不需要有这些复杂性同时仍能不损失相同语法代表的操作的普遍性。
* 四则运算以及 `%` 或许容易被多数初学者接受和掌握，但大部分即便在工业界“熟练”掌握 C 语言的用户并不足以让业界信任准确掌握了 `<<` 以及 `&` 等操作符和这些运算混用的情形，以至于甚至实现都需要警告加上括号。
* 类似 C 语言这样具有“丰富”的（二元甚至更多元）操作符的现有设计似乎使某些设计者产生了对用户接受扩充中缀语法的盲目乐观，乃至认为中等教育程度的用户应当能像接受四则运算一样容易接受各种不同的中缀语法。
	* 然而“定义新运算”的语法实践实际上普遍不属于学历教育中的必修内容（尽管可能出现在所谓“奥林匹克数学”的教学中），所以至少对初学者，门槛是普遍存在的。
	* 即便是对有经验的用户，不同语言之间可能存在的微妙的差异带来的成本也不是零，唯一能普遍可行的方法似乎就是忘记特设的优先级和结合性规则，不确定时就加上括号——然而这样为什么不直接用函数代替特设语法的操作符呢？

### 应对

　　语法设计的不必要的复杂性应根本地从设计上寻找原因并试图克服来解决：明确引起语法规则复杂的需求来源，合理地把一些语法上不合适处理的规则转移到更普遍的语义规则中处理。然而遗憾的是，大多数设计者并不能彻底分析复杂性的来源；不少通用目的语言的设计者欠缺识别需求通用性并拒绝其中不合理部分的能力。对这些作者来说，他们可能会使用其它措施来变通而不是解决问题。这样的变通无法深入语法规则自身，所以往往着眼于用户的语用体验。

　　一种在语用复杂性上的通用的变通措施是[语法糖(syntax sugar)](https://zh.wikipedia.org/zh-cn/%E8%AF%AD%E6%B3%95%E7%B3%96) ，即提供特设(ad-hoc) 的语法来替代其它语法的语用。这在迭代语法设计的不同版本时保持兼容性（以及掩盖旧的语法设计的失误）的场合往往很有效；也可以用来模拟不同范型的惯用法——例如纯函数式语言模拟指令式顺序风格的 do-notation 。但是，语法糖不可能根本地解决语法设计过于复杂的问题；相反，还很容易加剧复杂性：

* 按定义，语法糖提供的语法是已经在源语言中支持的语法的同义表达，因此语法糖实质上依赖被包装的其它原始语法，去掉后者就不是语法糖了。考虑语法规则的通常表达形式几乎不可能被复用，对设计者来说提供两种语法总是比提供一种语法需要更多的工作。
* 对用户而言，记忆清楚两种语法规则同样需要投入更多的精力；即便用户总是预期不打算记忆非语法糖形式的原始语法，语义的理解也必须依赖原始语法，实际上很难保证这就起到了简化。
	* 语法糖只能起到简化用户已经熟知语义时的特定的一些语用场景。然而，对通用目的语言，对特定的场景“优化”的这种设计很容易流于过度设计，并没有解决问题。
* 更麻烦的问题是，用户并不总是能熟悉近似语法对应的精确含义时，随意替代同义语法的习惯很容易进一步混淆用户对语法和语义分别解决的问题的范畴的混淆。有时候，还会出现实际上不是语法糖而被误认为语法糖的情况。
	* 一个典型例子：不少指令式语言新加入 lambda 表达式实现“匿名函数”，被用户误认为是具名过程（函数）的语法糖。这不一定成立，而且通常不应该成立。
		* 使用同义语法的替代并不保证精确地等义，这种情形下的匿名函数就不可能通过语法糖得到。例如，C++ 的求值得到闭包对象(closure object) 的 *lambda-expression* 就不能作为其它特性（如函数对象）语法糖，因为并没有其它语法支持等价地表达闭包对象的未指定属性（如捕获变量被存储在闭包中的布局的显式未指定(unspecified) 的初始化顺序）。（此外，因为重载等原因，C++ 的 *lambda-expression* 在功能上也不能替换传统的函数，这体现语义设计也具有冗余。）
		* 语义上匿名函数本来就比这些语言中具名函数更基本。通用目的语言中的具名函数本应设计为指称匿名函数的变量（若要拒绝修改函数，可以限制为拒绝修改匿名函数的绑定）；但由于种种历史原因，具名函数和变量指称的实体（“对象”）往往被区别对待。这些原因基本没有普遍的合理性：诸如“函数不是对象，因为它不提供确定的可访问的存储”这样的理由，相比使用名称指称实体而实现变量支持的普遍机制来讲，是更低层次的实现细节；把这样的设计提升为特设的规则的动机并不充分。

　　另一种和语法糖相对的做法称为[语法盐(syntactic salt)](https://zh.wikipedia.org/zh-cn/%E8%AF%AD%E6%B3%95%E7%9B%90) ，是指在语法规则中要求用户冗余表达的设计方式。和语法糖不同，语法盐以语用上的复杂性为代价减少非预期的代码错误，即语用复杂性总是会相对不要求冗余的对应语法更大；此外，语法盐要求的冗余可以是语法规则内部体现的，并不严格要求替换其它同义语法。和语法糖类似，语法盐在语法设计演进中也容易起到作用。若语法盐不排除被替代的易错的同义语法，则和语法糖一样会加剧语法设计的复杂性，同时其作用依赖用户的自觉。否则，冗余的合理性依赖和语义规则的交互作用。因此，语法盐也不是普遍可靠的在语法设计上消除复杂性的做法。不过，某些情况下合适的语法盐能区分原本不够明确的不同语义功能而简化具体情形的语义设计——例如 C++ 的显式转换代替 C 风格显式转换，排除 C 没有对应的部分的具体转换的规则反而更简单（虽然保留后者使之在某些情况处理为前者的语法糖使转换规则整体上仍然更复杂了）。

## 意义

　　语法设计的复杂，除了导致上述的复杂处理的表面问题外，还隐藏了更一般的麻烦问题：损失普遍性，并妨碍抽象的目的。

### 计算目的

　　对（因为不方便使用而）不适用 [AOT 编译(en-US)](https://en.wikipedia.org/wiki/Ahead-of-time_compilation) 的场合——包括人脑——解析语法的工作构成了求值算法(evaluation algorithm) 的算法复杂性的基础，也构成了计算性上的(computational) ——即为了通过操作语义规则得到计算结果的——需要克服的复杂性的基础。因此复杂的语法和语义一样会直接影响实现计算目的的效率。如果解析语法不是直觉上特别有目的的行为，语法不应该承担比语义更显著的角色。

　　一个语法上起到重要作用的构造的例子是[结合律](https://zh.wikipedia.org/zh-cn/结合律)。结合律用中缀风格的语法来表达时显得简洁易记，但使用前缀或后缀的写法就比较晦涩了。这说明中缀语法的优越吗？不，普遍来看恰恰相反，一般的计算中非二元操作远远多于（主要是作为某些构造性实现的）二元操作，因此结合律实际上并不应具有计算上的普遍作用。习惯性滥用结合律是一个“以辞害意”的例子。

### 本质问题

　　强调并不自觉依赖结合律这样的语法风格，在语法以外的一个直接原因是“二元操作中心主义”。这体现在二元操作的原生特殊支持——而扩展二元操作往往用 [fold(en-US)](https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29) 实现。但是，若要反方向归纳到二元以下的操作上，又需要有特殊的规则。这和 Lisp 风格用 `(+)` 、 `(+ 1)` 、 `(+ 1 1)` ……这样的序列通吃任意有限参数个数的操作而归纳出一致性相比，显得并不自然。

　　当然，以二元操作中心的方法论用于抽象目的上并非全然是无效的。得益于[数学归纳法](https://zh.wikipedia.org/zh-cn/数学归纳法)和[递归](https://zh.wikipedia.org/zh-cn/递归)的表达形式，像 [cons pair](https://en.wikipedia.org/wiki/Cons) 这样的还原主义方法就体现出了单一的二元操作(cons) 的简洁而普遍的威力。

　　但是，体现这种适用性的目的是*建模(modeling)* ——为了得到抽象的描述和理解对象本身的构造。一旦目的改为通过变换不同粒度的对象以解决一般的问题——*计算(computing)* ，其最明显的劣势就体现来了：直接使用二元操作解构运算的步骤来替代计算上的操作，会有复杂度上的困难。造成这种困难的原因是，要解决的问题通常并不在乎二元操作这种具体的实现细节，而二元操作隐含的归纳法本质依赖的局域性可能就只能作为可选的实现细节才不至于阻碍问题的解决。实际是否形成阻碍，取决于算法是否仅依赖局域特性。例如，当对一个序列(sequence) 进行搜索时，元素访问操作是局域的，而比较操作是不限制局域性的，因此使用 cons pair 这样的方式来表达序列的构造并不阻碍只依赖局域操作的最基本的顺序迭代算法；但这样的构造并不能利用超出相邻元素的局域的性质——当这个序列全局有序时，使用 cons pair 的构造无法利用全局性而不能直接支持[降低计算复杂度的有效算法](https://zh.wikipedia.org/zh-cn/二分搜索算法)。再如，cons pair 的实现方式蕴含了序列中非预期存在的构造顺序这一细节，而暴露了构造、访问和析构操作可能的和顺序相关的[副作用](https://zh.wikipedia.org/zh-cn/函数副作用)，使结构上的实现细节（非预期地）泄漏到普遍行为上，阻碍[信息隐藏(en-US)](https://en.wikipedia.org/wiki/Information_hiding) 和抽象目的的准确表达。

　　另一个次要的困难是，表达本身在计算上的冗余——罗嗦。有时候，这种罗嗦还可能“传染”到使用这些表达的问题的解中，使解的形式并不够具有预期的良好性质。要使解能符合原始目的，还需要一个附加的变换把解的形式修改回看上去更“正常”的形式。实际上，这时候被直接解的问题并不是原始问题。通过变换问题的形式使问题可解是个很实用的重要思路，但是在问题本来就并非难以解决时，这种多此一举就是一种过度设计，显然是有害的。

　　上述问题共同导致许多常用的抽象脱离使用二元操作构造表示的模型而存在独立的意义。不少时候，通过二元操作或其它还原论方法构造的模型仅仅起到模型论意义上的作用——例如，大多数时候人们不使用[集合论编码](https://zh.wikipedia.org/zh-cn/自然数的集合论定义)来表示自然数，即便是不使用加法之类套用模型会有算法复杂度问题的场合。

### 其它妨碍

　　在具体使用中，过度依赖二元操作或更特定的操作语法代替更直接自然的形式的局部设计，会以更复杂和看似偶然的方式嵌入到整体设计中，影响语言用户对问题和解决问题的方法的理解。这些影响的广泛性和深刻性可能并不小于上面的本质问题造成的负面影响。这些影响至少包括：

* 这种习惯倾向在语言设计中引入特设的(ad-hoc) 欠缺可扩展性的特性。其中，最直接的典型是[操作符重载(en-US)](https://en.wikipedia.org/wiki/Operator_overloading) 。
	* 因为语法上有限的操作符（通常其优先级和结合性还被写死了）通常有受限的内置的语义，不足以表示一些近似的语法形式，保留语法而替换具体语义的“重载”被发明以解决这样的问题。
	* 作为一个直接结果，这使语言的语义规则更加复杂。
		* 和通用的其它设计结合，这直接制造了更多需要解决的问题（例如，如何解析操作符找到非内建处理操作符的逻辑，使之能和词法作用域(lexical scoping) 、名称解析(name resolution) 等一般机制相容）。
		* 当然，无视复杂性的代价，这确实是可解决的，而且大部分复杂性普通用户经过训练后可以无视——所以也的确被作为 C++ 等一些现实语言的特性和“优点”。
	* 但是反过来，为什么不直接使操作符和“函数”一样共享语法而根本不需要引入这些特设的规则呢？
		* 即便非要适应特定领域用户对语法习惯，也完全可以局部地作为语法糖来设计，而不需要引入成套的复杂规则。
		* 现实中，不得已引入特设的复杂的规则，一个可能的原因是在此之前因为语言欠缺通用的语法扩展能力（如[卫生宏(en-US)](https://en.wikipedia.org/wiki/Hygienic_macro)）而无法可靠地把这样的特性作为语法糖，不过这就是另一个话题了。
	* 注意操作符重载是一种[特设多态(en-US)](https://en.wikipedia.org/wiki/Ad_hoc_polymorphism)，因此也自然具有特设多态带来的实用性问题，例如滥用（过度依赖领域知识）导致难以理解。不过这和语言的语法设计没有直接关系（因为造成的问题多少取决于用户如何使用这项特性），应与以上问题区分。
* 传统数学教育不够区分操作符关联的[操作顺序(en-US)](https://en.wikipedia.org/wiki/Order_of_operations)而使用户容易存在一些关于“计算”本质上的认知偏差。从经验上看，这种实际偏差被某些语言设计的问题放大了，且已经造成了用户学习和使用的困难，乃至因此在产品中制造了更多的缺陷。**随意、粗放而欠缺一致性的特设的语法规则加剧了这种现象。**
	* 因为传统数学中表达计算的系统本质上是[纯函数式](https://en.wikipedia.org/wiki/Purely_functional_programming)的，在子表达式中使用操作数进行计算的不同局部顺序并不会影响表达式整体的计算结果，所以新手往往不会注意到迁移到更有表达力的可能有[副作用(en-US)](https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29) 的系统中，忽略顺序导致的后果和导致这些后果的直接原因。继续这种思路进行语言的教学，会使用户容易陷入误区，事半功倍。
		* 用户被迫使用和数学教育过程中习得的相当不同的思维理解编程系统才能使编写的程序大体符合预期，而错失探究不同语言之间在数学上的存在的一些普遍联系的机会。特别地，在[重写系统](https://en.wikipedia.org/wiki/Rewrite_system)这样的模型中，行为看似不同的系统实际上是统一的。
			* 例如，上述局部顺序不影响计算结果的一般性质，在重写系统的意义下称为[汇聚性(en-US)](https://en.wikipedia.org/wiki/Confluence_%28abstract_rewriting%29) 。
			* 再如，传统的数学表达式作为重写系统具有[强规范化性质](https://zh.wikipedia.org/zh-cn/%E8%A7%84%E8%8C%83%E5%8C%96%E6%80%A7%E8%B4%A8)，保证有限的表达式的计算总是能经过有限计算步骤后终止，而一般的程序并不一定有这样的保证——实际上，[非终止性(en-US)](https://en.wikipedia.org/wiki/Nonterminating) 可以建模为一种副作用；此外，[图灵完备(en-US)](https://en.wikipedia.org/wiki/Turing_completeness) 的系统必须允许构造不终止的程序。
			* 若用户只使用总是汇聚和具有强规范性的这些**缺乏普遍性的特例**，反而不容易觉察和理解这些性质，且很可能进而**影响对通用目的语言能实现的特性的想象和理解**。
		* 用户同时错失对[求值策略(en-US)](https://en.wikipedia.org/wiki/Evaluation_strategy) 进行认识的机会，而进一步**妨碍对计算的本质特征和典型的语言如何实现计算的一般机制的理解**。
	* 因为对顺序问题理解上的含糊，使用表达式求值可能有副作用的语言，用户往往有更大的机会犯错，并且甚至在试图解释时继续犯错而自以为是地认为理解了。一个经典的例子是 C 语言的 `printf("%d %d %d", i++, i++, i++)` 这类存在[未定义行为](https://zh.wikipedia.org/wiki/未定义行为)的表达式求值的解释。
		* 抛开表述未定义行为的语言规则对表达式的求值顺序(order of evaluation) 的概念具有的依赖，混淆从左往右的语法分析顺序（同时应该也是大多数用户会习惯的“自然”的阅读顺序）和求值顺序甚至附会到某些实现的[调用约定](https://zh.wikipedia.org/wiki/调用约定)中作为函数参数的子表达式求值结果的传递顺序这**三种不同顺序**的问题，使用户对程序语义（而不是行为）的理解可能南辕北辙。
		* 未定义行为本身的性质使用户进一步原则上不可能推测出程序能具有的“正确”的可预期行为。
	* 即便抛开顺序本身的含义，使用 [PEMDAS(en-US)](https://en.wikipedia.org/wiki/Order_of_operations#Mnemonics) 这样的助记符灌输个别的教条形成的刻板印象也容易使用户适应新的优先级和结合律等规则更加困难。最直接的，用户需要一定程度上在 PEMDAS 以外的操作符的表达式付出记忆附加的求值规则的成本。
	* **中缀中心主义的风格以一种不容易被注意到的方式大大加深了类似的潜意识性的影响**，使用户更难判断语言设计的合理性。不少这样的语言（虽然不止是这样的语言）会以支持大量的操作符（以及对应表达式的特设的求值规则）来体现“功能丰富”，这客观上加强了用户理解具体操作规则的要求，而**竞争性地弱化了对表达计算的一般机制的理解的要求**。实际上，这样的设计因为之前提及的附加的规则记忆成本等问题而放大了这类设计的局限；但种种原因下，某些语言设计者和用户仍然陷入了斯德哥尔摩综合症的怪圈（认为中缀是“大众”意义上更合理的，全然不知晓或理会因果上的先来后到）。
	* 同时，没受到这些思维定势和怪圈影响的用户通常并不怎么关心这里的问题，或者认为问题不大，结果导致市面上的语言更倾向于不在乎这些问题的设计。久而久之，工程选型的范围也受到限制，在这方面上就整体“劣币驱逐良币”了。

### 一转攻势

　　着力于在两个现有数学体系之间建立联系（通过[态射](https://zh.wikipedia.org/wiki/态射)）的[范畴论](https://zh.wikipedia.org/zh-cn/范畴论)本来并没有太多的槽点，不过其中一些不良语法习惯被某些语言奉为“函数式”正统设计以至于把一些用户迷得神魂颠倒就颇有些奇怪了。

　　讽刺的是，在这个背景下的最基础的[复合](https://ncatlab.org/nlab/show/composition)，传统语法也有[歧义](https://ncatlab.org/nlab/show/composition#Notation)，以至于要强调所谓的 diagrammic order 。注意作为结合律的适用的典例，复合操作具有上面提及的所有问题。强调 diagram 这种先天被局域作用限制的语法已经在一定程度上误导了局部结构的在一般问题的解中所占的比重，乃至歪曲了表达解时本应注意到的抽象甚至目的。

## 解决

　　避免麻烦的语法和相关问题的大部分套路并不难：

* 除非必要，避免新造 DSL 。
  * 使用成熟的设计。
  * 使用通用目的语言构造 DSL ，而不是从头造轮子。
* 避免没有明确目的的中缀语法等过度依赖局部结构的设计。
  * 尤其避免设计生造的新的中缀语法。
  * 使用类似 `x . y . z` 到 `. x y z` 这样的变换消除一般情形中对结合律等局部特异性质的不当依赖。

　　不过，不擅于独立思考以及观念上先入为主的偏见容易导致难以实践本应简单的套路。这可能是相当难以纠正的。原因的一部分可以归因于理解上的困难，这来自经验和想象力的匮乏。

　　例如，就二元操作语法，有观点认为：函数调用表达式中，作为操作符的函数和操作数(operand) 的语法组合仍然是中缀的；即 `f x y` 实际上是 `f call x y` 或者更明显的 `(f) call (x y)` ，其中 `call` 是原本隐含的中缀操作符。这从实用上看似自然，实际却隐含了使用关于“调用”的求值策略的并不见得那么自然的前提：操作符和操作数作为表达式的求值保持相对独立，例如 [WHNF(en-US)](https://en.wikipedia.org/wiki/Lambda_calculus_definition#Weak_head_normal_form) 。作为后果，这种刻板印象排除了一些非决定性的其它优化求值策略，如允许在求值前对操作符内部结构进行（可能和操作数表达式有关联的）分析的[完全 β 规约(en-US)](https://en.wikipedia.org/wiki/Evaluation_strategy#Full_β-reduction)，而成为“以辞害意”限制可行表达的一个例子。

