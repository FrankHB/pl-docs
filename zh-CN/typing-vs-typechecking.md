# 类型 vs. 类型检查

# 引言

　　这篇文章是一些经常复用的常识科普的总结。

　　经问题太多，不得不绕过其它地方直接在这里填坑。

　　虽然对于内行可能很多废话，但是仍然建议自上而下阅读（发现有梗请按字面意思理解）。

　　阅读之前的另一个建议：姑且不要盲信某些问答或百科网站的观点，待足够了解相关话题后自行评估自洽性。

# 本体论(Ontology)

　　先问是什么，再问为什么。

　　不自觉地忽视“类型是什么”这个问题是造成乱象的根源之一，所以有必要首先澄清——尽管内容或许会（很遗憾地）出乎很多读者的意料。

## 概述

　　高屋建瓴：类型是一种抽象的实体(entity) 。嗯，等于没说。

　　当然其实是说了些什么的。熟悉 C++ 基本概念（字面意思，语源是 [ISO/IEC 14882 Clause 6<s>以前是3</s>](http://www.eel.is/c++draft/#basic) 的标题）知道，至少类型不是**名称**，是被指称而不是指称别的什么玩意儿的——在几乎所有语言和习惯用法中都一致。

　　不过现实中的问题<s>破事</s>当然不那么简单。

## 类型 = 分类？

　　当然不是。

　　在说为什么不是之前，首先需要正视这是一个有些年头了的笑话，并且可能具有名人效应而带坏一些不明真相的小碰友，典型地如[这篇](https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html)。在一口一个类型系统(type system) 如何如何时，不觉犯了基本的没搞清概念的内涵的低级错误，以至于把名义类型系统([nominal type system](https://en.wikipedia.org/wiki/Nominal_type_system)) 和类型系统混为一谈。鉴于[LtU 上的评论已经足够一针见血](http://lambda-the-ultimate.org/node/4554#comment-71474)，不在此多科普细节。

　　讽刺的是，造成这种误会的原因，恐怕就是原文批判的：类型系统烂设计过于有存在感——而影响了作者本应具有的视野。这样，应予以重视的教训除了“不要在不懂的领域跑火车”外，更要紧的是得先搞清楚要批判的东西到底是什么玩意儿，而不是一上来就想造个大煋闻，批判一番了事——不仅削弱本来可能性以微粒子程度存在的观点的合理性还误导群众，而且容易贻笑大方。

　　再给一个例子，如 C++ 里的 `std::input_iterator_tag` 这样的 tag type ，提出的目的显然不是为了对现有对象“分类”，因为被“分类”的对象都是先前毫无意义，只是通过这个类型才确定的，而且具有这样类型的值只可能有一种完全等价的构造方式。这就是所谓的 [unit type](https://en.wikipedia.org/wiki/Unit_type) 的实例，利用 C++ 名义类型系统“制造”保证和其它类型不*等价* 的自定义类型，来区分上下文——比如说，这里主要用于区分重载。（当然， C++ 的类型系统比较弱，一个随便什么多态类型都要单独约定语法和[等价](http://eel.is/c++draft/temp.type) ，而什么 [concept](https://en.cppreference.com/w/cpp/language/constraints) 之类一定程度上本来也是类型的玩意儿愣是不当作类型于是又多了不少破事乃至[扯](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0225r0.html)[皮](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0240r0.html)——但那是特定于语言设计的问题。）

## 那么一个类型“到底是什么玩意儿”？

　　还是先不用急。这一节的重点是理解[“到底什么玩意儿”](https://zh.wikipedia.org/zh-cn/%E6%9C%AC%E4%BD%93%E8%AE%BA_%28%E5%93%B2%E5%AD%A6%29)这个说法。

　　其实这是一个哲<s>♂</s>学问题，确切地说是一个形而上学问题（不管对这个领域清楚不清楚，请忘记黑格尔的私货，总之这里的意思和辩证法没一腿）。

　　这类统称[本体论](https://zh.wikipedia.org/zh-cn/%E6%9C%AC%E4%BD%93%E8%AE%BA_%28%E5%93%B2%E5%AD%A6%29)问题的重点就是“是什么”。接下来，有意思的是，要指望谁来回答这个问题？对于一般形式来讲，的确可能只能哲学到底了，但对于**某个类型系统中的类型**——这种**人为设计**中的一份子，其实答案是很明显的：类型系统的设计者或者类型的设计者（类型系统的用户）说“我就是想要让它**叫**那个啥”，如是而已。

　　比较无奈的是，很多钦定类型“**是**什么”者自己就对这层含义并不怎么清楚，似乎自以为是天赋人权了。

　　这个之后再提。先看一下祖宗长什么样再说吧。

## 历史上的“类型”是什么玩意儿

　　这段历史常识可能很多童鞋不知道，虽然真要追根溯源可能倒未必出很多人意料。

　　讨论当代程序设计语言使用的“类型”的直系高祖——其实本质上就是个哲学（数学）范畴的问题，因为“类型”是为了解决[第三次数学危机（罗素悖论）](https://zh.wikipedia.org/zh-cn/%E7%BD%97%E7%B4%A0%E6%82%96%E8%AE%BA)搞出来的副产品——[类型论](https://zh.wikipedia.org/zh-cn/%E7%B1%BB%E5%9E%8B%E8%AE%BA)的研究对象。

　　按照罗素本人的一些努力构造的解法之一是创造一个[公理系统](https://zh.wikipedia.org/zh-cn/%E7%BD%97%E7%B4%A0%E5%85%AC%E7%90%86%E4%BD%93%E7%B3%BB)——请注意其中的“[类(class)](https://zh.wikipedia.org/zh-cn/%E7%B1%BB_%28%E6%95%B0%E5%AD%A6%29)”和“面向对象”等并没有毛线关系（要是习惯望文生义可能就像上面提的搞不清什么是类型的那位一样中招了）。虽然作为事后诸葛亮，主流数学到现在也并不吃这套（而改用 [ZF(C)](https://zh.wikipedia.org/zh-cn/%E7%AD%96%E6%A2%85%E6%B4%9B-%E5%BC%97%E5%85%B0%E5%85%8B%E5%B0%94%E9%9B%86%E5%90%88%E8%AE%BA) ），但还是不妨提一些存在间接的深刻影响，特别是“类”的概念——比如 [NBG](https://zh.wikipedia.org/zh-cn/%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC-%E5%8D%9A%E5%86%85%E6%96%AF-%E5%93%A5%E5%BE%B7%E5%B0%94%E9%9B%86%E5%90%88%E8%AE%BA)（嗯不是某一心一教……）以及[“一般化的抽象废话”](https://zh.wikipedia.org/zh-cn/%E8%8C%83%E7%95%B4%E8%AE%BA)涉及的一些[重要基础](https://zh.wikipedia.org/zh-cn/%E9%9B%86%E5%90%88%E8%8C%83%E7%95%B4)（虽然这块东西即便是 Haskell 厨也并不方便抡圆了用）。

## 意义何在？

　　那么这些历史与上面有什么关系呢？嘛，至少对名义上的本体论意义，其实就是——**毫无关系**。

　　且不提当年的副产品[发展到现在](https://zh.wikipedia.org/zh-cn/%E5%90%8C%E4%BC%A6%E7%B1%BB%E5%9E%8B%E8%AE%BA)还在兴风作浪要顶掉集合论篡数学基础的大位，就是仅在程序语言理论中，它仍然是王道正统的几乎不二的形式基础。但是，纵观古今，我愣是没发现有一个类型论在一般意义上来指导用户**应该或必须把（具有类型论以外性质的）什么东西抽象成什么类型**。也就是说，**本体论意义的“类型”，根本就没有指导类型系统设计一般的数理逻辑理论支持，更不用提强调本体论意义的必要性了**。具体地，各种类型论中，并没有要求“类型”如同所谓面向对象的类一样，成为和某种领域外实体的对应，以作为**建模**或“分类”的基础，而仅仅是（[重写](https://zh.wikipedia.org/zh-cn/%E9%87%8D%E5%86%99%E9%80%BB%E8%BE%91#%E4%B8%8E%E9%A1%B9%E9%87%8D%E5%86%99%E7%B3%BB%E7%BB%9F)意义上的）项(term) 上关联的一些抽象实体罢了。（像 C++ 的 tag dispatching 之类的所谓奇技淫巧，反倒更符合“类型”在这里的原意—— term 上的 tag ——虽然语言规则使之具有的性质并不怎么方便用。）

　　某些人使用语言时没人限制该干啥，仗着指哪打哪、**叫**啥**是**啥可以作为天赋人权来用（看起来像是鸭子类型么……），强制让一个类型和一个不符合（类型系统蕴含的）一般性质的本体对应还想甩锅给类型系统的设计？这甩锅路线也太烂了……

　　从这里更加可以看出之前的例子为什么是笑话。强要加给“类型”以含义的，明明是**没怎么搞清需求**以及很可能**对类型系统如何在编码时起作用一窍不通**的用户，而并不来源于类型系统自身的设计。反过来，符合这些上梁不正的需求的类型系统“设计”，倒极可能带来更高渣设计的语用风险——比如说，解决一类明明在设计目标领域内的（其它语言容易做到的）问题怎么用都麻烦，让用户怀疑人生之类……

## 形式主义的认知偏差

　　先前提到，“类型”是类型论研究的对象。在形式系统之内，这种对象最初被认为表示论域([domain of discourse](https://en.wikipedia.org/wiki/Domain_of_discourse)) 。不巧的是，随着时间的推移，越来越复杂的类型轮被构造，类型的预期语用发生了很大的变化，乃至名存实亡——用户不再（或因为过于复杂而无法）关心某一个项具有的类型代表是何种被讨论的对象集合，而只在乎“是什么类型”这种形式判断。

　　历史上，[Curry-Howard 对应](https://zh.wikipedia.org/zh-cn/%E6%9F%AF%E9%87%8C-%E9%9C%8D%E5%8D%8E%E5%BE%B7%E5%90%8C%E6%9E%84)指出的逻辑和公式计算的演绎系统的关系为类型形式主义者提供了新的切入点。在“类型”的明确的本体论意义不复存在之后，在计算中描述类型具有逻辑上的对应操作成了一般的“类型”普遍缺乏外部（脱离作为项的元数据使用的情形）领域意义的救命稻草——类型用于断言被描述的系统具有的可证明的逻辑性质。遗憾的是，普遍意义上，这行不通：

* 严格来说，最初的对应仅指的是[简单类型 λ 演算](https://zh.wikipedia.org/zh-cn/%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%CE%BB%E6%BC%94%E7%AE%97)和[直觉逻辑](https://zh.wikipedia.org/zh-cn/%E7%9B%B4%E8%A7%89%E9%80%BB%E8%BE%91)的对应。虽然存在有限的一些扩展，这里的对应仍有被在扩展之外（错误地）普遍默认的情形。这种对应受限于实际描述系统的源语言，且这种局面难以改变。
	* 通过归纳证明的扩展对应是有限的。而以某个类型论作为逻辑基础，一般地，原则上没法构造性地保证它能对应某个外部的公式计算，因为后者并不保证以类型论作为元语言进行描述的，自然不保证能以特定类型论表达；证明这种对应存在即涉嫌循环论证。
	* 研究扩展关系的进展并不快。例如，带有一般用户习以为常的指令式控制(imperative control) 作用的λvC 演算和[经典逻辑](https://zh.wikipedia.org/zh-cn/%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91)的对应关系在 1990 年才被 Timothy Griffi 明确提出。
* 断言证明总是可以同构于程序(proof-as-programs) 同时使命题作为类型(proposition-as-types) 在计算上的应用仍然是一厢情愿的。
	* 需要注意普遍的计算允许以不符合[强规范化](https://zh.wikipedia.org/zh-cn/%E8%A7%84%E8%8C%83%E5%8C%96%E6%80%A7%E8%B4%A8)性质的程序表达的一般的[偏可计算函数(partially computational function)](https://zh.wikipedia.org/zh-cn/%E5%8F%AF%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0#%E5%AE%9A%E4%B9%89) ，却不能保证存在一一对应的有效的“部分证明”(partial proof) ——显然证明必须停机。
	* 考虑到以上被表达的一般的偏函数的非强规范化性质可被认为是一种有别于有限步骤求值的计算作用(computational effect) ，逻辑系统根本上只能表达纯(pure) 的计算，而不能表达更丰富的带有各种副作用的计算。
	* 这表示即便能依赖这些对应，也只能解释一部分计算中的“类型”的意义。

　　即便接受上述对应，仍不能解决一个事关用户自由的合理性问题——凭什么这些预期的性质就必须是通过拼凑组合某些预置的、随项按硬编码特设规则传染得到的类型，而不是由用户直接以语言中的计算规则表达何为预期性质的、不必然依赖具体的项的元数据来表达？

　　至少就编码解决实际问题的程序而言，显然存在更直接的方法来摆脱意义不明的或实现过于复杂的“类型”的缺陷，如 [Benjamin C. Pierce](https://en.wikipedia.org/wiki/Benjamin_C._Pierce) 的[一个 talk](http://www.cis.upenn.edu/~bcpierce/papers/harmful-mfps.pdf) ，其中举例设计语言中对类型的滥用遇到的问题，并提出[契约](https://zh.wikipedia.org/zh-cn/%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1)作为解决其中一部分问题的（部分）替代解决方案。这可能早就该是业内应被周知的做法，虽然迄今业界[似乎仍然习惯](https://cstheory.stackexchange.com/a/5231/55732)把契约弱化为[断言](https://zh.wikipedia.org/zh-cn/%E6%96%B7%E8%A8%80%20%28%E7%A8%8B%E5%BC%8F%29) 而使之不足以系统性地代替类型系统。

# 派生概念

　　出了偏差是要负责任的……

　　还需要补课。

## 类型正确(Type Correctness)

　　因为上梁不正的观念偏差，钦点“正确”的风气大势所趋严重；可惜排除少数几个坑明显特别大、涉及用户基数也大的话题（如 [`const` correctness](https://isocpp.org/wiki/faq/const-correctness) ），一个个都不怎么喜欢定义清楚什么叫“正确”……

　　当然，把“正确”当成“符合期望（上层规格说明隐含的规则）”其实在实用时本身问题不是很大。

　　比较显著的问题直接来源于上述的本体论认知混乱导致的对语用习惯的干扰：要先知道“是”什么类型，才敢放心用。然而，这并不总是有必要；无条件遵守这个教条反而容易引入不被期望的错误。

　　病例集中体现在[类型推断](https://zh.wikipedia.org/zh-cn/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA)（这里 inference 译为“推断”指要求必须存在能用于确定项上类型指派的解否则失败，通译“推论”没有这层含义，而“推导”(deduction) 形式上更一般但更弱，一般不要求限制特定输入的形式）上。典型例子是 C# 提供了 `var` 关键字，“社区”意见迅速分为两派（中间派似乎惯于闷声大发财）：尽量用和尽量不用。虽然前者主要势力之一的 Reflector 党忍受性能拙计（也许他们都有 SSD ）我不是很能理解，切入点也非常奇怪，但整体还是算有那么些道理；而后者主要理由是不显式写出类型可读性差之类。

　　基于足够的理由，我旗帜鲜明地站在前者一边——谁告诉你看不出显式的类型可读性就差了？谁规定显式类型就是所谓“可读性”了？又有谁规定理解程序源代码片段的含义应该先从了解具体的项的某一个类型开始？说白了，不讲清楚前提非要这样胡扯的，或者没有理性思辨就以不准确的直觉断定这种依赖是无条件必要的，都显然不适应缺乏阅读缺乏显式类型标注(type annotation) 代码；考虑到程序设计语言发展的历史以及所谓动态语言的流行，这样的人的阅读代码的天赋或经验本身就显得相当可疑，由此而来的片面结论也就缺乏普遍的参考价值了。基本原理其实很简单：根据没有刻意混淆过的代码理解程序是**正向**的工程过程，理应和产生设计思路在方向上大体一致。考察程序或语言自身的设计如何满足需求这一过程，都是先有表达设计的程序或语言（不管是合乎文法的代码还是先于代码成型的模糊概念），后有约束和刻画程序中局部组成部分的类型（附加的元信息）及依附于类型语义的类型系统规则。（这个过程就是一般意义上所谓的 *typing* ，不过这部分内容不在这里剧透，以下另行详细讨论。）并且，普遍意义上，**后者是可选的**，缺少类型的描述不应使被描述的设计不完整，否则设计本身就有问题（例如，对用于描述设计的语言选型不当）。当然，某些情况下（如设计具体类型系统的规则时），“类型”本身是“业务”对象，但这类情况下“类型”就是“值”，而真正起作用的类型是描述系统的元语言中的元类型——如果需要这种类型存在的话。总之，不管这里的过程由人类读者还是由机器根据语言的具体规则进行实现，缺乏这种**先来后到**的逻辑常识（换种说法，“允许使用类型简化问题”的需求和“引入类型”的设计之间满足**因果律**），对任何理解类型怎么在高级语言中工作来解决实际问题的用户来说，都是说不过去的。

　　另一个支持使用类型推断代替显式类型的观点声称这便于代码重构。实际上，这是上述逻辑自然的推论：若想在代码中表达的逻辑本来不就依赖具体的类型，那么以某个阶段为基础，无视这种类型继续重复微调正向设计自然不应受到更多的限制。不过，这已经是一种弱化的描述。更合适的做法是，即便不管实际会发生多少重构需求，**多数**情况下**就不应该写出（即便是不重复的）显式类型**，因为这些情况问题的有效的解就**不依赖类型具体是什么**；显式依赖不必要的具体类型不必要地限制了解的外延，反而在类型正确的问题上**更不精确**（或者说，**错误**的程度更大），只是在重构时更容易发现**不够**精确才更容易暴露出来而已。而作为上述因果律的应用，本来正常解决问题的套路就是**先理顺逻辑和实体之间的关系然后考虑能在选定的语言中使用什么类型**，而**不是先看看自己知道些某种语言能支持什么本体论意义上的名义类型然后去凑解决方案**（如果只是因为选定的语言抽象起来实在太不方便，那是选型失败，是工程缺陷，没权没条件改掉就横竖都得忍）。后者虽然在推敲具体实现时作为**妥协**（如消歧义文法变通和照顾编译性能）无可厚非，但显然是方法论意义上的颠倒因果，而且很容易造成[抽象泄漏](https://zh.wikipedia.org/zh-cn/%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F)）这类擦屁股后患无穷的问题。而这里依赖类型推断就是表达必要关系（而不是本体）的有效手段（如果只是编译器报错烂就别赖方法论问题了）。

　　小结：上面这种情况把类型写得太清楚具体，反而是不那么“类型正确”的——不“合适”地符合解决问题的“期望”。

　　简而言之，**更清楚地限制使用的类型具体“是什么”，依赖不必要的从实现泄漏的假设，导致很可能更不正确**。这是一个长期以来容易被用户普遍忽视的过度设计/实现的典型例子。

## 类型识别(Type Identification)

　　提到“是什么”的问题，最显然的实现是比较给定的表示类型的数据结构（类型标识）和已知类型的对应数据结构是否相等。进一步地，也可以扩展到任意两个类型之间的同一性(identity) 比较。这也被一些语言直接提供为语言特性。

　　这种实现具体的操作也暴露了基于本体论意义上的判断的局限，而且被更多用于普遍地了解。比如说， C++ 中一般尽量不要用 `typeid` 比较相等——倒未必是因为运行时 `typeid` 性能低（至少存在比 `dynamic_cast` 普遍快的实现），而主要是因为硬编码 `==` 扩展性烂得太感人了，和 `dynamic_cast` 啊虚函数啊比起来没啥优势。

　　当然不可否认运行时类型识别不少情况下可能仍然有必要（对 `typeid` 而言，实现 `any` 这样的类型擦除(type erasure) ，算是个主要的例子），但是提可扩展性和灵活性其实是不太必要关心运行时不运行时，道理都是类似的。为什么这里的理解就出了偏差呢？谁的责任？

## 类型转换(Type Conversion)

　　可能是基于某些劣质教材和人云亦云等原因，有几个相关话题的认识是重灾区，值得单独拎出来挂的程度。

　　鉴于不是重点，仅举一例。

　　例如，许多童鞋甚至不知道强制(coercion) 是一种**隐式转换**以及多态(ad-hoc polymorphsim) 而和铸型(casting) 这种**显式转换**混为一谈。

　　至少，请停止**颠倒黑白**。

## 类型安全(Type Safety)

　　比起上面几个而言，类型“安全”是在一般语言中更普遍存在的口水话题。

　　所谓安全，基本含义和“正确”类似，仍然是“符合期望”，只不过更多地强调考虑风险而不是考虑具体对策评判尺度的唯一性，在一般意义上也相对不那么容易被语言规则强制。

　　按理说，既然选择措施的余地更大，就应该更容易有共识各取所需才对。可惜业界的坏毛病是信息不对等面不改色继续窝里斗——我所谓的安全和你所谓的安全，也许就是鸡同鸭讲，但这个没关系，不听我话的就是不安全的！（黑人问号……）

　　基本上，比较有实用价值的类型安全的定义，依赖于类型这个概念本身的含义的准确性上。此外，在使用场景下需要满足一些性质。（虽然并非内涵）从实用角度出发，保证一般程序的“安全”这种普遍的期望，不能总是指望人；也就是说这类安全的机制应设计为可以被人以外的工具自动地检查。和表达能力结合，这需要设计本身具有某种意义上的可编程性。

　　较常用的一种安全机制的基本思路是，定义类型是某个域(domain) 中值的集合，保证类型安全即约束需要考察的值总是符合某一些类型的约束。语言规则中的一部分通过公开和类型关联的构造（如表达式），使判断对象语言描述的程序是否符合类型安全这项任务能被程序表达和实现（包括语言自身的实现，如编译时的检查）。这样，类型安全可以视为某一些语言规则中蕴含的性质。当语言的规则不足以保证它表达的任意操作产生的值属于规则事先指定的值的集合之内，这些规则就不是安全的；反之，这些语言规则是类型安全的。

　　问题在于，这里有个关键的岔子：什么才算是符合预期的事先指定的规则？或者说，如何选取域？

　　虽然有一些较为公认的规则（而被不同语言“借鉴”），但因为依赖的假设和类型系统设计不尽相同，超过类似上面的周知陈述地去讨论什么才能算类型安全而取得共识这点在一定意义上是徒劳的。

　　作为典型症状，相当多数用户在得到他们认为“安全”性质的推理过程有相当大的漏洞：他们往往既不知道作为共识的安全性质是指什么，也不清楚（各种不同的）“安全”是如何保证的。这样的方法论对澄清这种本已经混沌的话题自然没什么卵用。

# 点题

　　回到标题的问题。

## 类型检查(Typechecking)

　　现实的类型安全一般通过在语言设计中由两类手段提供支持：语言的构造性规则限制不安全类型构造的表达，以及语言对潜在不安全的表达进行额外的语义检查。前者涉及对不特定的项（如表达式）进行类型指派，也就是一般所谓的 *typing* ；后者相对比较事后诸葛亮但在设计语言时配置起来比较灵活（可以很容易地弱到没有而不那么容易影响其它语义），所谓 *typechecking* ；然而很多人根本没搞清楚**这两者根本不是一回事**。（这里的 typing 可以译为*定型* ，或者更逻辑学一点的说法，*类型指派* ——不过基于和 typechecking 直观对比等需要，本文暂且不译；此外，区别于作为按规则要求的必须实现的 typechecking ， type checking 指类型论中一般目的关于类型的验证，广义地，也能包含 typing ——但这里特别避免这样做——也因为这样无法在中文中体现的微妙差别而保留不译。）

　　（终于点题了……）

　　应当注意，这两者根本上指的是涉及语言规则的设计而非直接指定语言**实现**的行为。特别地，尽管一般实现 typechecking 蕴含解一个判定性问题——即作用于代码上判断出一个表示“通过”或“不通过”的二元结果，却并不一定表示接受或者拒绝接受程序。一条语言规则不会因为实现要求附加其它行为或不要求任何可预测的行为（所谓未定义行为）而不适合归类为 typechecking 规则。举例： C 的许多使用非兼容类型(compatible type) 的值的操作是未定义行为，这不是 typing ，而指定了作用于指针类型上的 typechecking ；只是它的要求弱到允许检查是**空实现**——实现可以附加任意少的检查操作（直至进行可能无法预料的响应）致使其可用性未必符合一般对 typechecking 有效性的期望，而容易被误认为和 typechecking 无关。

　　一般来说，这两者的确具有不少共性才容易被混淆。比如说，都可以作为实现某种类型安全规范的要素；再如，简单情形下都可以构造为判定性问题；再如，在语言实现的哪个阶段(phase) ——翻译时（“静态”）还是运行时（“动态”）检查（注意**区分出“运行时”和非“运行时”并非对所有语言都有意义**）；不一而足。只是混淆这两者问题可能还不大，但基于混乱的认知对语言设计分类而只能让围观群众继续不明觉厉，就不那么好笑了。

## 静态/动态（类型）？

　　首当其中的是一些关于静态/动态语言和静态类型/动态类型语言的混乱。在了解 typing 之后这就不攻自破了：静态类型或者动态类型都和 typing 的时机有关；而单纯静态/动态，对彻底不提供类型系统设计的 typeless 的语言都可能说得通。

　　重复，需注意，对一些不规定区分静态/动态阶段的语言，这些分类都毫无意义——除非就干脆认为静态只是特殊的动态得了。

## 强类型？

　　更严重的问题在于“强类型”(strong type/strong typing/strongly typed) 这个说法。考虑到这个概念词源上基于 typing ，引用起来却杂糅了 typing 和 typechecking ，不同作者对什么是足够强的理解还不一样，混乱可见一斑。

　　这里的一般建议是避免混乱的用法。如果不能避免，仅在确定类型时使用，而讨论类型检查时直接以具体的机制（对 ××× 类型的检查）来避免混乱。特别地，应注意避免“弱类型”这样望文生义还模糊了原本可能已分清界限而使之失去实用价值的生造词。（后者的使用者通常还具有其它的认知混乱，比如无法区分强制(coercion) 和铸型(casting) ，不清楚强制可以作为一种多态([ad-hoc polymorphism](https://en.wikipedia.org/wiki/Ad-hoc_polymorphism)) 而不一定有损类型安全性等等。）对特定实体声明保持类型的性质，使用 manifest typing/latent typing 论述——这样“强类型”这个说法才有一些无歧义的生存空间，不至于像“弱类型”一样鸡肋且造成误会。

**注释** 技术上，以削弱类型检查为由而强调“弱类型”的造成的混乱是相当容易理解的。须知，一个不支持隐式类型转换的强类型语言，其类型规则中可以通过添加*更多的* typing 规则，规定隐式转换所在上下文的源和结果应当具有什么相对于特设上下文（这里自然不能无条件适合任意类型，而需要明确更细粒度的条件）多态的类型，来引入原本不存在的隐式转换，堂皇地变成了所谓的“弱类型”。问题来了：为什么一个已有的“强类型”语言中加入了更多细粒度的类型规则，反而变“弱”了？明白 typeing 和 typechecking 的不同之后，这类问题就变得不攻自破；而“强”“弱”类型的说法是如何散播愚蠢的这点也愈加鲜明了。

　　另外，虽然不如上面的提法直接，还有其它[一些观点](http://papl.cs.brown.edu/2016/safety-soundness.html#%28part._.Types_.Versus_.Safety%29)指出强类型和类型检查的“强度”无关。和上面的结论类似，为了避免不相关的误导，持有这类观点的作者也同样不建议使用“强类型”“弱类型”的说法。

## 习题

　　了解这里的习惯描述以后，仍然可能未必了解概念的使用（因为没法指望不同的作者统一使用准确的含义），不过我期望读者能自行分辨一些较明显的混淆。

　　看似专业的错误面面观（当然，也不是每个作者都用错了）：

* https://www.zhihu.com/question/19918532
* http://lambda-the-ultimate.org/node/5286

　　**提示** 首先，考虑讨论的是一般的语言设计，不要先入为主地假想类型（系统）已经存在。其次，“使用语言规则约束程序行为提供保证”的设计手段和“使用类型系统的某些性质提供保证实现这种设计手段”不是同一个层次的抽象。

# 延伸阅读

　　继续补课仍然是有意义的，特别是验证以上认知的意义。

　　另外，虽然不是惯常风格，偶尔留些习题也好。

## 类型可靠性(Soundness)

　　可靠性是关于逻辑系统的性质。一个逻辑系统是可靠的，当且仅当任意合式公式(well-formed formula) 论证的形式保证在语义上有效（有效前提蕴含有效结论）。

　　类型系统（或者，至少它的一个实现——确信符合要求的程序代码）可以作为逻辑系统，相应地具有类型可靠性。具有类型可靠性的类型系统，静态地（在运行前）通过类型检查得到程序的性质，和程序运行时保证的性质总是一致。

　　有些关于类型安全的命题可能足够众所周知之而被作为可靠性的公认判断准则，比如[这个](http://typeof.net/2014/m/formation-of-modern-magic--why-functions-are-contravariant-in-the-input-type.html)（嘛，函数类型对参数类型协变的公理，原文挂了暂时也懒得找）。遗憾的是可用的结论虽然普适但过于基础而太少，而且仍然依赖特定对象语言的类型系统设计（有些语言根本就不支持表达这样的类型所以就是一句空话……）。

## 强制类型(Mandatory Typing)

　　一般来说，一个语言设计可以有类型系统，不过还是有一些手段能在现有的语言上套用不同的类型系统并发挥原始设计者都并不一定预见的作用。

　　这样有个问题。如果把使用不同设计的类型系统作为扩展手段，那么原始的设计中坚持指定的类型系统有什么用呢？

　　当然，一致性(conformance) 是在写 spec 时的核心问题。不过，是什么决定，有必要把 spec 写成这样呢？意义何在，又有多少的部分是妥协？实践上通常采用哪些演进路线，决策的理由是？

## 语法方法主义(Syntacticism)

　　从逻辑系统的意义上来说，让类型检查的规则代替表达类型的类型指派规则是可行的。这种处理具有一定的普遍意义，同时（至少形式上）能减少通常无法准确形式化的语义规则带来的纰漏。极端地，可以用形式文法把语义规则用语法规则和前提假设代替。

**注释** 实践中，正如 Benjamin C. Pierce 在 [TAPL 的 Introduction](https://www.cis.upenn.edu/~bcpierce/tapl/) 中指出的，编程语言应用的类型系统是指一种*语法方法(syntactic method)* 。这相当符合大多数实际情况——尽管被类型系统描述的编程语言（对象语言）中类型系统规则是语义规则，但描述这些规则的元语言，不论是自然语言还是更系统的形式语言，指定的都是关于以特定种类的类型作为模式(pattern) 的规则，亦即元语言的语法规则。

　　然而，实际上局限也非常明显。

　　被忽视的重点在于，这以**已经得到了一个可靠的形式系统**——良型(well-typed) 规则为前提——这并非适用于一般领域（特别是通用目的语言的设计），类型系统的抽象能力并不足以应对所有需求变化。然而，没有一个通用的语言设计能保证一次性地给出所有精确的类型规则；相反，现实中能满足需要的通用编程语言设计——包括其**类型系统的设计普遍是不断演进的**（只是有些极端情况因为设计得过于局促，无法扩展而停止罢了）。这意味着语言规范中关于类型规则的部分可能会被不断地修改，往往需要可观的维护工作。要求类型系统先验地可靠对语言规范的维护者提出了不切实际的要求，以至于就给出规范的这个任务上都无法保证可实现。从工程角度看，不满足可行性要求是一种规约失败，即便限制通用性以保证能勉强设计出来结果，也只是个变通的**妥协**，根本算不上针对原需求的**正确**的解决方案。

**注释** 即便不考虑具体的工业语言，经典的带有的类型系统计算模型自身也在不断演化。例如，简单类型 λ 演算就是从[无类型 λ 演算](https://zh.wikipedia.org/zh-cn/%CE%9B%E6%BC%94%E7%AE%97)扩展（添加限制）得到的；前者之后还扩展到 [λ 立方体](https://zh.wikipedia.org/zh-cn/Lambda%E7%AB%8B%E6%96%B9%E4%BD%93)和其它比简单类型 λ 演算更复杂的模型。这里特别有趣的一点是，光是简单类型 λ 演算到 λ 立方体的扩展具有三条正交的演化路径，且每一个演化步骤添加的类型规则和得到的结果都有清晰明确的类型系统意义。要先于无类型 λ 演算的发现直接建立这些有类型 λ 演算的精确理论无疑是困难的（尽管历史上一些近似却没有经过足够理论分析的类型系统特性在差不多同一时期或更早就出现工业语言设计中了），而这仅仅覆盖了现有语言中的（大多数还是缺乏严格形式规范描述的）类型特性的一小部分；要在理论上分析现有的非形式设计的有效性和合理性普遍会更困难。

　　其次，运行类型检查的算法复杂性和实现及维护良型程序需要的代价，往往没有被妥善考虑。这里的代价更多落在语言的直接用户上，使用户使用这样的语言的理由打了折扣，还（因为对语言的了解程度普遍不如设计者，以及基数较大）容易造成原本就没有解决的混乱急剧扩大——庸俗点说，可读性、可调试性、最小惊讶原则……这类也是一揽子口水话题了。

　　第三，或许是距离用户最远，但根本上最重要的理由是，强调类型系统作为语法方法设计，会阻碍对一些具有强力实际效用的语言设计的可能性：折叠不同的元语言和对象语言，使得到的设计更加通用——这样，使用一种语言在特定上下文的（语义规则上的）特化，就能适应不同的领域，而不必（从语法规则开始）设计许多特设的[领域特定语言](https://zh.wikipedia.org/zh-cn/%E9%A2%86%E5%9F%9F%E7%89%B9%E5%AE%9A%E8%AF%AD%E8%A8%80) ，显著减少需要综合大量不同领域的应用的开发者的学习及兼容性等问题的成本。

　　之所以说距离最终用户最远，是因为当前的用户普遍没有能力使用这样的方法，甚至大多数专业开发者也没有自觉。但这不会总是未来。而最重要，指的是对语言的可用性设计的全局影响——某种程度上比区区关于“类型”的话题更重要。

　　这种被语法方法限制的方法具体是指通过提供同时在元语言和对象语言中通用的语言特性。这样的设计可用于扩展语言自身。具有这种能力的语言设计的性质称为*光滑性(smoothness)* 。John N. Shutt 提出[*光滑性猜想(smoothness conjecture)*](http://fexpr.blogspot.com/2013/12/abstractive-power.html) ，指出违反光滑性会损失语言的抽象能力（这里的抽象能力是可被形式定义的概念）。在满足足够光滑性的语言中，关于类型系统的设计是自然地极小化的，也不需要有静态规则；如有必要，静态类型规则可被用户程序提供，使类型规则作为语言的扩展。就传统的静态类型的最主要应用目的（提供“静态”证明，减少计算开销和可能的程序缺陷）来讲，这并非必要，因为元语言从来没有“静态”地要求先验存在类型这样的实体，而直接允许直接定义不像类型语法地依赖于项的独立的可证明构造的方法，这比依附于项上的“表达式具有类型从而使程序可以证明有用的保证”在实用意义上更强大：对证明的形式限制更少，原则上还能最大化地复用（可能经过扩展的）元语言的所有不引起逻辑冲突的语法构造。

**注释** 对静态类型语言设计者而言，语法方法蕴含一种设计顺序的限制：先设计类型规则作为语言的核心，再设计符合类型系统的其它语义规则（形式地，一般是操作语义规则）。这种设计得到的类型系统称为*内在类型系统(intrinsic type system)* ，或称 Church-style type system 。与之相反，先设计语义规则，再标记语义规则允许的项上的类型进行限制得到的类型系统，称为*外在类型系统(extrinsic type system)* ，或称 Curry-style type system 。从实例的普遍性来讲，因为历史习惯等原因，内在类型系统是当前（除某些如定理证明为目的的个别特定领域的）编程语言设计的绝对主流，但因为原则上实用的类型系统会复杂到需要先于被描述的语义规则的形式描述，因而引入特设的元语言，而天然地违反光滑性（这样的元语言的语义规则不能恰好保证和被设计的对象语言一致，否则就有鸡和蛋的问题），也不符合通过自然扩展得到复杂类型系统的模型的演化方向（如先前的 λ 演算扩展的例子）。这种根本缺陷是方法论意义上无法克服的。

　　注意光滑性具有远比类型系统设计更普遍深远的影响——例如，足够光滑的语言不需要提供特设的“反射”这样的特性，就能取得（不论是否是关于类型的）元数据，因为之前的元数据从没必要像“静态类型”一样预期被丢弃，而需要通过反射迂回地引入。作为特例，关于所谓的类型内省(type introspection) 之类在普通静态语言需要“黑科技”的特设接口设计的经典问题，通过不依赖类型系统设计方法的路径就被轻描淡写地消解了。**与之相比，类型系统的具体设计的话题甚至琐碎得像是“实现细节”，实在没什么相提并论的必要。**（当然，也应该不算白讲……）

　　抛开编程语言，语法方法的目的和意义也有不少超出“类型”本身的（不那么）有趣的问题。

　　虽然当前没有完全分析归纳某些理论家在局限明显的情形下继续吹捧这类“完全体”静态类型语言的动机（也许是数理逻辑一向就有证明论语义(proof-theoretic semantics) 方法学的间接影响……嗯……且不管和形式逻辑内的观点[撕逼](https://link.springer.com/chapter/10.1007/978-3-319-22686-6_11)），不想阴谋论，不过作为问题也是有必要思考一下的：在一般意义下支持的理由（有什么优势以及能够接受的不足）？

# 旧瓶新酒

　　之前提到的类型论在历史上的作用。“类型”这个概念之所以作用显著，还得益于之后的一些发展，不过，并不是那么顺利。

## 渊源

　　众所周知，罗素悖论在集合论框架中被 [ZF](https://zh.wikipedia.org/zh-cn/%E7%AD%96%E6%A2%85%E6%B4%9B-%E5%BC%97%E5%85%B0%E5%85%8B%E5%B0%94%E9%9B%86%E5%90%88%E8%AE%BA) 等[公理化集合论](https://zh.wikipedia.org/zh-cn/%E5%85%AC%E7%90%86%E5%8C%96%E9%9B%86%E5%90%88%E8%AE%BA)形式上地解决。包括 ZF 和 [新基础集合论](https://zh.wikipedia.org/zh-cn/%E6%96%B0%E5%9F%BA%E7%A1%80%E9%9B%86%E5%90%88%E8%AE%BA)等的公理化集合论在演化中历史弱化直至放弃（由[有序对](https://zh.wikipedia.org/zh-cn/%E6%9C%89%E5%BA%8F%E5%AF%B9)编码集合的构造取代）了类型的概念。这意味着“类型”在构成数学基础的逻辑系统中不是必要的。鉴于[其它之后历史上其它一些理论取代公理化集合论地位的失败](https://zh.wikipedia.org/zh-cn/%E8%8C%83%E7%95%B4%E8%AE%BA#%E5%8E%86%E5%8F%B2%E6%B3%A8%E8%AE%B0)，类型的概念迄今仍未被公认作为整个数学的形式基础。

　　不过，基于[逻辑学](https://zh.wikipedia.org/zh-cn/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91)的进展，上述有关“类型”的遗产被发展为[类型论](https://zh.wikipedia.org/zh-cn/%E7%B1%BB%E5%9E%8B%E8%AE%BA)这一新的数学分支，为[元数学](https://zh.wikipedia.org/zh-cn/%E5%85%83%E6%95%B0%E5%AD%A6)和[类型系统](https://zh.wikipedia.org/zh-cn/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1)提供替代集合论的[形式模型](https://zh.wikipedia.org/zh-cn/%E6%A8%A1%E5%9E%8B%E8%AE%BA)。

## 类型、逻辑和语言设计

　　按逻辑学的传统，类型论或形式化的类型系统的设计常用[相继式演算](https://zh.wikipedia.org/zh-cn/%E7%9B%B8%E7%BB%A7%E5%BC%8F%E6%BC%94%E7%AE%97)表达。其中逻辑公式断言了符合类型系统要求的合式(well-formed) 的项。一个语言中的 typing 或 tyechecking 的实现可以对应为找到符合公式指定的类型约束的项，或证明这样的合式公式(well-formed formula) 。

　　因为相似性，[自动定理证明](https://zh.wikipedia.org/zh-cn/%E5%AE%9A%E7%90%86%E6%9C%BA%E5%99%A8%E8%AF%81%E6%98%8E)和[形式验证](https://zh.wikipedia.org/zh-cn/%E5%BD%A2%E5%BC%8F%E9%AA%8C%E8%AF%81)等特别适合这样的方法。这些领域使用的领域特定语言具有特定的、较丰富特性的具体类型论。一些与此相关的基于特定类型论的语言也被提出：

* [LCF](https://en.wikipedia.org/wiki/Logic_for_Computable_Functions) 引入 [ML语言](https://zh.wikipedia.org/zh-cn/ML%E8%AF%AD%E8%A8%80) 作为定理证明系统的元语言，使用其中的 [Hindley-Milner 类型系统](https://en.wikipedia.org/wiki/Hindley–Milner_type_system)。后继的 [HOL](https://en.wikipedia.org/wiki/HOL_%28proof_assistant%29) 系统也使用 ML 。
* [Nuprl](https://en.wikipedia.org/wiki/Nuprl) 使用[直觉类型论](https://zh.wikipedia.org/zh-cn/%E7%9B%B4%E8%A7%89%E7%B1%BB%E5%9E%8B%E8%AE%BA)。
* [Coq](https://zh.wikipedia.org/zh-cn/Coq) 使用[归纳构造演算](https://zh.wikipedia.org/zh-cn/%E6%9E%84%E9%80%A0%E6%BC%94%E7%AE%97) 。
* [Haskell](https://zh.wikipedia.org/zh-cn/Haskell) 也使用 H-M 类型系统。
* 一些 ML 和 Haskell 扩展使用[依赖类型](https://zh.wikipedia.org/zh-cn/%E4%BE%9D%E8%B5%96%E7%B1%BB%E5%9E%8B)。
* [Adga](https://zh.wikipedia.org/zh-cn/Agda) 和 [Idris](https://zh.wikipedia.org/zh-cn/Idris) 使用的类型系统基于 [UTT](https://www.researchgate.net/profile/Zhaohui_Luo/publication/225233240_A_unifying_theory_of_dependent_types_the_schematic_approach/links/0deec52a1025ec6518000000/A-unifying-theory-of-dependent-types-the-schematic-approach.pdf?origin=publication_detail) 。
* [F*](https://www.fstar-lang.org/) 的类型系统支持特性包括依赖类型和[限制类型](https://en.wikipedia.org/wiki/Refinement_type)。

## 作为语言设计模型的有效性

　　基于 Curry-Howard 对应，一部分语言不仅使用类型论提供类型系统的基础设计，也作为语义模型的整体基础，保证计算可被表达而适用于通用目的。不过，就“表达计算”而非求出证明这一目的而言，这样的方法在原则上有一些其它通用语言不合适的性质：类型论原则上具有额外的复杂性，作为表达通用的计算的基本模型不够简明(succinct) 。这个判断的表现和理由是：

* 集合论的例子表明一个不依赖类型概念的演绎系统即有相当强的表达力。类似地，一个表达计算的系统，[原则](https://zh.wikipedia.org/zh-cn/%E9%80%92%E5%BD%92%E8%AE%BA)上并不必须引入类型。
* 虽然证明和计算的同构揭示了一些深层的联系，逻辑系统能表达计算并非模型设计的原始目的。
* 任何包含类型的系统，不论以相继式演算还是更一般的演绎逻辑表示，都较为复杂。这导致设计和维护（查找和修正缺陷）一个类型系统的设计，相比一个同等的不要求表达类型部分的计算的基础模型，普遍具有较高的难度和较大的工作量。
* 当然，一个不包含类型的基础模型需要引入类型语义时无法避免类似的工作量；但这至少可以通过模块分离解决。而以类型为中心的基础理论则表示类型全然无法被剥离。
* 以类型论作为核心语义规则的系统因为内廪的冗余复杂性等原因，对人类用户不友好。
	* 即便表达能力在可计算性上等价，也无法提供对计算作用的直接抽象。本质的原因是计算作用并没有依赖于特定的类型上（而间接依赖于项上）的必要，强制要求类型表达计算作用的做法添加了一层对类型论设计者以外无用的间接抽象，是一种抽象泄漏。
		* 这也是有的设计中单独建模[作用系统(en-US)](https://en.wikipedia.org/wiki/Effect_system) 的原因之一——即便它和类型系统有相似性。
	* 直觉主义意义上的复杂性：基本不可能简洁地把程序分解为可被人直接模拟操作的[结构操作语义](https://zh.wikipedia.org/zh-cn/%E6%93%8D%E4%BD%9C%E8%AF%AD%E4%B9%89%E5%AD%A6)（[小步语义](https://en.wikipedia.org/wiki/Operational_semantics#Structural_operational_semantics)）。
		* 要让用户（哪怕是设计类型论的专家）记忆核心语言的逻辑公式来解读程序的含义（且不考虑目的）脱离实际。
		* 作为对比，退化为无类型 λ 演算的系统表达的基本计算本质上并不陌生，因为这实际上也是多数常见[指令式语言]中的一个严格子集。尽管后者的形式定义也非常晦涩，但非形式的理解和适当的形式模型相对容易找到对应。特别地，不要求任意的项的良型(well-typed) 对直觉理解的效率有相当大的影响。
	* 一旦引入类型，就难以避免和常见语言的显著差别，这样的差别还可能引起计算能力的改变。例如，即便是看起来“足够简单”的简单类型 λ 演算，其 β-归约的强规范性使之严格弱于[图灵完备](https://zh.wikipedia.org/zh-cn/%E5%9C%96%E9%9D%88%E5%AE%8C%E5%82%99%E6%80%A7)语言的表达能力。
	* 检验代码是否合式通常不直观，因为并不存在一般的方法保证能从可能语法正确的程序上完全地、任意地提取合式的性质，这本质上需要读者自行记忆各个项的类型并实现类型检查。相比之下，不以类型规则作为核心语义的通常语言中虽然也无法实现性质的提取，但直接在项上（而不是隐藏在项的类型中）的显式编码相对容易通过约定来标识。例如，对控制作用(control effect) 限定在少数构造中的常规语言，通过排除特定控制副作用的项即容易确认强规范性的操作，这对一般的类型系统不适用。这种不直观性破坏了高级语言的一部分抽象的目的。
	* 退一步讲，以类型论为核心的模型可能以非传统类型论的方式改进而克服抽象性和不直观性，但这没有避免或改善自身的复杂性，反而使整个设计更复杂。并且，借着同构的“合理目的”，在相似的特性集合上创造的元语言上的 [TMTOWTDI](https://zh.wikipedia.org/zh-cn/不止一种方法去做一件事) 的术语滥用的做法，并没有简化对计算的表达，反而容易引起误会。
* 以类型论为核心语义规则的系统对机器不友好，有效实现受到明显的限制。
	* 和[逻辑编程](https://zh.wikipedia.org/zh-cn/%E9%82%8F%E8%BC%AF%E7%B7%A8%E7%A8%8B)类似，实现必须在一定程度上填补声明式语言和底层的指令式表示（如机器 [ISA](https://zh.wikipedia.org/zh-cn/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B) ）的形态差距。相对于存在较简洁的结构化语义的模型来说，这需要更大差异性的变换，普遍更困难。
	* 这样的模型基本没有同时提出或补充提出面向机器的版本，只在具体的实现中逐步完善。与此相比，不依赖类型论，直接用规约表示计算的抽象机模型[早在 1960 年代就被提出](https://zh.wikipedia.org/zh-cn/SECD抽象机)，而[和规约系统的变换](https://www.cs.bham.ac.uk/~hxt/research/principles-of-programming-languages-notes.pdf)也被研究多年，经验积累较成熟。
	* 这种差异也导致实现习惯上普遍依赖翻译成外部的语言这种方式，整体上使通用目的计算有较大的互操作成本，对实现技术的应用也受到限制。
	* 一般地，对提供近似功能和保证的系统，替代的其它形式模型通常也难以十分高效地直接实现。但显然“不要求以类型论作为基础”蕴含了更少的要求，更容易保证不引入不必要引入限制。

　　也有一些语言不以此作为理论基础，但吸收了一部分特性：

* [Shen 语言](http://www.shenlanguage.org/) 的可选的静态类型系统支持依赖类型。

　　这样的语言可能避免上面提及的一部分缺点。不过，这样的特性引入方式基本上不会和不能提供能直接迁移不同系统的代码的兼容性保证；大部分照搬不同风格的程序可能也在一定程度上有保留混乱的风险。

## 过度设计

　　上面的分析实际上能在一些设计上体现。先前提到的 BCP 的 talk 体现了他已经认识到这里存在的在语言设计中滥用类型的问题。（另外有个值得一提的表述，Types good ⇒ More types better?）

　　有[类型论支持者](https://ice1000.org/about-cn/)认为这里的契约就是所谓的[限制类型](https://en.wikipedia.org/wiki/Refinement_type)。不过首先就历史看，契约风格的设计在限制类型前独立提出，而其涵盖的[同样具有逻辑学背景的某些方法](https://zh.wikipedia.org/zh-cn/%E9%9C%8D%E5%B0%94%E9%80%BB%E8%BE%91)的历史更是长得多。其次，抛开一些具体设计的相似性，契约在方法论上不要求类型理论的基础模型。因此，这显然是两回事。这样的观点的也可以视为术语滥用后果的例子。

　　另一个例子是对（以 Java 为代表的语言）提供 [checked exception](https://en.wikipedia.org/wiki/Exception_handling#Checked_exceptions) 的语言特性的观点。就特性本身来讲这算不上和类型论相关的过度设计（倒是可以作为独立于类型设计的控制作用的例子），但是一些对这项特性的观点表明某些用户存在对类型相关理论以及类型在语言设计影响和重要性的误读。例如，[这里](http://www.yinwang.org/blog-cn/2017/05/23/kotlin)的观点：

> 首先，写 C# 代码时最让我头痛的事情之一，就是 C# 没有 CE。每调用一个函数（不管是标准库函数，第三方库函数，还是队友写的函数，甚至我自己写的函数），我都会疑惑这个函数是否会抛出异常。由于 C# 的函数类型上不需要标记它可能抛出的异常，为了确保一个函数不会抛出异常，你就需要检查这个函数的源代码，以及它调用的那些函数的源代码……

> 也就是说，你必须检查这个函数的整个“调用树”的代码，才能确信这个函数不会抛出异常。这样的调用树可以是非常大的。说白了，这就是在用人工对代码进行“全局静态分析”，遍历整个调用树。这不但费时费力，看得你眼花缭乱，还容易漏掉出错。显然让人做这种事情是不现实的，所以绝大部分时候，程序员都不能确信这个函数调用不会出现异常。

　　这是一种典型的误解。事实上，这里描述的情况并不一定是无意的，造成困难可能仅仅是因为理解不足导致的误用。支持这个观点（而假定“确信这个函数不会抛出异常”总是必要的）的用户显然并不清楚[异常中立性(exception neutrality)](https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_exceptions.html) 在实际代码中起到的作用：表达接口的使用者明确*不需要关心* 和*不应依赖* 某个特定上下文可能存在的异常执行路径。这是一种接口设计上有意的[信息隐藏(en-US)](https://en.wikipedia.org/wiki/Information_hiding)（因为该条目质量问题，不引用中文维基百科词条）。（此外，另一个和具体实现细节相关的目的是接口的[二进制](https://zh.wikipedia.org/zh-cn/%E5%BA%94%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3)稳定性。）在这种上下文中要求使用 checked exception 是把目的彻底搞反了，即便能允许实现，也是自寻烦恼。

　　是什么引起了这样的误会？除了无师自通的理（瞎）解（蒙）能力和实际接口设计相关的经验问题外，下文的说辞也许能揭示一些原因：

> CE 看起来有点费事，似乎只是为了“让编译器开心”，然而这其实是每个程序员必须理解的事情。出错处理并不是 Java 所特有的东西，就算你用 C 语言，也会遇到本质一样的问题。使用任何语言都无法逃脱这个问题，所以必须把它想清楚。在《编程的智慧》一文中，我已经讲述了如何正确的进行出错处理。如果你滥用 CE，当然会有不好的后果，然而如果你使用得当，就会起到事半功倍，提高代码可靠性的效果。

> Java 的 CE 其实对应着一种强大的逻辑概念，一种根本性的语言特性，它叫做“union type”。这个特性只存在于 Typed Racket 等一两个不怎么流行的语言里。Union type 也存在于 PySonar 类型推导和 Yin 语言里面。你可以把 Java 的 CE 看成是对 union type 的一种不完美的，丑陋的实现。虽然实现丑陋，写法麻烦，CE 却仍然有着 union type 的基本功能。如果使用得当，union type 不但会让代码的出错处理无懈可击，还可以完美的解决 null 指针等头痛的问题。通过实际使用 Java 的 CE 和 Typed Racket 的 union type 来构建复杂项目，我很确信 CE 的可行性和它带来的好处。

　　最直接的是，这种观点没有认识到对意图的不准确推测已经体现了“滥用”。不过，耐人寻味的是，为 checked exception 辩护的理由，是把它和体现“强大的逻辑概念”的“union type”相类比，似乎因为逻辑概念上的“强大”就自然具有普遍而正当的适用性了。既然 checked exception 能看作是 union type 的“不完美的，丑陋的实现”，那么 union type 就应该更符合这里的需求了？很遗憾，事实完全相反。使用 union type 而不作特别处理，会*改变* 函数的类型签名；结合接口设计对函数类型的稳定性预期（这很常见）和这里的 checked exception 或函数返回类型的“传染性”，在接口设计上很容易导致和 checked exception 类似的灾难性后果（如果实现上不是更严重的话——考虑现有工具对 exception 可能有更完善的重构支持），实际上*污染* 了整个接口设计，在一定程度上也是一种抽象泄漏。而以“使用得当”为前提， unchecked exception 同样能够实现“无懈可击”的目的，并且不具有这种问题；反过来，在这个问题上（特别是整个调用树很大的情况），恐怕 checked exception 和 union type 都是几乎注定无法“使用得当”的。

　　另一方面，为何会对 checked exception 和 union type 有“完美”的预期呢？作用何在？

> 另外，Hejlsberg 还指出 C# 代码里没有被 catch 的异常，应该可以用“静态分析”检查出来。可以看出来，他并不理解这种静态检查是什么规模的问题。要能用静态分析发现 C# 代码里被忽略的异常，你必须进行“全局分析”，也就是说为了知道一个函数是否会抛出异常，你不能只看这个函数。你必须分析这个函数的代码，它调用的代码，它调用的代码调用的代码…… 所以你需要分析超乎想象的代码量，而且很多时候你没有源代码。所以对于大型的项目，这显然是不现实的。

> 相比之下，Java 要求你对异常进行 throws 显式声明，实质上把这个全局分析问题分解成了一个个模块化（modular）的小问题。每个函数作者完成其中的一部分，调用它的人完成另外一部分。大家合力帮助编译器，高效的完成静态检查，防止漏掉异常处理，避免不必要的 try-catch。实际上，像 Exceptional 一类的 C# 静态检查工具，会要求你在注释里写出可能抛出的异常，这样它才能发现被忽略的异常。所以 Exceptional 其实重新发明了 Java 的 CE，只不过 throws 声明被写成了一个注释而已。

　　好像也就这部分比较清楚用途。理由似乎比较明显了，是“模块化”的“静态检查”。不过，这样做明显有个逻辑漏洞：对这里使用 union type 来讲，模块性和静态检查保证的性质的并不是靠 union type ，很大一部分是函数返回类型一致性（暂时不考虑协变性）的功劳。为何把这个基础的“类型安全”保证忽略了？似乎没有答案。

　　不过之后找到[提及这个支持此观点的解读](https://ice1000.org/lagda/DependentFunctionsVersusDynamicTyping.html)，从上下文中似乎又能体现一些问题。

> Java 的 Checked Exception 作为一个例外，是静态的异常， 但是这种语法结构和返回带有错误信息的类型 （可以理解为 Haskell 的 Either， Rust 的 Result） 是同构的（这篇文章本身说的很有道理，但请不要看它所引用的《给 Java 说句公道话》）。

　　如果说清楚地了解原因，那么应该容易地认识到，checked exception 在这里是体现冗余信息的反面教材，并不能作为体现动态类型信息的价值。不过为什么会遗漏这个考虑，是只有不清楚异常中立的作用的原因吗？

　　也许还真不是。回想上面 BCP 的 talk ，可能真陷入 Types good ⇒ More types better 的怪圈里去了……即便实际上表达控制作用可以全然不关心类型（比如[这个](https://dl.acm.org/citation.cfm?id=39443)）。

　　实际上，并不限于 checked exception ，具有类似性质的依赖“模块化”类型检查造成的带有传染性的污染都极易显著地阻碍工程意义上的可扩展性：一旦需要添加新的代码进行交互，牵一发而动全身，搞不好得把接口代码也全部修改一遍。类似的一个实例如[使用 sum type 代替子类型](https://www.reddit.com/r/haskell/comments/423o0c/why_no_subtypingsubtype_polymorphism/cz88npa/)。从逻辑的角度来讲，这些用法是对[封闭世界假定](https://zh.wikipedia.org/zh-cn/%E5%B0%81%E9%97%AD%E4%B8%96%E7%95%8C%E5%81%87%E5%AE%9A)的不当依赖。考虑到应用类型检查的主要目的之一是帮助用户避免不符合意图的非预期的程序构造，这样的非预期地限制了本该合理的程序构造的过度设计可被认为是假阳性(negative positive) 结果的实例。这个实例实在地揭示出类型检查的普遍局限性——不论类型系统如何强大，仍然需要人为地担保类型推理前提不和意图冲突这种非形式的正确性；这可能比确保类型正确性更难，而且容易被忽视，而和应用类型检查的主要原始目的相悖。

## 关于等价性的设计

　　因为类型论自身的特点，使用类型论作为模型的语言强调和依赖特定形式的等价性。这些等价性和不以类型论基础的语言有一定的差异，使之可能不如其它语言直接地在计算中表达。

　　逻辑推理可以[*演绎*](https://zh.wikipedia.org/zh-cn/%E6%BC%94%E7%BB%8E%E6%8E%A8%E7%90%86) 的形式表达，这也用于表达作为逻辑系统或计算的元语言的模型，其中的基本操作以[*重写系统*](https://zh.wikipedia.org/zh-cn/%E9%87%8D%E5%86%99%E9%80%BB%E8%BE%91) 的形式表示，称为*规约(reduction)* 。在规约中保持系统的语言保证的等价关系作为基本的相等性，称为[*规约等价性(reduction equality)* 或*计算相等性(computational equality)*](https://ncatlab.org/nlab/show/equality#computational_equality) 。*内涵的(intensional)* 类型论中特别地强调计算相等性（有时被涵盖于[*定义相等性(definitional equality)*](https://ncatlab.org/nlab/show/equality#definitional_equality) ）和[*命题相等性(propositional equality)*](https://ncatlab.org/nlab/show/equality#propositional_equality) 的区别（只有后者需要证明），使以类型论为模型的语言能同时表达计算和逻辑中需要的等价关系。这样的预设分类保持了语义的清晰并一定程度上避免了元语言和对象语言中关于等价谓词的规格重复，但相对非类型论系统（至少，相对不引入静态类型的系统，例如使用[潜在类型](https://en.wikipedia.org/wiki/Latent_typing)的设计）显得更复杂。内涵的类型论因为保证终止，其可计算性严格弱于图灵完备的语言。（*外延(extensional)* 的类型论则不明确区分这点，但也使类型检查[不可判定](https://zh.wikipedia.org/zh-cn/不可判定问题)，并不保证终止。）此外，可能因为外延过广以及实现通常不提供一致的底层对象模型的原因，类型论系统一般也缺乏能生成一般地“相等”的等价谓词的机制（如 [EGAL](http://web.cecs.pdx.edu/~black/publications/egal.pdf) ），尽管其它不少语言也没有这样的特性。

　　从语言的设计上考虑，要在形式上使语言能有效地解决可编程的问题同时要能被有效地实现（不蕴含对实现手段的不必要的限制），其[理论](https://en.wikipedia.org/wiki/Theory_%28mathematical_logic%29)需要提供一系列保持等价关系的等式(equation) ，即其公式在形式上包含相等关系的表达（即*等式理论(equational theory)* ）。这样指定的等价关系，允许实现在一定程度上变换以提供不同但对应相同语义的等价优化实现。这样的等式支持的等价关系实例越多，则允许支持的潜在优化余地越大。但是，若要保持语言的（不论是对设计者还是对用户的）简单性，等式不能过多。作为实用语言的理想的模型应该满足这样的性质，同时需要避免*平凡* 的理论，即理论中只包含*自反* 的陈述的情形。虽然对表达计算的目的目的来讲，平凡性并不是一个直接的问题；但对描述变换的逻辑系统而言，平凡性可能导致致命的困难，其例子和讨论详见[这篇文献](https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf)的 8.4.1 和 8.4.2 节。这影响到元语言意义上的实现：因为自反性被等价关系蕴含，平凡的等式理论并不能体现对“语义等价的不同的实现”的支持，意味着实现通常需要全程序分析才能对程序进行等价变换；这也意味着使用类型论这样的逻辑系统替代对计算的表达（而不只是关于计算的表达）会遇到一些额外的困难。

## 意义和效用

　　回归之前的数学上的讨论。相对其它的一些模型，例如集合论——类型论在语言或数学理论中起到的作用更多。经典的模型中，讨论模型需要遵循的元理论规则——逻辑学，和具体的“数学意义”，根本上是两回事。例如公理化集合论中用一阶逻辑描述集合论的，这样的逻辑作为元语言，在描述时是独立于集合论自身以外的。元语言表达的模型在逻辑上的具体适用性依赖[解释](https://zh.wikipedia.org/zh-cn/解釋_%28邏輯%29)来判断——尽管模型和*严格形式的* 解释在形式上基本是同义的，这种说法在一定程度上提供了关于模型在逻辑意义侧重上的自由借以安插非形式的观念（例如，考虑公理化的[可实现性](https://zh.wikipedia.org/zh-cn/可实现性)模型作为直觉逻辑的 [BHK 解释](https://zh.wikipedia.org/zh-cn/BHK释义) 的形式化，前者补全了后者并没有明确定义的*证明* 的观念）。

　　类型论的基础性运用则根本地改变了这种依赖关系。类型论的模型可以同时兼容（数理）逻辑和更传统的数学（计算）意义上的解释，因此在具体理论中能同时以同一套方法构造元语言和对象语言。这种反射（自反）的(reflective) 用法初看起来因为排除了多套不同的语言解释方法而非常简洁明了，却增加了理解和使用上的困难。历史地看，提炼模型使之能兼容不同的解释是给出语言设计之后的工作；融合不同领域的语言的兼容模型并不会凭空自动地提供超出语言意义以外的解释，不加修正被自然保留的只有共性。为了不损失各个依赖这样的公共模型提供的对语言的具体解释，模型自身会变得越发复杂（注意这不同于可计算性和可表达性，添加什么性质根本上依赖的是自然语言表达的选取外部语言的现有模型的决策，是没有方法断定模型一定够用而不需修改的）。同时，就任一个一般的特定领域和层次的语言来看，模型中的设计可能是冗余却无法简化的，因为不存在通过个别语言判断其它为了不相关目的提出的语言的（未严格形式化的）解释是否冗余的方法。

　　此外，即便在理想的情况下总是能得到兼容各种语言的模型，和逻辑同构的论题使接受和扩展模型的工作和计算感兴趣的结果无异，并不会提供更多可供演绎的对象。这样的目的下，效用就显得可疑了——为什么不直接使用领域更广、目的常常更明确、实现限制和开销可能更小的直接抽象更一般的变换（一般的“计算”，而不是以等价关系为中心的“逻辑”演绎）的模型呢？这也许就是依赖领域经验的主观问题了；不过，可供复用的工程资源的限制，使这方面的选型上不总是有太多的余地。这个意义上，答案或许是明确的。

# 结语

　　……科普教育果然还是甩链接省时省劲。

