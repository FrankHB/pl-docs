# 计算机语言学习导论

# 引言

　　因为近几个月收到了较多计算机科学基础尤其是编程语言入门指导的问题，之前也说过好几回会汇总一起解答，是时候填坑了。

　　但说实话这个坑挺大的，无法一次性填完，在这里会不定期更新。

　　因为是填坑，所以请读者当读到 **TODO** 注释时不要感到奇怪。大部分这类注释表示文档中相对较低优先级的部分，缺失可能会影响完成度，但不应影响主旨的理解。

# 历史遗留

　　早期论述片段汇总。仅供参考，初学者建议跳过。

**TODO** 可以加不少链接。

**TODO** Markdown 格式化。

## 学习经历

**注释** 免责声明：确实没什么可重复性，甚至至今除了使用的设备以外，这个偏差和普通用户相比较越来越大了。

**TODO** 另起章节补充之后的其它内容，阐明为何在没有可重复性上越走越远。

源：[这个贴吧主题](https://tieba.baidu.com/p/3388459316) 3L 。

　　感觉没啥可重复性。。。

　　就拿用什么设备|撸什么码|看什么书面材料举例好了……

* 2002-2004 文曲星PC2000C+NC3000|GVBASIC|内置帮助
* 2004-2006 文曲星NC3000*2+TC800C|LavaX/LavaX帮助手册+GVMaker文档
* 2006-2010 Dell Axim X51v(WM5/WM6+LavaXVM))|LavaX+C/ACM材料若干+ISO/IEC 9899:1999
* 2008-2012 Samsung R520+iDSL(DSTT)+HP iPAQ212(WM6/WM6.1/WM6.5)|C/C++|ISO/IEC 9899:TC3+/TC++PL/D&E/ISO/IEC 14882

* 2012- Dell 14R Turbo+iDSL+HP iPAQ212|C/C++|ISO/IEC 9899 2011:Cor1 ISO/IEC 14882:2011

　　材料：学校书本略（基础课的东西主要是让我来找错的）、所有没有被出版的略（比如WG14/WG21的paper）、认真看了50页以下的略（比如C艹Primer啊Haskell 2010啊算导啊TAOCP啊还有HoTT之类的数学书什么的）。

　　对别人来说应该没啥可操作性。。。比如C的书老实说之前一本都没正经看过，第一本正经看的就是C99，技术问题不管什么方面从来都是有问题直接Google懒得问人……居然没走岔路。有谁跟我一样奇葩么。

## 入门书目问题 [1]

源：[这个贴吧主题](http://tieba.baidu.com/p/5759976927) 14L 。

　　C++入门书？Bjarne Stroustrup的The C++ Programming Language，虽然我也没耐心看几百页就去直接读ISO C++了。

　　嫌难就找Bjarne Stroustrup的Programming: Principles and Practice Using C++，对多数人来讲应该更容易点。The design & evolution of C++这本不是入门的，但研究语言设计理论的，可以当消遣性历史读物，用于通过自测不看书之前的理解是否对路帮助评判自己悟性如何。

　　以下只能给出常识性评价。

　　首先，权威文档是 ISO C 和 ISO C++ 。有错误可以翻 open-std.org 的 defect report 和 paper 考古。其它靠谱点的书基本都有 errata ，不过相对没那么容易及时修bug。

　　C的话就是 K&R 的 The C Programming Language ，不过也可能有一些错误，所以随时准备考虑 ISO C 修正。

　　C++入门的除了 BS 也就 Scott Meyers 的书稍微能看点。 Herb Sutter 和 Andrew Koenig 也算稍微高级那么点的话题的靠谱的作者（也包括一些关于 C 的说法）。这里提一下 Accerated C++ 风评还可以，但是应该比较旧了。相对来讲一些讲C++惯用法的书（[More] Efficient/Exceptional C++）和以及讲C相关的书如 C Traps and Pitfall 这种相对不那么容易过时，特别是后者——因为语言在这方面变动比较少。

　　不推荐 C++ Primer 的原因是 Lippman 的文笔以及一些其它编排问题。以及读者认知偏差会比其它正经经典书更多。

　　Primer 后带 Plus 的不管是 C 还是 C++ 都是著名李鬼。作者应该不太懂关键知识点。

　　谭×之类的国产作者写这类书一般不作考虑——如果你不想返工重来一遍的话。尽管书本身的销量可能最多。

　　另外这里一个经验之谈是，如果一个作者既写 C++ 又写 Java 或者其它语言的基础教材，那么基本上至多只会有其中一门语言稍微靠谱点。比如谭×也就是写 BASIC 的书还行。当然，更可能的是没一本书靠谱。因为写靠谱的作者需要同时对不同语言的 spec 有深入准确的理解，这类作者一般不会去有空写这种书。（换做是我，要不是需要重复科普废话实在太多，带人灌水 paper 都来不及呢……）

　　如果有能力读原著，那就考虑直接读原著，因为译者的下限会把书的内容质量下限再过滤一遍，而译者普遍水平比坐着更差，虽然不排除个别还算靠谱的。尤其应慎重选择教科书的译著以免先入为主。裘宗燕的翻译质量整体还行，但有些术语明显偏离惯用法。其它自己搜风评。

## 入门书目问题 [2]

源：[这个贴吧主题](http://tieba.baidu.com/p/6113807981) 15L 。

　　虽然吧规有给清单，不过我本人不推荐任何书，更反对没其它编程语言的经验直接上手 C++ 。你不是天选之人，没本事把一坨蠢书的 bug 都找出来，之后事半功倍就等着呵呵吧。

　　硬说的话， SICP 旧版和 CSAPP 打底，基本上看懂（不一定需要做题，看各人本事）以后学其它语言稍微容易点。讲 ALGOL-like 语言的国产书和带 Primer 的都更不推荐，稍微要上路点的，C 可能一本合格的都没有， C++ 看 Bjarne Stroustrup 的出版年份较近的入门读物。（我不给具体书名。如果找不到，说明基本不适合学这玩意儿。）但是你非得要“速成”，除了会啃权威文档习惯快速断章取义给书找 bug 以外基本没什么办法——跟某些没经验者的不同，这就是已知最快的方法（只不过对基础技能要求比较高，但说白了也就是一般专业要求而已），除非你有本事发明你学的东西（但即便是有，也就是快慢的区别，参考权威文献对这种 artifact 是批判的基础所以不可能省掉）。当然，LZ 可以抱怨短时间吃 3 本书强人所难，不过 LZ 的问题本来就是这个状况，何况就现在本科教师普遍连什么权威材料该参考都搞不清楚的教学质量，大多数专业 4 年出来的基本也都达不到这个入门水准。

源：[同主题](http://tieba.baidu.com/p/6113807981) 16L 。

　　关于 SICP 之类的前期入门问题，免责声明：我没全部审阅过。但是我还是没找到更好的替代，所以顺便解释一下。

　　虽然我是所有都自学的，不过路径和进度都比较奇葩（远超出科班教学规划并且直接能给当期教材审校的程度），所以本身不怎么有参考性。

　　例如，我正式学 C 是直接读的 ISO/IEC 9899:1999 （之前有一些 BASIC 和个别小的嵌入式设备的 C-like 的基础，也是翻手册学的），反过来看 C 的教科书都是各种惨不忍睹了，包括 K&R 。具体坑哪先不多展开。

　　然后，C++ 我翻了一遍 BS 的 TC++PL 100 来页，就懒得多看了，直接翻 ISO/IEC 14882 的 draft 对照最新进展来试验。

　　这些学习路径对一般教师和学生确实强人所难。

　　不过我发现我还是漏掉了一个优化，那就是 SICP 。当年有个出国的学生（记得是哲学类贴吧遇到的，现在反正不混贴吧了）百度消息问我里面的问题，我第一反应是“什么鬼”，还提醒应该多了解些“函数式编程”，现在看来可能是黑历史了，直到我自己之后重新开始自己设计语言，从 λ 演算开始开始推出“纯粹”的计算模型，才发现 Scheme 的设计显然的清晰之处。

　　（还有个理由是，论长度， RnRS 显然比 ISO 的裹脚布清爽多了……差了几十倍。这导致原则上我对 LZ 这样的没基础的同学入门 C++ 这样的玩意儿持悲观态度，因为不管是什么书，杂七杂八的内容的数量就放在哪里，没基础就意味着不知道什么算是入门，哪些只是为了入门就能跳过的而节约时间。）

　　这时候我重新看了一部分 SICP （因为早就对非 spec 类文献习惯性速读，习题全部跳过不评价），发现里面确实有不少东西讲得比几乎所有其它入门教科书都清楚。

　　不过，以现在的眼光看，主要仍然是前几章的内容耐看。之后的内容有更多其它专业文献参考，对使用的语言本身的设计的要求也比较高。很遗憾，大部分语言属于“不怎么样”的一类（比如没有 proper tail recursion ）。

　　新版用 Python 的 SICP 在目的上实际出现了偏差。按 Gerald Jay Sussman 的说法，他想教的是 computer engineering ，而我这里说的纯粹就是 programming 的入门。

　　具体内容的问题，随便举个例子：

> Statements & Expressions. Python code consists of statements and expressions. Broadly, computer programs consist of instructions to either

>    Compute some value
>    Carry out some action

> Statements typically describe actions. When the Python interpreter executes a statement, it carries out the corresponding action. On the other hand, expressions typically describe computations that yield values. When Python evaluates an expression, it computes its value. This chapter introduces several types of statements and expressions.

　　从语言设计的角度来说，贸然把语句(statement) 和表达式(expression) 并列起来并不是什么好的讲法。

　　其实这里没有很好地抓住重点，而以至于偏差。

　　表达式来自并扩充了代数学上的一些习惯性表示，其目的起先是为了计算(computation) ，这点并没有错。

　　但是对非纯函数式的语言来讲，计算并不是使用表达式的唯一能表达的计算作用(computational effect) 。

　　在这里所有之前提到的语言的表达式的求值(evaluation) ，都是可能带副作用(side effect) 的——例如，输入/输出。这意味着一般的表达式同时可以 carry out some action 。

　　而语句确实经常只是为了 carry out some action ，但所有之前提到的这些语言中都是可以用表达式构建的。

　　所以把语句和表达式并列地讲，已经造成了先入为主的印象偏差。这不适合一般的“编程”基础（事实上，旧版 SICP 使用的 Scheme 就不是，下面会讨论）。

　　理论上正确一些的要点是，表达式包含的子表达式求值的顺序并不固定（尽管语言可以添加规则约定顺序），而“语句”必须是限定顺序的。这也是为什么语句对副作用的语言来说是个相对重要的构造，因为副作用（例如输入/输出）随意交换顺序可能会改变程序的可观察行为，用户通常必须指定顺序。而表达式则是一般地包含 compute some value 和 carry out some action 这两个职责的构造。

　　自以为已经入门的同学可以自测一下，有多少书本和老师会讲清这个的？如果真靠你自己的思考就能得到这个结论，可能就已经“入门”了。

　　至于我是在接触其它书之前独立通过 ISO C/C++ 的 function invocations do not interleave 规则发现的，后来才发觉这个就是理论计算机科学中经典的 applicative order （使用 currying 的话就无所谓 leftmost first ）。

　　题外话，其实从上面的讨论也可以看出，人为地在语言中区分出语句和表达式本来就不是什么容易理解的设计。像 Python 之类就属于这样的一开始就不怎么容易理解的语言。

　　反过来，Scheme 是不强调语句的概念的。在 Scheme 中，顺序的表达式求值使用特殊形式(special form) （在 R7RS 改称表达式类型(expression type) ） begin 。也就是说，实质上的语句的功能在 Scheme 中是用一个非常局部的语言特性就能实现的，这并不是什么大不了的认识。

　　然而对 ALGOL-like 语言（以及 Python 这样的大杂烩）入门的更多人来讲，他们是很长时间中都没有意识到这点的机会的。所以他们以后学不是这样设计的语言时，就要付出本该避免的更大的代价来摆脱思维定势。

　　当然，有的同学可能会问，首先用语句来作为最普遍的基本结构不也是很正常的吗？

　　这个问题也很简单：即便你有了语句，现实中也摆脱不了表达式。表达式具有子表达式这种递归的语法和对应的求值规允许以很小的代价使通过组合复用计算结果，而语句只支持顺序的描述，并且常规用法中不能直接把它当作表达式来用。

　　只有类似语句而没有类似文法的表达式结构，是没法表示灵活的抽象的，于是使用这样的语言，就被迫发明类似的高级语法扩展。

　　常见的大概也就一些汇编了（然而一般的汇编器实际上还是支持表达式的，还有更高级的抽象，所以事实是摆脱不掉；都有嵌套递归语法的设计在里面）。

　　这样的语言中，顶层上基本也是不符合结构化编程(structure programming) 的要求的，以至于只使用这样的构造，没法在现实中使用。（直接点说，和 SICP 要介绍 function 进行抽象的做法是矛盾的。）

　　结果，你学习这样强调语句为描述操作的基本单位的语言（虽然不严格，通常所谓的指令式语言(imperative language) 都是这样），需要同时了解表达式和语句，有的时候可能还要纠结什么时候使用语句，而没有清晰地了解或者忘记“我需要顺序就使用语句”这个本质需求。

　　作为普遍现象，这样的需求错位还带来了语言从设计到学习上的混乱。一个经典的冗余设计是 C 的 while 的条件，因为语法设计没法往里面塞语句，就需要用逗号表达式往里面实现语句的功能。（不像 C++ ，还有逗号重载而显得区分起来有点意义，虽然那个工程上基本上更恶心而更糟糕。）

　　让这样的语言设计流行起来，入门的错误姿势大概“功不可没”。语言的设计者也得通过对语言的学习入门，并且先入为主地对这样的语言更熟悉，于是市面上这样的语言就更多。所以，“工程”方面就更容易见到这些语言。但是，以“编程”为目的入门不应该受到这个结果的影响而增加工作量。

　　类似地，还有强调 proper tail recursion ，以及强调递归比循环更普遍（类似表达式比语句更一般化）也是常常会被忽视的理论计算机科学的传统。

　　这样做在表达计算目的和简化语言设计上其实是有很明确的目的的（虽然原理比较复杂，暂略），而许多语言通常没有独立的理论基础（例如操作语义模型），会漠视这个需求。

　　除了传统指令式语言的流行，这很大程度可能是“工业界”语言的设计者本身缺乏学术背景和训练的原因，以至于看不清这样的思路来简化更一般的设计问题。

　　像 Python 的设计者 Guido van Rossum ，早年就分不清 proper tail recursion 和 tail call optimization 的概念（这或许还情有可原，很多搞 Lisp 的都没分清），而且还以“难调试”作为不支持的借口，贻笑大方。

　　为了文明用语，暂时先不对其它具体讲法进一步长篇大论了，有问题可以个别提问和讨论。

源：[同主题](http://tieba.baidu.com/p/6113807981) 18L 。

　　还有一段 disclaimer 漏了，补充给了解 Scheme 的同学，虽然我认为 Scheme 很多地方设计得更正确，不过请勿在这个议题上误认为我是在单方面鼓吹 Scheme ：

　　就 begin form（其它 Lisp 可能用 progn 代替，对 C-like 语言来讲就是内建的分号——原则性表示“语句”的分隔符），Scheme 的具体特性的设计其实也不咋地。

　　事实上在 RnRS 的 derivation 中，可以看到 begin 使用宏基于 lambda 实现的。也就是 Scheme 的 lambda form 其实蕴含了“顺序”求值表达式的作用，在我看来违反了单一职责原则，并且 parse 起来容易错（可读性上还不如分号+}来得显眼）。

　　我已经在类似的语言中实现了不用任何原生顺序结构，只用函数调用的 applicative order 就派生出来类似 begin 的操作。（这种做法首先来自 John N. Shutt 的 Kernel ，不过我做的不要求 GC 。）

　　说起来倒是跟 Haskell 用 monad 实现 do-notation 有点像，但我全然不喜欢 monadic 的提法，因为说白了起作用的就是某个 monad law 但实际上应该叫 applicative 性质的东西而已。

### 延伸阅读：关于语句和表达式

　　参见这个 [SO 回答(en-US)](https://stackoverflow.com/questions/19132/57619680#57619680) 。

**TODO** 析出文献。

## 关于开发工具

**注释** 以下仅代表历史观点。虽然直至 2023 年 VC++ 因为并没有方便到哪去仍然不是首选（除非已经为了学习 VC# 等原因安装好了 VS 想在配置环境上偷懒），有些缺陷是改进，到能用的程度了。

源：[[备份]为什么就学C/C++来说VS是渣](https://tieba.baidu.com/p/3706209867)。

原始源：[失效链接](http://www.bilibili.com/video/av2211552/) 评论 795L 。

**注释** 即便没失效也没多少意义，因为现在找不到楼层了。

　　既然有那么多外行跳出来洗VS，科普一下为什么就学C/C++来说VS是渣。

　　首先有一个前提：搞清楚自己要学的东西是什么。如果要提扩展啊专有特性啊什么的那就没边了。不到万不得已，入门绝不该碰这些恶心的玩意儿。

　　现在C的“正式版”是ISO/IEC 9899:2011，外加2012年Cor.1。Windows上，VS中的VC++的各个版本甚至都没有支持全十五年前的C99，更别说C11了。当 然，不是说其它环境就支持全或者一定吊打VC艹了，比如Linux上glibc的C11实现就不全，其中一小部分VS2013里还刚好就有（一定程度上侧 面说明了C的鸡肋，C++的标准库实现就一般是编译器厂商提供的，所以不是这样）。但是，VC++项目组长期人手不足、优先支持C++11/14/1z的 策略导致C编译器的核心实现残废是事实。拿一个靠C++拉动C实现的环境学C，怎么看都不是靠谱的策略。

　　更讽刺的是，抛开dssq被抛弃的 export不讲，VC++的C++实现都是残的（另外，各种逗比bug略）。C++98里的2 phase lookup都十几年了还没正确实现。C++11支持也是挑肥拣瘦容易得先上，而库的支持却要等到核心特性支持完整才能启动，这导致VS2015 RTM都不能支持C++11要求的库里的constexpr……这些事实表明了使用任何版本的VS在短时间内都只能用残废的语言子集。反观其它实 现，Clang++早就C++14 feature complete了，G++早就C++11 core feature complete了（libstdc++在trunk里complete），就算没有OS X不方便用Clang++和libc++，Windows上现代mingw-w64发行版在标准语言特性上长期足够吊打VC艹（似乎好像还从来没被反超 的）。

　　这种情况下vczh等还能跳出来洗什么VS "14"“（2014）年底前C++14 feature complete”还没人挂，也难怪有那么多看热闹的了。

源：[同主题](https://tieba.baidu.com/p/3706209867)。

原始源：[失效链接](http://www.bilibili.com/video/av2234283/)

**注释** 背景知识参见[关于变量](about-variables.md)。

　　B站评论比度娘还度娘了，那就顺便在这里放着好了。

　　C没有严格的“变量”，类型不止用于“变量”，“整型”和integer类型是两回事、float和浮点型不是一个玩意儿……这些姑且还是能当文字游戏先略过算了。

　　敢用//，为什么还要说“变量声明要在语句之前”呢……好吧这个就当支持VS2013前的逗比cl好了。

　　既然花了不少时间讲conversion specification，不顺便把%f在printf和scanf里的不一样的坑说清楚么。

　　“scanf……不能漏加取地址符不然一定出错”——话别说得太死好么。后面马上讲字符数组不就麻烦了。

　　嘛，没初始化的自动对象具有indeterminate value，读取这个值是UB，不保证这个值是不是有或者没有意义，就是炸了也活该。

　　然后，fflush(stdin)……具体什么意思敢不纠结是么。不纠结具体含义确实是正确姿势，然而理由是——这个也是UB……不好意思，根本不·保·证有效。

　　“不能无视编译器警告”……不会修改项目配置倒可以理解，但是下面的错误消息明明告诉了_CRT_SECURE_NO_WARNINGS，不把刚讲过的宏定义活学活用一遍么。

　　最后，UP主啥时候把源文件扩展名改正常呢。

