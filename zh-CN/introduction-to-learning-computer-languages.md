# 计算机语言学习导论

# 引言

　　因为近几个月收到了较多计算机科学基础尤其是编程语言入门指导的问题，之前也说过好几回会汇总一起解答，是时候填坑了。

　　但说实话这个坑挺大的，无法一次性填完，在这里会不定期更新。

　　因为是填坑，所以请读者当读到 **TODO** 注释时不要感到奇怪。大部分这类注释表示文档中相对较低优先级的部分，缺失可能会影响完成度，但不应影响主旨的理解。

# 历史遗留

　　早期论述片段汇总。仅供参考，初学者建议跳过。

**TODO** 可以加不少链接。

**TODO** Markdown 格式化。

## 学习经历

**注释** 免责声明：确实没什么可重复性，甚至至今除了使用的设备以外，这个偏差和普通用户相比较越来越大了。

**TODO** 另起章节补充之后的其它内容，阐明为何在没有可重复性上越走越远。

源：[这个贴吧主题](https://tieba.baidu.com/p/3388459316) 3L 。

　　感觉没啥可重复性。。。

　　就拿用什么设备|撸什么码|看什么书面材料举例好了……

* 2002-2004 文曲星PC2000C+NC3000|GVBASIC|内置帮助
* 2004-2006 文曲星NC3000*2+TC800C|LavaX/LavaX帮助手册+GVMaker文档
* 2006-2010 Dell Axim X51v(WM5/WM6+LavaXVM))|LavaX+C/ACM材料若干+ISO/IEC 9899:1999
* 2008-2012 Samsung R520+iDSL(DSTT)+HP iPAQ212(WM6/WM6.1/WM6.5)|C/C++|ISO/IEC 9899:TC3+/TC++PL/D&E/ISO/IEC 14882

* 2012- Dell 14R Turbo+iDSL+HP iPAQ212|C/C++|ISO/IEC 9899 2011:Cor1 ISO/IEC 14882:2011

　　材料：学校书本略（基础课的东西主要是让我来找错的）、所有没有被出版的略（比如WG14/WG21的paper）、认真看了50页以下的略（比如C艹Primer啊Haskell 2010啊算导啊TAOCP啊还有HoTT之类的数学书什么的）。

　　对别人来说应该没啥可操作性。。。比如C的书老实说之前一本都没正经看过，第一本正经看的就是C99，技术问题不管什么方面从来都是有问题直接Google懒得问人……居然没走岔路。有谁跟我一样奇葩么。

## 入门书目问题 [1]

源：[这个贴吧主题](https://tieba.baidu.com/p/5759976927) 14L 。

　　C++入门书？Bjarne Stroustrup的The C++ Programming Language，虽然我也没耐心看几百页就去直接读ISO C++了。

　　嫌难就找Bjarne Stroustrup的Programming: Principles and Practice Using C++，对多数人来讲应该更容易点。The design & evolution of C++这本不是入门的，但研究语言设计理论的，可以当消遣性历史读物，用于通过自测不看书之前的理解是否对路帮助评判自己悟性如何。

　　以下只能给出常识性评价。

　　首先，权威文档是 ISO C 和 ISO C++ 。有错误可以翻 open-std.org 的 defect report 和 paper 考古。其它靠谱点的书基本都有 errata ，不过相对没那么容易及时修bug。

　　C的话就是 K&R 的 The C Programming Language ，不过也可能有一些错误，所以随时准备考虑 ISO C 修正。

　　C++入门的除了 BS 也就 Scott Meyers 的书稍微能看点。Herb Sutter 和 Andrew Koenig 也算稍微高级那么点的话题的靠谱的作者（也包括一些关于 C 的说法）。这里提一下 Accerated C++ 风评还可以，但是应该比较旧了。相对来讲一些讲C++惯用法的书（[More] Efficient/Exceptional C++）和以及讲C相关的书如 C Traps and Pitfall 这种相对不那么容易过时，特别是后者——因为语言在这方面变动比较少。

　　不推荐 C++ Primer 的原因是 Lippman 的文笔以及一些其它编排问题。以及读者认知偏差会比其它正经经典书更多。

　　Primer 后带 Plus 的不管是 C 还是 C++ 都是著名李鬼。作者应该不太懂关键知识点。

　　谭×之类的国产作者写这类书一般不作考虑——如果你不想返工重来一遍的话。尽管书本身的销量可能最多。

　　另外这里一个经验之谈是，如果一个作者既写 C++ 又写 Java 或者其它语言的基础教材，那么基本上至多只会有其中一门语言稍微靠谱点。比如谭×也就是写 BASIC 的书还行。当然，更可能的是没一本书靠谱。因为写靠谱的作者需要同时对不同语言的 spec 有深入准确的理解，这类作者一般不会去有空写这种书。（换做是我，要不是需要重复科普废话实在太多，带人灌水 paper 都来不及呢……）

　　如果有能力读原著，那就考虑直接读原著，因为译者的下限会把书的内容质量下限再过滤一遍，而译者普遍水平比坐着更差，虽然不排除个别还算靠谱的。尤其应慎重选择教科书的译著以免先入为主。裘宗燕的翻译质量整体还行，但有些术语明显偏离惯用法。其它自己搜风评。

## 入门书目问题 [2]

源：[这个贴吧主题](https://tieba.baidu.com/p/6113807981) 15L 。

　　虽然吧规有给清单，不过我本人不推荐任何书，更反对没其它编程语言的经验直接上手 C++ 。你不是天选之人，没本事把一坨蠢书的 bug 都找出来，之后事半功倍就等着呵呵吧。

　　硬说的话，SICP 旧版和 CSAPP 打底，基本上看懂（不一定需要做题，看各人本事）以后学其它语言稍微容易点。讲 ALGOL-like 语言的国产书和带 Primer 的都更不推荐，稍微要上路点的，C 可能一本合格的都没有，C++ 看 Bjarne Stroustrup 的出版年份较近的入门读物。（我不给具体书名。如果找不到，说明基本不适合学这玩意儿。）但是你非得要“速成”，除了会啃权威文档习惯快速断章取义给书找 bug 以外基本没什么办法——跟某些没经验者的不同，这就是已知最快的方法（只不过对基础技能要求比较高，但说白了也就是一般专业要求而已），除非你有本事发明你学的东西（但即便是有，也就是快慢的区别，参考权威文献对这种 artifact 是批判的基础所以不可能省掉）。当然，LZ 可以抱怨短时间吃 3 本书强人所难，不过 LZ 的问题本来就是这个状况，何况就现在本科教师普遍连什么权威材料该参考都搞不清楚的教学质量，大多数专业 4 年出来的基本也都达不到这个入门水准。

源：[同主题](https://tieba.baidu.com/p/6113807981) 16L 。

　　关于 SICP 之类的前期入门问题，免责声明：我没全部审阅过。但是我还是没找到更好的替代，所以顺便解释一下。

　　虽然我是所有都自学的，不过路径和进度都比较奇葩（远超出科班教学规划并且直接能给当期教材审校的程度），所以本身不怎么有参考性。

　　例如，我正式学 C 是直接读的 ISO/IEC 9899:1999 （之前有一些 BASIC 和个别小的嵌入式设备的 C-like 的基础，也是翻手册学的），反过来看 C 的教科书都是各种惨不忍睹了，包括 K&R 。具体坑哪先不多展开。

　　然后，C++ 我翻了一遍 BS 的 TC++PL 100 来页，就懒得多看了，直接翻 ISO/IEC 14882 的 draft 对照最新进展来试验。

　　这些学习路径对一般教师和学生确实强人所难。

　　不过我发现我还是漏掉了一个优化，那就是 SICP 。当年有个出国的学生（记得是哲学类贴吧遇到的，现在反正不混贴吧了）百度消息问我里面的问题，我第一反应是“什么鬼”，还提醒应该多了解些“函数式编程”，现在看来可能是黑历史了，直到我自己之后重新开始自己设计语言，从 λ 演算开始开始推出“纯粹”的计算模型，才发现 Scheme 的设计显然的清晰之处。

　　（还有个理由是，论长度，RnRS 显然比 ISO 的裹脚布清爽多了……差了几十倍。这导致原则上我对 LZ 这样的没基础的同学入门 C++ 这样的玩意儿持悲观态度，因为不管是什么书，杂七杂八的内容的数量就放在哪里，没基础就意味着不知道什么算是入门，哪些只是为了入门就能跳过的而节约时间。）

　　这时候我重新看了一部分 SICP （因为早就对非 spec 类文献习惯性速读，习题全部跳过不评价），发现里面确实有不少东西讲得比几乎所有其它入门教科书都清楚。

　　不过，以现在的眼光看，主要仍然是前几章的内容耐看。之后的内容有更多其它专业文献参考，对使用的语言本身的设计的要求也比较高。很遗憾，大部分语言属于“不怎么样”的一类（比如没有 proper tail recursion ）。

　　新版用 Python 的 SICP 在目的上实际出现了偏差。按 Gerald Jay Sussman 的说法，他想教的是 computer engineering ，而我这里说的纯粹就是 programming 的入门。

　　具体内容的问题，随便举个例子：

> Statements & Expressions. Python code consists of statements and expressions. Broadly, computer programs consist of instructions to either\
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute some value\
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Carry out some action\
> Statements typically describe actions. When the Python interpreter executes a statement, it carries out the corresponding action. On the other hand, expressions typically describe computations that yield values. When Python evaluates an expression, it computes its value. This chapter introduces several types of statements and expressions.

　　从语言设计的角度来说，贸然把语句(statement) 和表达式(expression) 并列起来并不是什么好的讲法。

　　其实这里没有很好地抓住重点，而以至于偏差。

　　表达式来自并扩充了代数学上的一些习惯性表示，其目的起先是为了计算(computation) ，这点并没有错。

　　但是对非纯函数式的语言来讲，计算并不是使用表达式的唯一能表达的计算作用(computational effect) 。

　　在这里所有之前提到的语言的表达式的求值(evaluation) ，都是可能带副作用(side effect) 的——例如，输入/输出。这意味着一般的表达式同时可以 carry out some action 。

　　而语句确实经常只是为了 carry out some action ，但所有之前提到的这些语言中都是可以用表达式构建的。

　　所以把语句和表达式并列地讲，已经造成了先入为主的印象偏差。这不适合一般的“编程”基础（事实上，旧版 SICP 使用的 Scheme 就不是，下面会讨论）。

　　理论上正确一些的要点是，表达式包含的子表达式求值的顺序并不固定（尽管语言可以添加规则约定顺序），而“语句”必须是限定顺序的。这也是为什么语句对副作用的语言来说是个相对重要的构造，因为副作用（例如输入/输出）随意交换顺序可能会改变程序的可观察行为，用户通常必须指定顺序。而表达式则是一般地包含 compute some value 和 carry out some action 这两个职责的构造。

　　自以为已经入门的同学可以自测一下，有多少书本和老师会讲清这个的？如果真靠你自己的思考就能得到这个结论，可能就已经“入门”了。

　　至于我是在接触其它书之前独立通过 ISO C/C++ 的 function invocations do not interleave 规则发现的，后来才发觉这个就是理论计算机科学中经典的 applicative order （使用 currying 的话就无所谓 leftmost first ）。

　　题外话，其实从上面的讨论也可以看出，人为地在语言中区分出语句和表达式本来就不是什么容易理解的设计。像 Python 之类就属于这样的一开始就不怎么容易理解的语言。

　　反过来，Scheme 是不强调语句的概念的。在 Scheme 中，顺序的表达式求值使用特殊形式(special form) （在 R7RS 改称表达式类型(expression type) ） begin 。也就是说，实质上的语句的功能在 Scheme 中是用一个非常局部的语言特性就能实现的，这并不是什么大不了的认识。

　　然而对 ALGOL-like 语言（以及 Python 这样的大杂烩）入门的更多人来讲，他们是很长时间中都没有意识到这点的机会的。所以他们以后学不是这样设计的语言时，就要付出本该避免的更大的代价来摆脱思维定势。

　　当然，有的同学可能会问，首先用语句来作为最普遍的基本结构不也是很正常的吗？

　　这个问题也很简单：即便你有了语句，现实中也摆脱不了表达式。表达式具有子表达式这种递归的语法和对应的求值规允许以很小的代价使通过组合复用计算结果，而语句只支持顺序的描述，并且常规用法中不能直接把它当作表达式来用。

　　只有类似语句而没有类似文法的表达式结构，是没法表示灵活的抽象的，于是使用这样的语言，就被迫发明类似的高级语法扩展。

　　常见的大概也就一些汇编了（然而一般的汇编器实际上还是支持表达式的，还有更高级的抽象，所以事实是摆脱不掉；都有嵌套递归语法的设计在里面）。

　　这样的语言中，顶层上基本也是不符合结构化编程(structure programming) 的要求的，以至于只使用这样的构造，没法在现实中使用。（直接点说，和 SICP 要介绍 function 进行抽象的做法是矛盾的。）

　　结果，你学习这样强调语句为描述操作的基本单位的语言（虽然不严格，通常所谓的指令式语言(imperative language) 都是这样），需要同时了解表达式和语句，有的时候可能还要纠结什么时候使用语句，而没有清晰地了解或者忘记“我需要顺序就使用语句”这个本质需求。

　　作为普遍现象，这样的需求错位还带来了语言从设计到学习上的混乱。一个经典的冗余设计是 C 的 while 的条件，因为语法设计没法往里面塞语句，就需要用逗号表达式往里面实现语句的功能。（不像 C++ ，还有逗号重载而显得区分起来有点意义，虽然那个工程上基本上更恶心而更糟糕。）

　　让这样的语言设计流行起来，入门的错误姿势大概“功不可没”。语言的设计者也得通过对语言的学习入门，并且先入为主地对这样的语言更熟悉，于是市面上这样的语言就更多。所以，“工程”方面就更容易见到这些语言。但是，以“编程”为目的入门不应该受到这个结果的影响而增加工作量。

　　类似地，还有强调 proper tail recursion ，以及强调递归比循环更普遍（类似表达式比语句更一般化）也是常常会被忽视的理论计算机科学的传统。

　　这样做在表达计算目的和简化语言设计上其实是有很明确的目的的（虽然原理比较复杂，暂略），而许多语言通常没有独立的理论基础（例如操作语义模型），会漠视这个需求。

　　除了传统指令式语言的流行，这很大程度可能是“工业界”语言的设计者本身缺乏学术背景和训练的原因，以至于看不清这样的思路来简化更一般的设计问题。

　　像 Python 的设计者 Guido van Rossum ，早年就分不清 proper tail recursion 和 tail call optimization 的概念（这或许还情有可原，很多搞 Lisp 的都没分清），而且还以“难调试”作为不支持的借口，贻笑大方。

　　为了文明用语，暂时先不对其它具体讲法进一步长篇大论了，有问题可以个别提问和讨论。

源：[同主题](https://tieba.baidu.com/p/6113807981) 18L 。

　　还有一段 disclaimer 漏了，补充给了解 Scheme 的同学，虽然我认为 Scheme 很多地方设计得更正确，不过请勿在这个议题上误认为我是在单方面鼓吹 Scheme ：

　　就 begin form（其它 Lisp 可能用 progn 代替，对 C-like 语言来讲就是内建的分号——原则性表示“语句”的分隔符），Scheme 的具体特性的设计其实也不咋地。

　　事实上在 RnRS 的 derivation 中，可以看到 begin 使用宏基于 lambda 实现的。也就是 Scheme 的 lambda form 其实蕴含了“顺序”求值表达式的作用，在我看来违反了单一职责原则，并且 parse 起来容易错（可读性上还不如分号+}来得显眼）。

　　我已经在类似的语言中实现了不用任何原生顺序结构，只用函数调用的 applicative order 就派生出来类似 begin 的操作。（这种做法首先来自 John N. Shutt 的 Kernel ，不过我做的不要求 GC 。）

　　说起来倒是跟 Haskell 用 monad 实现 do-notation 有点像，但我全然不喜欢 monadic 的提法，因为说白了起作用的就是某个 monad law 但实际上应该叫 applicative 性质的东西而已。

### 延伸阅读：关于语句和表达式

　　参见这个 [SO 回答(en-US)](https://stackoverflow.com/questions/19132/57619680#57619680) 。

**TODO** 析出文献。

## 关于开发工具

**注释** 以下仅代表历史观点。虽然直至 2023 年 VC++ 因为并没有方便到哪去仍然不是首选（除非已经为了学习 VC# 等原因安装好了 VS 想在配置环境上偷懒），有些缺陷是改进，到能用的程度了。

源：[[备份]为什么就学C/C++来说VS是渣](https://tieba.baidu.com/p/3706209867)。

原始源：[失效链接](https://www.bilibili.com/video/av2211552/) 评论 795L 。

**注释** 即便没失效也没多少意义，因为现在找不到楼层了。

　　既然有那么多外行跳出来洗VS，科普一下为什么就学C/C++来说VS是渣。

　　首先有一个前提：搞清楚自己要学的东西是什么。如果要提扩展啊专有特性啊什么的那就没边了。不到万不得已，入门绝不该碰这些恶心的玩意儿。

　　现在C的“正式版”是ISO/IEC 9899:2011，外加2012年Cor.1。Windows上，VS中的VC++的各个版本甚至都没有支持全十五年前的C99，更别说C11了。当 然，不是说其它环境就支持全或者一定吊打VC艹了，比如Linux上glibc的C11实现就不全，其中一小部分VS2013里还刚好就有（一定程度上侧 面说明了C的鸡肋，C++的标准库实现就一般是编译器厂商提供的，所以不是这样）。但是，VC++项目组长期人手不足、优先支持C++11/14/1z的 策略导致C编译器的核心实现残废是事实。拿一个靠C++拉动C实现的环境学C，怎么看都不是靠谱的策略。

　　更讽刺的是，抛开dssq被抛弃的 export不讲，VC++的C++实现都是残的（另外，各种逗比bug略）。C++98里的2 phase lookup都十几年了还没正确实现。C++11支持也是挑肥拣瘦容易得先上，而库的支持却要等到核心特性支持完整才能启动，这导致VS2015 RTM都不能支持C++11要求的库里的constexpr……这些事实表明了使用任何版本的VS在短时间内都只能用残废的语言子集。反观其它实 现，Clang++早就C++14 feature complete了，G++早就C++11 core feature complete了（libstdc++在trunk里complete），就算没有OS X不方便用Clang++和libc++，Windows上现代mingw-w64发行版在标准语言特性上长期足够吊打VC艹（似乎好像还从来没被反超 的）。

　　这种情况下vczh等还能跳出来洗什么VS "14"“（2014）年底前C++14 feature complete”还没人挂，也难怪有那么多看热闹的了。

源：[同主题](https://tieba.baidu.com/p/3706209867)。

原始源：[失效链接](https://www.bilibili.com/video/av2234283/)

**注释** 背景知识参见[关于变量](about-variables.md)。

　　B站评论比度娘还度娘了，那就顺便在这里放着好了。

　　C没有严格的“变量”，类型不止用于“变量”，“整型”和integer类型是两回事、float和浮点型不是一个玩意儿……这些姑且还是能当文字游戏先略过算了。

　　敢用//，为什么还要说“变量声明要在语句之前”呢……好吧这个就当支持VS2013前的逗比cl好了。

　　既然花了不少时间讲conversion specification，不顺便把%f在printf和scanf里的不一样的坑说清楚么。

　　“scanf……不能漏加取地址符不然一定出错”——话别说得太死好么。后面马上讲字符数组不就麻烦了。

　　嘛，没初始化的自动对象具有indeterminate value，读取这个值是UB，不保证这个值是不是有或者没有意义，就是炸了也活该。

　　然后，fflush(stdin)……具体什么意思敢不纠结是么。不纠结具体含义确实是正确姿势，然而理由是——这个也是UB……不好意思，根本不·保·证有效。

　　“不能无视编译器警告”……不会修改项目配置倒可以理解，但是下面的错误消息明明告诉了_CRT_SECURE_NO_WARNINGS，不把刚讲过的宏定义活学活用一遍么。

　　最后，UP主啥时候把源文件扩展名改正常呢。

# 概述

　　计算机语言是在计算机上为处理信息等目的而设计和实现的*人工语言(artifical language)* ，包括*通用目的语言(general-purpose language)* 和*领域特定语言(DSL, domain-specific language)* 两类。

　　人工语言和*自然语言(natural language)* 相对，最显著的区别是人工被人为地*设计(design)* 而非*演化(evolute)* 。自然语言的演化过程中不排除*正字法(orthography)* 等的人为干预，但主要的现象仍然来自演化的结果。而人工语言不需要遵从受到不可控环境演化规律的影响，原则上完全使用人为指定的*规则(rule)* 。

　　一般地，通用目的 PL 具备*可编程性(programming)* ，能表达程序代码。这类语言称为*编程语言(PL, programming language)* 。DSL 可能是 PL 。其它的领域特定语言可能仅为了描述数据格式而不要求使其代码被作为程序，因此不视为 PL 。

　　广义的*语言学(linguistics)* 同时以自然语言和人工语言两者为研究对象，但初始的对象仅是自然语言。有的人工语言（如世界语）是人为创造的自然语言替代品；与此不同，计算机语言首要便于计算机处理，而非以自然语言的方式使用，它一定是书面语。语言学中，处理自然语言的一些分支，如*语音学(phonetics)* ，在计算机语言中不再适用。因此，可以认为计算机语言是具有更大限制性的语言。

　　但因为侧重的目的过于不同，不仅研究对象的普遍规律不同，传统的语言学的方法论也经常不在计算机语言上生效；并且，完善的人为设计能排除重新发现和应用外部规律的需要。因此，指导计算机的不是语言学，而是*编程语言理论(PLT, programming language theory)* ，这可被认为是一种数学分支。其它的不具有足够可编程性的计算机语言，仍然能被 PLT 解释。

# 入门策略

　　要入门，首先需要看到门在哪里。

## 场景

　　对初学者而言，一般首先通过某一门具体 PL 来接触使用语言编写程序这样的主要场景。但是，尽管大多数学习者首要关心这个场景，**学习语言和学习编写程序实际上是两回事**。学习语言的知识至少还是**改进语言设计**这样的任务场景的基本要求。因此，“门”的指涉也相应地不同：

* 如果只是想要编写程序，入门可以是了解环境的搭建并实际写出可以运行的程序。
* 如果是学习语言，入门是掌握如何参照基本规则适应不同的使用场景的一般方法。

　　编写程序是一个主要场景，但不是全部。作为更一般地情形，后者的要求显然高于前者。对后者，“门”具体是指**权威的语言规则**。

## 规范

　　作为人工语言，这些规则应当是**明确的**。一般计算机语言的规则通过语言*规范(specification)* 或称为规格说明的文档描述。由于计算机语言的*实现(implementation)* 通常是软件，这同时也是语言实现的软件规格说明书的公共组成部分——具体实现可能有更具体的扩展。例如：

* Java 语言的语言规范是 JLS(Java language specification) ，通过 JVMS(Java virtual machine specification) 提供一些实现的更具体的规范。
* C 语言的语言规范是国际标准 ISO/IEC 9899 ，具体实现的规格说明由提供实现的各厂商自行维护。

　　语言规范应当确保提供足够完整的语言规则，这些规则定义了*符合性(conformance)* ，即判定一个实现是否构成语言规范中的规则*定义(define)* 的语言。符合性规则包含了对实现的*要求(requirement)* 。因为实现不需要被无条件要求能接受任意输入，语言规范通常也规定对实现可接受程序的要求。因此，语言规范能够定义清楚什么样的代码才是符合要求的程序，而间接明确了如何写出正确的程序的**最低要求**。

　　因为语言规范中语言规则不依赖具体实现细节，掌握语言规范和其它一些 PLT 和实现的知识，用户应当就能自行实现语言。满足符合性的语言实现之间允许存在实现环境要求和支持特性集等差异，而形成被实现的语言的不同的*方言(dialect)* 。语言规范中的符合性规则同时也是检验不同方言之间的兼容性的准则。

　　理解和掌握如何去寻找这些明确的语言规则，可以认为是入门了。就那么简单。

# 现实应对

　　然而实际情形更加复杂一些。有时语言只有一种实现，可能不提供语言规范，而直接发布实现（如解释器和编译器），同时给出指导如何使用实现的*参考手册(reference manual)* 。参考手册是提供给用户的具体实现的使用说明书，通常是规格说明的简化版。此时权威来源只此一家，由于人工语言的特殊性，用户没法擅自添加规则（除非同时维护自己的实现），所以参考手册会被勉为其难地被作为语言规范来使用。这样的语言如 Python 和 Rust 。

　　作为对比，参考手册只需要描述具体实现的行为和使用方式，不一定提供完整的语言规则，因此通过参考手册开发方言虽然不是不可能（如 Python 在 CPython 之外还有 PyPy 等），但因为规则不够清晰，难度可能更大，出现更多的兼容性问题。

　　严格来说，没有语言规范的人工语言设计是残缺的。不过，对实用计算机语言这样复杂的情形，语言规范的起草要求较高，乃至工业语言的设计者自身都不一定有能力独自完成（而需要专家委员会或志愿者协助），使用参考手册凑数作为妥协也并不少见。

　　其它的文献，例如关于 PL 的教科书，一般都是二次开发作品，在描述什么是语言上权威性更弱。有少数的例外：语言的原始设计者在起草语言规范前提供的替代文献。例如，C++ 标准的第一版（即 ISO/IEC 14882:1998 ）之前，Bjarne Stroustrup 的 *The Annotated C++ Reference Manual* 虽然体例和名义上是参考手册，实际起到了语言规范的作用（当时已有多个语言实现），因为没有更权威的完整语言规则的来源。

　　遗憾的是，大多数新手只接触到如何入门编写程序的文献，甚至这些文献在编写程序上的入门都很不完善，却没有意识到基础的不完整。结果，先接触这些文献的用户，可能了解在特定情形下如何写出可运行的程序，但实际上没有能力**在最基本的情形保证**总是按照预期运行。

　　例如，首先试图用编译器生成的汇编代码来解释 C 程序如何运行的用户，通常不会理解 C 的*未定义行为(undefined behavior)* 的具体外延和排除方法。一旦更换编译器版本、操作系统、具体程序输入甚至什么都不变，程序就可能罢工，但这种差异的来源并非是生成的代码，而可能是因为按照语言规范（这里是 ISO C ）源程序自身存在缺陷，连维持正确的最低要求都没达到。

　　一旦习惯这种思路，要进一步确保写的程序能符合最低正确性要求的、可被人理解，往往比纯新手入门还困难，因为首先要摒除错误姿势的形成的思维定势。

　　因此，作为初学者，应当注意，即便仅是为了学习编写程序而不是全面掌握语言的实用，这样地**一知半解入错门还不如不入门**。

## 局限性

　　应当了解，语言规范规定关于语言的规则并不一定在语言外适用。特别地，它可能不适用于概括不同语言的不同规则，乃至术语都不通用。对要求*多语言(ployglot)* 理解的一般情形，通常应了解 PLT 的惯例。

　　但是，一般初学者不足以有条件分辨到底哪些语言中的定义符合一般惯例。这种情形下，须对具体语言提供的定义保持足够的怀疑，即默认不要把未经确认的术语和规则套用到其它语言中，以免形成错误理解和以讹传讹。

　　一些体现现有具体语言的复杂和混乱情形的实例：

* 一些重要基本概念，如*变量(variable)* 和*对象(object)* ，定义在各个语言中存在出入。
	* [JLS 规定*变量(variable)* 是带类型的存储](https://docs.oracle.com/javase/specs/jls/se20/html/jls-4.html#jls-4.12)，[Go 语言规范也类似](https://go.dev/ref/spec)，而这实际相当于 ISO C 和 [ISO C++ 中*对象(object)*](https://eel.is/c++draft/intro.object#1) 的概念。
	* ISO C [没有变量的正式定义](https://github.com/FrankHB/pl-docs/blob/master/zh-CN/variables.md)。
	* [ISO C++ 的变量](https://eel.is/c++draft/basic#def.odr-5)总是具名的。这符合数学传统，同时和 ISO/IEC 2382 的定义兼容。
	* Java 和 Go 语言的定义和数学传统以及遵循这个传统（“变量的值不可变”）的纯函数式语言（如 Haskell ）中的定义（特别地，*类型变量(type variable)* ）是冲突的。
	* 事实上，[JLS 中直接定义了类型变量](https://docs.oracle.com/javase/specs/jls/se20/html/jls-4.html#jls-4.4)，是符合数学传统的；但类型变量不是变量，直观上存在矛盾。
* ISO C++ 规定[*多态类(polymorphic class)* 是具有虚成员函数的类](https://eel.is/c++draft/class#virtual-1)，但实际上这里的*多态性(polymorphism)* 在一般意义上在一般意义上的特殊情形，即[*包含多态(inclusion polyrphism)* 或称*子类型多态(subtype polymorphism)*](https://zh.wikipedia.org/zh-cn/%E5%AD%90%E7%B1%BB%E5%9E%8B) 。
	* 尽管没在语言规范中明确，C 和 C++ 的*强制(coercion)* 是一种*特设多态(ad-hoc polymorphism)* 。
	* C++ 的*重载(overloading)* 是另一种特设多态。
	* C++ 的类模板是*参数多态(parametric polymorphism)* 。
	* 上述其它形式的多态在历史上早于包含多态的出现。

　　此外，由于大多数语言的设计者未必具有足够的 PLT 背景，他们的作品不一定能够正确反映一般语言的知识。语言的实现者也未必足够清楚关于设计上的知识。例如：

* Python 的设计者[承认不清楚尾调用和循环的区别](https://neopythonic.blogspot.com/2009/04/final-words-on-tail-calls.html)。
* Go 语言的设计者[看来不清楚*名义类型(nominal typing)*](https://www.reddit.com/r/programming/comments/chrtx/rob_pike_on_how_and_why_googles_new_go_language/) 。
* Lisp 方言的一些编译器作者使用[*尾调用优化(TCO, tail call optimization)* 但并不清楚*真尾递归(proper tail recursion)* 的一般性质，造成一些混乱](https://groups.google.com/d/msg/comp.lang.lisp/AezzhxTliME/2Zsq7HUn_ssJ)。

　　看起来可能是专家的语言设计和实现者尚且如此，没有足够参与语言维护工作的一般用户的观点同样（如果不是更）可能是相当地不可靠的，**这包括大多数的高校教师**。因为大学的具体 PL 课通常是基础课，可以理解通常难以配备足够的专家作为师资。

　　而可能出人意料的是，**相当一部分的教科书作者也不可靠**。因为编写教科书的要求和语言规范不同，为了容易理解，**可能更难以保证正确性**。

　　更困难的一个问题是，几乎任何一个实用计算机语言其实都已经复杂到不适合没有完全没有理论计算机背景知识的学习者。而很多基础课（如关于体系结构或者算法的）却又经常要求有学生有 PL 的基础，否则难以理解其中“为何如此设计”的原理——因为它们要么是适应 PL 的局限性要么是会使用 PL 的方法描述内容，根本无法彻底抽象掉。

　　所以真正的零基础入门，无论只是为了学习编写程序，还是更一般地掌握 PL ，唯一比较可行的就是选择比较简单的实用通用目的 PL ，然后了解如何使用 PL 的主要方式，再在必要时根据领域选择不同的具体 PL 进一步学习。

## 文献选择

　　如果有条件，例如已经有其它类似的 PL 学习基础，且语言规范文档容易获得，那么应当直接使用语言规范。

　　若研究需要，则优先使用补充的第一手来源（论文、报告和专利等）。仅当同行评审或教学需要时，才有必要参考二手资料。

　　如果要仅针对特定的语言选读非权威文献，则**一般建议选择语言设计者的著作**，这至少能接近原始的设计。

　　而 PLT 则视为单独的领域。但是，PLT 有非常多细分领域，即便是知名的著作也未必在每个方向上都保证可靠。如果需要了解，请务必做好**考察原始文献（主要是论文）的准备**。

　　对零基础入门，实现上节的策略建议选择 [SICP 2nd edition](https://web.mit.edu/6.001/6.037/sicp.pdf) ，这是 MIT 课程编号 6.001 的同名经典课程的经典教材（没有之一）。理由是：

* 此书使用 [Scheme](https://www.scheme.org) 作为教学 PL 。
	* Scheme 的核心语言特性相对简单但很灵活，程序代码也较紧凑，不用花费多少时间学习即可以求解描述较复杂的问题，零基础适应编程方法这个目的性价比较高。这在书中有直接体现。
	* Scheme 语言规范 [R<sup>n</sup>RS](https://standards.scheme.org/) 以简洁而紧凑著称，篇幅较短信息集中，体例较为严谨，质量相对较高，适合初学者熟悉语言规范的写作风格以及练习从语言规范文档检索信息。
	* Scheme 要求支持真尾递归，确保尾递归和循环在计算复杂度上等价，避免一开始需要记忆过多的控制结构语法，有助于养成对*过程式范型(procedural paradigm)* 的正确认识。
	* 作为通用目的 PL ，Scheme 在*函数式编程(functional programming)* 、DSL 和动态语言等多个方面都可以作为典型的实例直接使用。
	* 作为早期 LISP 的演进，也和其它 Lisp 方言在很多特性上通用；同时还直接影响了一些流行语言如 JavaScript 。了解 Scheme 对学习这些语言有帮助。
	* Scheme 具有天然的 PLT 背景，是该方向的学习者入门的起点之一（尽管 SICP 并没有详细展开）。
		* 其原始论文 [R<sup>0</sup>RS](https://standards.scheme.org/official/r0rs.pdf) 直接扩展无类型 λ 演算，而这是所有通用目的 PL 研究无法绕开的基本模型，因为它在一定程度上定义了**所有高级语言的公共特性子集**。
			* 相对地，和 λ 演算作为计算模型在*计算表达性(computational expressiveness)* 等价的*图灵机(Turing machine)* ，没有实用 PL 的近似对应，除非有谁能把 [Brainfuck](https://esolangs.org/wiki/Brainfuck) 用成实用 PL ……
			* 另一个和 λ 演算计算表达上等价的重要模型——*组合子逻辑(combinationary logic)* ，近似的 PL 主要是 [Unlambda](https://esolangs.org/wiki/Unlambda) ，闲着也可以试一下……（然后会发现要写程序基本得熟悉 λ 演算否则拆不掉 λ 抽象。）
		* Scheme 演进的 [Racket](https://racket-lang.org/) 是*面向语言编程(LOP, language-oriented programming)* 的主要代表，也是 PL 研究中实现原型的主要工具之一。
* 涉及的应用领域的广度超越大多数入门级 PL 读物，许多方面不容易简单地找到替代文献。
	* **正确**地展示了如何合理使用不同形式的递归，而非流于表面和纠结具体实现细节。
	* 涉及过程式、函数式和*逻辑编程(logical programming)* 等范型。
	* 明确了*续延(continuation)* 和*求值器(evaluator)* 等基础概念。
	* 有的实用编程技巧（如 streams ）经常被误认为进阶内容，在此接触有助于避免日后一些不必要的神秘感。
* 作为入门教材，基本没有局部错误和偏离主题的现象，不容易对其它领域或其它 PL 的进一步学习造成先入为主的负面影响。
	* 也许除了可能嫌弃其它语言不够灵活……
	* 作者[之一](https://en.wikipedia.org/wiki/Gerald_Jay_Sussman)是 Scheme 的主要设计者，PL 上基本不用担心专业性问题。
* 作为经典，久经考验。
* 可以找到原作者教学的视频资源。虽然其实看书就够了。

　　但同时要注意，除非直接在 MIT 上课，最好**不要**使用 Python 作为教学 PL 的新版本：

* 尽管也能完成基本的课程目标，Python 版本基本上缺乏所有以上 Scheme 具有的优点。
	* Python 在零基础的意义上没有 Scheme 简单，例如需要纠结语句和表达式。
	* Python 没有正式语言规范只有[语言参考文档](https://docs.python.org/3/reference/)，体例质量和通读难度上都不如 [R<sup>n</sup>RS](https://standards.scheme.org/) 。
	* 在初期接触 Python 的一些限制性设计（如 lambda 表达式只有一行，没有真尾递归）不利于养成良好的编程习惯。
	* 学了 Python 再学别的语言可能不那么有参照性。
* 新版质量相对较差，例如关于语句和表达式直接并列的讲法不严谨，容易造成错误理解。
* 新版替换掉了一些经典内容，虽然更接近当前实用场景，但也意味着这部分内容更容易被其它“现代”的参考文献替换。
* 使用这个版本的一个理由是和数据科学课程衔接，因为该领域流行使用 Python ，能减少学习工作量。
	* 不过这方面只会 Python 实际可能不大够用（比如经常还得会 C++ ），所以这个入门姿势收益可能不一定明显，而影响以后不太有机会纠正的基础理解明显是亏的。

　　其它要点：

* 如果日程紧凑，需要安排其它课程，可以只看前 3 章。
	* 因为这里的依赖不是线性的，前面的章节和入门这个目的相关性较高，后期的内容可以作为进阶内容学习。这时可以针对性参考其它更详细的文献而非入门读物。
* 如果日程仍然紧凑，可以跳过习题。
	* 但需要自行另外验证学习效果。

## 做题

　　一般顺序是靠谱的教材的题目做一部分或者全部。应试随意。

　　有些题**可以看看但不去解**。在不解题的情况下理解出题的思路不一定比解题容易，**可能比解题还重要**。不过这要求正确判断问题在涉及问题领域中的重要程度，对初学者较难。

　　除非对竞赛感兴趣，刻意刷所谓的“算法题”对一般从业者没多大必要。因为**实际干活的场景比单纯实现算法经常麻烦得多**，搞不好配个环境都有技术门槛，这种**不容易训练的技能更该趁早对付**。刷题除了有时间限制，某种意义上只是简化了规则的舒适区。

　　笔者的经验比较极端：因为入门就是从语言手册和规范文档开始，之后才参考普通的著作（包括 SICP ），原则上不是为了挑作者的错就全部跳过题目，而直接用解决项目中的实际问题代替；偶尔兴起直接出题再比较出题思路。这么做：

* 首要好处是节约学习时间。特别地，减少训练**正确高效地提出和总结问题**这样的（相对如何实现还可能更重要的）研究和工程技能所花费的时间。
* 稳定工作流：
	* 为什么重复造轮子，现成的不香？
	* 非要自己实现……如何实现？肌肉记忆不够？
	* 剩下的……世界那么大，旮旯那么多，临时找文献都比回忆怎么做题快。
	* 找不到，没人会，不得不自己整了，横竖都别指望快哪去。（做题也不太容易练这个。）
* 从提问入手，更容易发现现有的缺陷。
	* 有的需求就是假需求，有的问题压根就不该存在。
	* 极大地提升了**看穿过度设计**的能力。
* 主要坏处是对基础的全面要求比较高。
	* 比较吃天赋，特别吃想象力：需要能预判没经验的具体场景并承担误判风险，免得浪费时间掌握个空气还不如老实做题。
	* 入门时没轻没重，问题都怎么没见识过所以不太会正确评价具体问题的重要程度，实操很容易在分配资源上跑偏。
* 题外话：
	* 不是复杂或偏门到一定程度，如何写出能跑的代码其实是相对容易替代的没那么智能的工作。（看看 AI 。）
	* 看代码（发现问题或为代码质量背书）比写代码可能更有技术含量。
	* 在能确保可行的前提下，通常**正确理解需求和提出设计比具体实现更关键**。
	* 如果花了过多的时间在纯粹的实现而非设计和验证设计的过程上，可能就该怀疑干的是不是太偏体力活了。
	* ~~只接到体力活没办法？摸鱼去学多点有技术含量的啊~~……其实调 bug 可能倒不那么体力活。

　　总之：

1. 量力而为。
2. 只做题死路一条。
3. 有自信可以完全不做题。

# 语言律师

　　有的人会把理解语言规则的人称作*语言律师(language lawyer)* ，这并不怎么确切。律师通常需要执业资格，而所谓语言律师并不是。并且，除了律师和法官等专业人士外，普通人也有必要了解一些法律常识；即便不是要维护语言的演化而只是利用语言来写代码的语言的普通用户，掌握语言规则的最基本知识，也同样有必要。

　　另一方面，从法的位阶来说，大部分语言规范并没有经过广泛的公开程序评审而更像“地方自治法规”，公开的技术标准才更像是“法律”。

　　这实际上确实在文本上有所体现，例如，[ISO/IEC directives, part 2](https://www.iso.org/sites/directives/current/part2/index.xhtml) 对情态动词使用 shall 而非 must 表示*强制要求(mandatory requirement)* 以及 should 表示建议的规定，和实际的英语国家中的传统法律的遣词习惯一致。当然，这种规范性主要强调形式统一，而具体表现，也有与之相同和不同的做法：

* [RFC 2119](https://tools.ietf.org/html/rfc2119) 规定关键词 MUST、REQUIRED 或 SHALL 都能表示上述 shall 的含义。
* [RFC 8174](https://tools.ietf.org/html/rfc8174) 更新 RFC 2119 ，进一步规定只有大写形式才具有特殊含义。
* 关于法律中的 shall 和 must ，存在一些长期误用的歧义，因此[学界存在争议](https://www.plainlanguage.gov/guidelines/conversational/shall-and-must/)。
* 英国法院裁定英国竞争和市场管理局终止对苹果的反垄断调查，[因为苹果上诉主张 shall 的含义是强制要求被法院支持](http://www.fosspatents.com/2023/01/apple-apparently-argues-shall-means.html)。

　　实际情况：入门阶段不太容易遇到需要律师解决的问题。

　　不要为逃避本该掌握的常识问题找借口。

# TODO

**TODO** 补充其它进阶话题。

**TODO** 补充和具体语言相关的问题。

